CCS PCH C Compiler, Version 4.084, 62285               16-Aug-12 12:59

               Filename: c:\users\akayikci\documents\kiþisel\elektronik\ccs c pic\uygulamalar\tcpserver_project\main.lst

               ROM used: 20638 bytes (31%)
                         Largest free fragment is 44896
               RAM used: 477 (12%) at main() level
                         659 (17%) worst case
               Stack:    11 worst case (10 in main + 1 for interrupts)

*
00000:  GOTO   4DF6
*
00008:  MOVWF  05
0000A:  MOVFF  FD8,06
0000E:  MOVFF  FE0,07
00012:  MOVLB  0
00014:  MOVFF  FE9,0D
00018:  MOVFF  FEA,08
0001C:  MOVFF  FE1,09
00020:  MOVFF  FE2,0A
00024:  MOVFF  FD9,0B
00028:  MOVFF  FDA,0C
0002C:  MOVFF  FF3,14
00030:  MOVFF  FF4,15
00034:  MOVFF  FFA,16
00038:  MOVFF  00,0F
0003C:  MOVFF  01,10
00040:  MOVFF  02,11
00044:  MOVFF  03,12
00048:  MOVFF  04,13
0004C:  BTFSS  FF2.5
0004E:  GOTO   0058
00052:  BTFSC  FF2.2
00054:  GOTO   0232
00058:  MOVFF  0F,00
0005C:  MOVFF  10,01
00060:  MOVFF  11,02
00064:  MOVFF  12,03
00068:  MOVFF  13,04
0006C:  MOVFF  0D,FE9
00070:  MOVFF  08,FEA
00074:  BSF    08.7
00076:  MOVFF  09,FE1
0007A:  MOVFF  0A,FE2
0007E:  MOVFF  0B,FD9
00082:  MOVFF  0C,FDA
00086:  MOVFF  14,FF3
0008A:  MOVFF  15,FF4
0008E:  MOVFF  16,FFA
00092:  MOVF   05,W
00094:  MOVFF  07,FE0
00098:  MOVFF  06,FD8
0009C:  RETFIE 0
.................... #include "C:\Users\AKAYIKCI\Documents\Kiþisel\Elektronik\ccs c Pic\Uygulamalar\TCPSERVER_Project\main.h" 
.................... #include <18F4620.h> 
.................... //////// Standard Header file for the PIC18F4620 device //////////////// 
.................... #device PIC18F4620 
.................... #list 
....................  
.................... #device adc=8 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES INTRC                    //Internal RC Osc 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES BORV21                   //Brownout reset at 2.1V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES MCLR                     //Master Clear pin enabled 
....................  
.................... #use delay(clock=8000000) 
*
002CC:  MOVLW  01
002CE:  MOVWF  FEA
002D0:  MOVLW  E3
002D2:  MOVWF  FE9
002D4:  MOVF   FEF,W
002D6:  BZ    02F2
002D8:  MOVLW  02
002DA:  MOVWF  01
002DC:  CLRF   00
002DE:  DECFSZ 00,F
002E0:  BRA    02DE
002E2:  DECFSZ 01,F
002E4:  BRA    02DC
002E6:  MOVLW  97
002E8:  MOVWF  00
002EA:  DECFSZ 00,F
002EC:  BRA    02EA
002EE:  DECFSZ FEF,F
002F0:  BRA    02D8
002F2:  RETLW  00
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
*
00252:  BTFSS  F9E.4
00254:  BRA    0252
00256:  MOVWF  FAD
00258:  RETLW  00
....................  
....................  
.................... #define STACK_USE_ICMP  1 
.................... #define STACK_USE_ARP   1 
.................... #define STACK_USE_TCP   1 
.................... #include "ccstcpip.h" 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // ccstcpip.h - Common code shared among all Embedded Internet/Embedded 
.................... // Ethernet tutorial book examples. 
.................... // 
.................... // If you are using a CCS Embedded Ethernet Board (labeled PICENS, which 
.................... // has an MCP ENC28J60) then define STACK_USE_CCS_PICENS to TRUE. 
.................... // 
.................... // If you are using a CCS Embedded Internet Board (labeled PICNET, which 
.................... // has a Realtek RTL8019AS and a 56K Modem) then define STACK_USE_CCS_PICNET 
.................... // to TRUE. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // 10/25/06 
.................... //  - Added STACK_USE_CCS_PICEEC 
.................... //  - ExampleUDPPacket[] UDP header length fixed 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define STACK_USE_CCS_PICENS   1 //TODO 
.................... #define STACK_USE_CCS_PICNET   0 
.................... #define STACK_USE_CCS_PICEEC   0   
....................  
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... #if STACK_USE_CCS_PICEEC 
....................  #define STACK_USE_MCPINC 1 
.................... #endif 
....................  
.................... /*#if STACK_USE_CCS_PICENS 
....................  #include <18F4620.h> 
....................  #use delay(clock=40000000) 
....................  #fuses H4, NOWDT, NOLVP, NODEBUG 
.................... #elif STACK_USE_CCS_PICNET 
....................  #include <18F6722.h> 
....................  #use delay(clock=40000000) 
....................  #fuses H4, NOWDT, NOLVP, NODEBUG 
.................... #elif STACK_USE_CCS_PICEEC 
....................  #include <18F67J60.h> 
....................  //#use delay(clock=41666667) 
....................  //#fuses NOWDT, NODEBUG, H4_SW, NOIESO, NOFCMEN, PRIMARY 
....................  #use delay(clock=25M) 
....................  #fuses NOWDT, NODEBUG, HS, NOIESO, NOFCMEN, PRIMARY, ETHLEDNOEMB 
.................... #elif STACK_USE_CCS_PICNET_OLD 
....................  #include <18F6720.h> 
....................  #use delay(clock=20000000) 
....................  #fuses HS, NOWDT, NOLVP, NODEBUG 
....................  #define STACK_USE_CCS_PICNET   TRUE 
.................... #else 
....................  #error You need to define your custom hardware 
.................... #endif 
....................  
.................... #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7)*/ 
....................  
.................... #include "tcpip/stacktsk.c"    //include Microchip TCP/IP Stack 
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #case 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #use fast_io(D) 
.................... #use fast_io(E) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   60000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_CCS_PICENS 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................    #elif STACK_USE_CCS_PICEEC 
....................       //no hardware definitions - everything is internal 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
....................  
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        192   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        168   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        2 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        5 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           2 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     5 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
03F68:  MOVFF  1FA,1FC
03F6C:  MOVFF  1F9,1FB
03F70:  MOVFF  1FC,03
03F74:  MOVLB  1
03F76:  MOVFF  1FB,FE9
03F7A:  MOVFF  1FC,FEA
03F7E:  MOVF   FEF,F
03F80:  BZ    3F8E
03F82:  INCF   xFB,F
03F84:  BTFSC  FD8.2
03F86:  INCF   xFC,F
03F88:  MOVLB  0
03F8A:  BRA    3F70
03F8C:  MOVLB  1
....................    return(sc - s); 
03F8E:  MOVF   xF9,W
03F90:  SUBWF  xFB,W
03F92:  MOVWF  00
03F94:  MOVF   xFA,W
03F96:  SUBWFB xFC,W
03F98:  MOVWF  03
03F9A:  MOVFF  00,01
.................... } 
03F9E:  MOVLB  0
03FA0:  RETLW  00
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = TRUE, sign = FALSE, point = FALSE; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = FALSE; 
....................          if (c == '+') 
....................          { 
....................             sign = FALSE; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = TRUE; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = TRUE; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
00A68:  MOVFF  4E,1E2
00A6C:  MOVFF  4D,1E1
00A70:  MOVFF  4C,1E0
00A74:  MOVFF  4B,1DF
00A78:  MOVLW  41
00A7A:  MOVLB  1
00A7C:  MOVWF  xE6
00A7E:  MOVLW  C6
00A80:  MOVWF  xE5
00A82:  MOVLW  4E
00A84:  MOVWF  xE4
00A86:  MOVLW  6D
00A88:  MOVWF  xE3
00A8A:  MOVLB  0
00A8C:  BRA    09C4
00A8E:  MOVLW  39
00A90:  MOVLB  1
00A92:  ADDWF  00,W
00A94:  MOVWF  4B
00A96:  MOVLW  30
00A98:  ADDWFC 01,W
00A9A:  MOVWF  4C
00A9C:  MOVLW  00
00A9E:  ADDWFC 02,W
00AA0:  MOVWF  4D
00AA2:  MOVLW  00
00AA4:  ADDWFC 03,W
00AA6:  MOVWF  4E
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
00AA8:  MOVFF  4D,00
00AAC:  MOVFF  4E,01
00AB0:  CLRF   02
00AB2:  CLRF   03
00AB4:  MOVFF  4E,1E1
00AB8:  MOVFF  4D,1E0
00ABC:  MOVFF  4E,1E3
00AC0:  MOVFF  4D,1E2
00AC4:  MOVLW  7F
00AC6:  MOVWF  xE5
00AC8:  MOVLW  FF
00ACA:  MOVWF  xE4
00ACC:  MOVLB  0
00ACE:  BRA    0A20
00AD0:  MOVFF  00,01
00AD4:  MOVFF  03,02
.................... } 
00AD8:  GOTO   0BEA (RETURN)
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
009B0:  MOVFF  1E2,4E
009B4:  MOVFF  1E1,4D
009B8:  MOVFF  1E0,4C
009BC:  MOVFF  1DF,4B
.................... } 
009C0:  GOTO   0BE8 (RETURN)
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder		2/9/05	Added hexatob(), btohexa_high(), and 
....................  *								btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *						'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:			None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
.................... 	// Convert lowercase to uppercase 
.................... 	if(AsciiChars.v[1] > 'F') 
.................... 		AsciiChars.v[1] -= 'a'-'A'; 
.................... 	if(AsciiChars.v[0] > 'F') 
.................... 		AsciiChars.v[0] -= 'a'-'A'; 
....................  
.................... 	// Convert 0-9, A-F to 0x0-0xF 
.................... 	if(AsciiChars.v[1] > '9') 
.................... 		AsciiChars.v[1] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[1] -= '0'; 
....................  
.................... 	if(AsciiChars.v[0] > '9') 
.................... 		AsciiChars.v[0] -= 'A' - 10; 
.................... 	else 
.................... 		AsciiChars.v[0] -= '0'; 
....................  
.................... 	// Concatenate 
.................... 	return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
.................... 	b >>= 4; 
.................... 	return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *					or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *					the input byte. 
....................  *					ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:			None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
.................... 	b &= 0x0F; 
.................... 	return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
00CF0:  MOVFF  288,289
....................     new.v[1]=v.v[0]; 
00CF4:  MOVFF  287,28A
....................  
....................     return(new.Val); 
00CF8:  MOVLB  2
00CFA:  MOVFF  289,01
00CFE:  MOVFF  28A,02
.................... } 
00D02:  MOVLB  0
00D04:  RETLW  00
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
01C28:  MOVFF  273,274
....................     new.v[1]=v.v[2]; 
01C2C:  MOVFF  272,275
....................     new.v[2]=v.v[1]; 
01C30:  MOVFF  271,276
....................     new.v[3]=v.v[0]; 
01C34:  MOVFF  270,277
....................  
....................     return(new.Val); 
01C38:  MOVFF  274,00
01C3C:  MOVFF  275,01
01C40:  MOVFF  276,02
01C44:  MOVFF  277,03
.................... } 
01C48:  RETLW  00
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
.................... 	WORD i; 
.................... 	WORD *val; 
....................  
.................... 	union 
.................... 	{ 
.................... 		DWORD Val; 
.................... 		struct 
.................... 		{ 
.................... 			WORD_VAL LSB; 
.................... 			WORD_VAL MSB; 
.................... 		} words; 
.................... 	} tempSum, sum; 
....................  
.................... 	sum.Val = 0; 
*
019A0:  MOVLB  2
019A2:  CLRF   x79
019A4:  CLRF   x78
019A6:  CLRF   x77
019A8:  CLRF   x76
....................  
.................... 	i = count >> 1; 
019AA:  BCF    FD8.0
019AC:  RRCF   x6D,W
019AE:  MOVWF  x6F
019B0:  RRCF   x6C,W
019B2:  MOVWF  x6E
.................... 	val = (WORD *)buffer; 
019B4:  MOVFF  26B,271
019B8:  MOVFF  26A,270
....................  
.................... 	while( i-- ) 
.................... 		sum.Val += *val++; 
019BC:  MOVFF  26F,03
019C0:  MOVF   x6E,W
019C2:  BTFSC  FD8.2
019C4:  DECF   x6F,F
019C6:  DECF   x6E,F
019C8:  IORWF  03,W
019CA:  BZ    19FA
019CC:  MOVFF  271,03
019D0:  MOVFF  270,00
019D4:  MOVLW  02
019D6:  ADDWF  x70,F
019D8:  BTFSC  FD8.0
019DA:  INCF   x71,F
019DC:  MOVFF  00,FE9
019E0:  MOVFF  03,FEA
019E4:  MOVFF  FEC,03
019E8:  MOVF   FED,F
019EA:  MOVF   FEF,W
019EC:  ADDWF  x76,F
019EE:  MOVF   03,W
019F0:  ADDWFC x77,F
019F2:  MOVLW  00
019F4:  ADDWFC x78,F
019F6:  ADDWFC x79,F
019F8:  BRA    19BC
....................  
.................... 	if ( count & 1 ) 
019FA:  MOVF   x6C,W
019FC:  ANDLW  01
019FE:  MOVWF  00
01A00:  CLRF   03
01A02:  MOVF   00,W
01A04:  IORWF  03,W
01A06:  BZ    1A1C
.................... 		sum.Val += *(BYTE *)val; 
01A08:  MOVFF  270,FE9
01A0C:  MOVFF  271,FEA
01A10:  MOVF   FEF,W
01A12:  ADDWF  x76,F
01A14:  MOVLW  00
01A16:  ADDWFC x77,F
01A18:  ADDWFC x78,F
01A1A:  ADDWFC x79,F
....................  
.................... 	tempSum.Val = sum.Val; 
01A1C:  MOVFF  279,275
01A20:  MOVFF  278,274
01A24:  MOVFF  277,273
01A28:  MOVFF  276,272
....................  
.................... 	while( (i = tempSum.words.MSB.Val) != 0u ) 
.................... 	{ 
01A2C:  MOVFF  275,26F
01A30:  MOVFF  274,26E
01A34:  MOVF   x6E,F
01A36:  BNZ   1A3C
01A38:  MOVF   x6F,F
01A3A:  BZ    1A7A
.................... 		sum.words.MSB.Val = 0; 
01A3C:  CLRF   x79
01A3E:  CLRF   x78
.................... 		sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
01A40:  CLRF   x7D
01A42:  CLRF   x7C
01A44:  MOVFF  277,27B
01A48:  MOVFF  276,27A
01A4C:  CLRF   02
01A4E:  CLRF   03
01A50:  MOVF   x6E,W
01A52:  ADDWF  x76,W
01A54:  MOVWF  x76
01A56:  MOVF   x6F,W
01A58:  ADDWFC x77,W
01A5A:  MOVWF  x77
01A5C:  MOVF   02,W
01A5E:  ADDWFC x7C,W
01A60:  MOVWF  x78
01A62:  MOVF   03,W
01A64:  ADDWFC x7D,W
01A66:  MOVWF  x79
.................... 		tempSum.Val = sum.Val; 
01A68:  MOVFF  279,275
01A6C:  MOVFF  278,274
01A70:  MOVFF  277,273
01A74:  MOVFF  276,272
.................... 	} 
01A78:  BRA    1A2C
....................  
.................... 	return (~sum.words.LSB.Val); 
01A7A:  MOVFF  277,03
01A7E:  COMF   03,F
01A80:  MOVF   x76,W
01A82:  XORLW  FF
01A84:  MOVWF  01
01A86:  MOVFF  03,02
.................... } 
01A8A:  MOVLB  0
01A8C:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
....................  
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
004BC:  MOVLW  83
004BE:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
004C0:  MOVLW  CF
004C2:  MOVWF  FD7
004C4:  MOVLW  2B
004C6:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
004C8:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
004CA:  MOVLW  C0
004CC:  IORWF  FF2,F
.................... } 
004CE:  GOTO   0C26 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
0204E:  BCF    FF2.5
....................     ret=TickCount; 
02050:  MOVFF  51,22F
02054:  MOVFF  50,22E
....................     enable_interrupts(INT_TIMER0); 
02058:  BSF    FF2.5
....................     return ret; 
0205A:  MOVLB  2
0205C:  MOVFF  22E,01
02060:  MOVFF  22F,02
.................... } 
02064:  MOVLB  0
02066:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00232:  INCF   50,F
00234:  BTFSC  FD8.2
00236:  INCF   51,F
....................  
....................         second_counter_intermediate++; 
00238:  INCF   53,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
0023A:  MOVF   53,W
0023C:  SUBLW  09
0023E:  BC    0244
....................             second_counter++; //increment this ever 1s 
00240:  INCF   52,F
....................             second_counter_intermediate=0; 
00242:  CLRF   53
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00244:  MOVLW  CF
00246:  MOVWF  FD7
00248:  MOVLW  2B
0024A:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *					     MAC.h 
....................  *					     string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *					     Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date   		Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		6/28/04	Original 
....................  * Howard Schlunder		10/8/04	Cleanup 
....................  * Howard Schlunder		10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder		11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder		12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder		1/09/06	Added comments and minor mods 
....................  * Howard Schlunder		1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder		2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE		//due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
....................  
.................... #define SPISelectEthernet()		output_low(PIN_ENC_MAC_CS) //changed by ccs 
.................... #define SPIUnselectEthernet()	output_high(PIN_ENC_MAC_CS)   //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS	(TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO	(LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS		(TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO		(LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //		flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //		other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //		done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a) 					(a & 0xFF) 
.................... #define HIGH(a) 				((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE	8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART	(0ul)						// Should be an even memory address 
.................... #define	RXSTOP	((TXSTART-2ul) | 0x0001ul)	// Odd for errata workaround 
.................... #define RXSIZE	(RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define	WCR (0b010<<5)			// Write Control Register command 
.................... #define BFS (0b100<<5)			// Bit Field Set command 
.................... #define	BFC (0b101<<5)			// Bit Field Clear command 
.................... #define	RCR (0b000<<5)			// Read Control Register command 
.................... #define RBM ((0b001<<5) | 0x1A)	// Read Buffer Memory command 
.................... #define	WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define	SR  ((0b111<<5) | 0x1F)	// System Reset command does not use an address. 
.................... 								//   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP	(0x00u) 
.................... #define ETHER_ARP	(0x06u) 
....................  
.................... #define MAXFRAMEC	(1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
0024C:  BCF    FF2.2
0024E:  GOTO   0058
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16			NextPacketPointer; 
....................     RXSTATUS		StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
.................... 	WORD_VAL StartAddress; 
.................... 	WORD_VAL EndAddress; 
.................... 	struct 
.................... 	{ 
.................... 		unsigned char bFree : 1; 
.................... 		unsigned char bTransmitted : 1; 
.................... 	} Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
*
004D2:  MOVLW  03
004D4:  IORWF  F93,F
004D6:  MOVF   F94,W
004D8:  ANDLW  D7
004DA:  IORLW  10
004DC:  MOVWF  F94
004DE:  MOVLW  FC
004E0:  ANDWF  F95,F
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
004E2:  BCF    FC6.5
004E4:  MOVLW  20
004E6:  MOVWF  FC6
004E8:  MOVLW  40
004EA:  MOVWF  FC7
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
....................    output_float(PIN_ENC_MAC_SO); 
....................  #endif 
.................... 	// 
.................... 	// Set up the SPI module on the PIC for communications with the ENC28J60 
.................... 	// 
.................... 	SPIUnselectEthernet(); 
004EC:  BSF    F8C.1
....................  
.................... 	// Deassert the nRESET pin on the ENC28J60.  The internal 
.................... 	// weak pull on the nRESET pin will get the job done anyway, 
.................... 	// so this isn't necessary, but it may provide extra noise immunity, 
.................... 	// should someone put their finger on the pin or otherwise cause a leakage 
.................... 	// path to ground on this pin. 
.................... 	output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
004EE:  BSF    F8C.0
.................... } 
004F0:  GOTO   07C4 (RETURN)
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
004F4:  MOVF   FC9,W
004F6:  MOVFF  292,FC9
004FA:  RRCF   FC7,W
004FC:  BNC   04FA
004FE:  MOVFF  FC9,01
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
....................       output_high(PIN_ENC_MAC_CLK); 
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
....................       output_low(PIN_ENC_MAC_CLK); 
....................    } 
....................    return(in); 
....................  #endif 
.................... } 
00502:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *					registers in the ENC28J60 so that normal operation can 
....................  *					begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
.................... 	BYTE i; 
....................  
....................    ENCSPIInit(); 
*
007C2:  BRA    04D2
....................  
.................... 	// Wait for CLKRDY to become set. 
.................... 	// Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
.................... 	// means the part is in RESET or otherwise our SPI pin is being driven 
.................... 	// incorrectly.  Make sure it is working before proceeding. 
.................... 	do 
.................... 	{ 
.................... 		i = ReadETHReg(ESTAT).Val; 
007C4:  MOVLW  1D
007C6:  MOVLB  2
007C8:  MOVWF  x87
007CA:  MOVLB  0
007CC:  RCALL  0504
007CE:  MOVFF  01,1DC
.................... 	} while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
007D2:  MOVLB  1
007D4:  BTFSS  xDC.3
007D6:  BRA    07DC
007D8:  MOVLB  0
007DA:  BRA    07C4
007DC:  MOVF   xDC,W
007DE:  XORLW  FF
007E0:  ANDLW  01
007E2:  BTFSC  FD8.2
007E4:  BRA    07EA
007E6:  MOVLB  0
007E8:  BRA    07C4
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
.................... 	// Do the memory test and enter a while always trap if a hardware error 
.................... 	// occured.  The LEDA and LEDB pins will be configured to blink 
.................... 	// periodically in an abnormal manner to indicate to the user that the 
.................... 	// error occured. 
.................... 	if( !TestMemory() ) 
.................... 	{ 
.................... 		SetLEDConfig(0x0AA2);		// Set LEDs to blink periodically 
.................... 		while(1); 
.................... 	} 
.................... #endif 
....................  
.................... 	// RESET the entire ENC28J60, clearing all registers 
.................... 	SendSystemReset(); 
007EA:  MOVLB  0
007EC:  BRA    052A
....................     delay_ms(1); 
007EE:  MOVLW  01
007F0:  MOVLB  1
007F2:  MOVWF  xE3
007F4:  MOVLB  0
007F6:  RCALL  02CC
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
007F8:  CLRF   4F
....................  
.................... 	// Start up in Bank 0 and configure the receive buffer boundary pointers 
.................... 	// and the buffer write protect pointer (receive buffer read pointer) 
.................... 	WasDiscarded = TRUE; 
007FA:  BSF    58.0
.................... 	NextPacketLocation.Val = RXSTART; 
007FC:  CLRF   55
007FE:  CLRF   54
.................... 	WriteReg(ERXSTL, LOW(RXSTART)); 
00800:  MOVLW  08
00802:  MOVLB  2
00804:  MOVWF  x8D
00806:  CLRF   x8E
00808:  MOVLB  0
0080A:  RCALL  053C
.................... 	WriteReg(ERXSTH, HIGH(RXSTART)); 
0080C:  MOVLW  09
0080E:  MOVLB  2
00810:  MOVWF  x8D
00812:  CLRF   x8E
00814:  MOVLB  0
00816:  RCALL  053C
.................... 	WriteReg(ERXRDPTL, LOW(RXSTOP));	// Write low byte first 
00818:  MOVLW  0C
0081A:  MOVLB  2
0081C:  MOVWF  x8D
0081E:  MOVLW  F7
00820:  MOVWF  x8E
00822:  MOVLB  0
00824:  RCALL  053C
.................... 	WriteReg(ERXRDPTH, HIGH(RXSTOP));	// Write high byte last 
00826:  MOVLW  0D
00828:  MOVLB  2
0082A:  MOVWF  x8D
0082C:  MOVLW  1B
0082E:  MOVWF  x8E
00830:  MOVLB  0
00832:  RCALL  053C
.................... #if RXSTOP != 0x1FFF	// The RESET default ERXND is 0x1FFF 
.................... 	WriteReg(ERXNDL, LOW(RXSTOP)); 
00834:  MOVLW  0A
00836:  MOVLB  2
00838:  MOVWF  x8D
0083A:  MOVLW  F7
0083C:  MOVWF  x8E
0083E:  MOVLB  0
00840:  RCALL  053C
.................... 	WriteReg(ERXNDH, HIGH(RXSTOP)); 
00842:  MOVLW  0B
00844:  MOVLB  2
00846:  MOVWF  x8D
00848:  MOVLW  1B
0084A:  MOVWF  x8E
0084C:  MOVLB  0
0084E:  RCALL  053C
.................... #endif 
.................... #if TXSTART != 0		// The RESET default ETXST is 0 
.................... 	WriteReg(ETXSTL, LOW(TXSTART)); 
00850:  MOVLW  04
00852:  MOVLB  2
00854:  MOVWF  x8D
00856:  MOVLW  F8
00858:  MOVWF  x8E
0085A:  MOVLB  0
0085C:  RCALL  053C
.................... 	WriteReg(ETXSTH, HIGH(TXSTART)); 
0085E:  MOVLW  05
00860:  MOVLB  2
00862:  MOVWF  x8D
00864:  MOVLW  1B
00866:  MOVWF  x8E
00868:  MOVLB  0
0086A:  RCALL  053C
.................... #endif 
....................  
.................... 	// Enter Bank 1 and configure Receive Filters 
.................... 	// (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
.................... 	// acceptable) 
.................... 	// Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
.................... 	//BankSel(ERXFCON); 
.................... 	//WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
.................... 	// Enter Bank 2 and configure the MAC 
.................... 	BankSel(MACON1); 
0086C:  MOVLW  02
0086E:  MOVLB  2
00870:  MOVWF  x8B
00872:  CLRF   x8A
00874:  MOVLB  0
00876:  RCALL  058A
....................  
.................... 	// Enable the receive portion of the MAC 
.................... 	WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00878:  MOVLB  2
0087A:  CLRF   x8D
0087C:  MOVLW  0D
0087E:  MOVWF  x8E
00880:  MOVLB  0
00882:  RCALL  053C
....................  
.................... 	// Pad packets to 60 bytes, add CRC, and check Type/Length field. 
.................... 	WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00884:  MOVLW  02
00886:  MOVLB  2
00888:  MOVWF  x8D
0088A:  MOVLW  32
0088C:  MOVWF  x8E
0088E:  MOVLB  0
00890:  RCALL  053C
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00892:  MOVLW  03
00894:  MOVLB  2
00896:  MOVWF  x8D
00898:  MOVLW  40
0089A:  MOVWF  x8E
0089C:  MOVLB  0
0089E:  RCALL  053C
....................  
.................... 	// Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
.................... 	// 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
.................... 	// collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
008A0:  MOVLW  09
008A2:  MOVLB  2
008A4:  MOVWF  x8D
008A6:  MOVLW  3F
008A8:  MOVWF  x8E
008AA:  MOVLB  0
008AC:  RCALL  053C
....................  
.................... 	// Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
.................... 	// inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
.................... 	// later. 
.................... 	WriteReg((BYTE)MAIPGL, 0x12); 
008AE:  MOVLW  06
008B0:  MOVLB  2
008B2:  MOVWF  x8D
008B4:  MOVLW  12
008B6:  MOVWF  x8E
008B8:  MOVLB  0
008BA:  RCALL  053C
.................... 	WriteReg((BYTE)MAIPGH, 0x0C); 
008BC:  MOVLW  07
008BE:  MOVLB  2
008C0:  MOVWF  x8D
008C2:  MOVLW  0C
008C4:  MOVWF  x8E
008C6:  MOVLB  0
008C8:  RCALL  053C
....................  
.................... 	// Set the maximum packet size which the controller will accept 
.................... 	WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
008CA:  MOVLW  0A
008CC:  MOVLB  2
008CE:  MOVWF  x8D
008D0:  MOVLW  EE
008D2:  MOVWF  x8E
008D4:  MOVLB  0
008D6:  RCALL  053C
.................... 	WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
008D8:  MOVLW  0B
008DA:  MOVLB  2
008DC:  MOVWF  x8D
008DE:  MOVLW  05
008E0:  MOVWF  x8E
008E2:  MOVLB  0
008E4:  RCALL  053C
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
.................... 	BankSel(MAADR1); 
008E6:  MOVLW  03
008E8:  MOVLB  2
008EA:  MOVWF  x8B
008EC:  MOVLW  04
008EE:  MOVWF  x8A
008F0:  MOVLB  0
008F2:  RCALL  058A
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
008F4:  MOVLW  04
008F6:  MOVLB  2
008F8:  MOVWF  x8D
008FA:  MOVFF  1C,28E
008FE:  MOVLB  0
00900:  RCALL  053C
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00902:  MOVLW  05
00904:  MOVLB  2
00906:  MOVWF  x8D
00908:  MOVFF  1D,28E
0090C:  MOVLB  0
0090E:  RCALL  053C
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00910:  MOVLW  02
00912:  MOVLB  2
00914:  MOVWF  x8D
00916:  MOVFF  1E,28E
0091A:  MOVLB  0
0091C:  RCALL  053C
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
0091E:  MOVLW  03
00920:  MOVLB  2
00922:  MOVWF  x8D
00924:  MOVFF  1F,28E
00928:  MOVLB  0
0092A:  RCALL  053C
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
0092C:  MOVLB  2
0092E:  CLRF   x8D
00930:  MOVFF  20,28E
00934:  MOVLB  0
00936:  RCALL  053C
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00938:  MOVLW  01
0093A:  MOVLB  2
0093C:  MOVWF  x8D
0093E:  MOVFF  21,28E
00942:  MOVLB  0
00944:  RCALL  053C
....................  
.................... 	// Get the Rev ID so that we can implement the correct errata workarounds 
.................... 	ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00946:  MOVLW  12
00948:  MOVLB  2
0094A:  MOVWF  x87
0094C:  MOVLB  0
0094E:  RCALL  0504
00950:  MOVFF  01,59
....................  
.................... 	// Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
.................... 	// side effect. 
.................... 	WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00954:  MOVLW  10
00956:  MOVLB  1
00958:  MOVWF  xE1
0095A:  MOVLW  01
0095C:  MOVWF  xE3
0095E:  CLRF   xE2
00960:  MOVLB  0
00962:  RCALL  05EE
....................  
.................... 	// Configure LEDA to display LINK status, LEDB to display TX/RX activity 
.................... 	SetLEDConfig(0x0472); 
00964:  MOVLW  14
00966:  MOVLB  1
00968:  MOVWF  xE1
0096A:  MOVLW  04
0096C:  MOVWF  xE3
0096E:  MOVLW  72
00970:  MOVWF  xE2
00972:  MOVLB  0
00974:  RCALL  05EE
....................  
.................... 	// Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
.................... 	MACSetDuplex(FULL);		// Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
.................... 	MACSetDuplex(HALF);		// Function exits with Bank 2 selected 
00976:  MOVLB  1
00978:  CLRF   xDD
0097A:  MOVLB  0
0097C:  BRA    0722
.................... #else 
.................... 	// Use the external LEDB polarity to determine weather full or half duplex 
.................... 	// communication mode should be set. 
.................... 	MACSetDuplex(USE_PHY);	// Function exits with Bank 2 selected 
.................... #endif 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
0097E:  MOVLW  1F
00980:  MOVLB  2
00982:  MOVWF  x8F
00984:  MOVLW  04
00986:  MOVWF  x90
00988:  MOVLB  0
0098A:  RCALL  0570
.................... }//end MACInit 
0098C:  GOTO   0C28 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *						  and the link has been up continuously since the last 
....................  *						  call to MACIsLinked() 
....................  *					FALSE: If the PHY reports no link partner, or the link went 
....................  *						   down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
.................... 	// LLSTAT is a latching low link status bit.  Therefore, if the link 
.................... 	// goes down and comes back up before a higher level stack program calls 
.................... 	// MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
.................... 	// call to MACIsLinked() will return TRUE (unless the link goes down 
.................... 	// again). 
.................... 	return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *								  FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *					FALSE: If a previous transmission was started, and it has 
....................  *						   not completed yet.  While FALSE, the data in the 
....................  *						   transmit buffer and the TXST/TXND pointers must not 
....................  *						   be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
0216C:  MOVLW  1F
0216E:  MOVLB  2
02170:  MOVWF  x87
02172:  MOVLB  0
02174:  CALL   0504
02178:  MOVFF  01,269
0217C:  MOVLW  00
0217E:  MOVLB  2
02180:  BTFSC  01.3
02182:  MOVLW  01
02184:  XORLW  00
02186:  BZ    218C
02188:  MOVLW  00
0218A:  BRA    218E
0218C:  MOVLW  01
0218E:  MOVWF  01
02190:  BRA    2192
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  
.................... 	// Check if the current buffer can be modified.  It cannot be modified if 
.................... 	// the TX hardware is currently transmitting it. 
.................... 	if(CurrentTxBuffer == LastTXedBuffer) 
.................... 	{ 
.................... 	    return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
.................... 	} 
....................  
.................... 	// Check if a buffer is available for a new packet 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			return TRUE; 
.................... 		} 
.................... 	} 
....................  
.................... 	return FALSE; 
.................... #endif 
.................... } 
02192:  MOVLB  0
02194:  RETLW  00
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	BUFFER i; 
....................  
.................... 	if(HighPriority) 
.................... #endif 
.................... 	{ 
.................... 		return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
00FFC:  MOVLW  1F
00FFE:  MOVLB  2
01000:  MOVWF  x87
01002:  MOVLB  0
01004:  CALL   0504
01008:  MOVFF  01,269
0100C:  MOVLW  00
0100E:  MOVLB  2
01010:  BTFSC  01.3
01012:  MOVLW  01
01014:  XORLW  00
01016:  BNZ   101C
01018:  MOVLW  00
0101A:  BRA    101E
0101C:  MOVLW  FF
0101E:  MOVWF  01
01020:  BRA    1022
.................... 	} 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Find a free buffer.  Do not use buffer 0, it is reserved for 
.................... 	// high priority messages that don't need to be acknowledged 
.................... 	// before being discarded (TCP control packets, all ICMP 
.................... 	// packets, all UDP packets, etc.) 
.................... 	for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
.................... 	{ 
.................... 		// If this buffer is free, then mark it as used and return with it 
.................... 		if(TxBuffers[i].Flags.bFree) 
.................... 		{ 
.................... 			TxBuffers[i].Flags.bFree = FALSE; 
.................... 			TxBuffers[i].Flags.bTransmitted = FALSE; 
.................... 			return i; 
.................... 		} 
.................... 	} 
....................  
.................... 	return INVALID_BUFFER; 
.................... #endif 
.................... } 
01022:  MOVLB  0
01024:  RETLW  00
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
.................... 	{ 
.................... 	    TxBuffers[buffer].Flags.bFree = TRUE; 
.................... 	    CurrentTxBuffer = buffer; 
.................... 	} 
.................... #endif 
.................... } 
*
00004:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *					MACGetHeader())as being processed and frees the buffer 
....................  *					memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
.................... 	WORD_VAL NewRXRDLocation; 
....................  
.................... 	// Make sure the current packet was not already discarded 
.................... 	if( WasDiscarded ) 
*
00C30:  BTFSS  58.0
00C32:  BRA    0C36
.................... 		return; 
00C34:  BRA    0C92
.................... 	WasDiscarded = TRUE; 
00C36:  BSF    58.0
....................  
.................... 	// Decrement the next packet pointer before writing it into 
.................... 	// the ERXRDPT registers.  This is a silicon errata workaround. 
.................... 	// RX buffer wrapping must be taken into account if the 
.................... 	// NextPacketLocation is precisely RXSTART. 
.................... 	NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
00C38:  MOVLW  01
00C3A:  SUBWF  54,W
00C3C:  MOVLB  2
00C3E:  MOVWF  x2E
00C40:  MOVLW  00
00C42:  SUBWFB 55,W
00C44:  MOVWF  x2F
.................... #if RXSTART == 0 
.................... 	if(NewRXRDLocation.Val > RXSTOP) 
00C46:  MOVF   x2F,W
00C48:  SUBLW  1A
00C4A:  BC    0C5E
00C4C:  XORLW  FF
00C4E:  BNZ   0C56
00C50:  MOVF   x2E,W
00C52:  SUBLW  F7
00C54:  BC    0C5E
.................... #else 
.................... 	if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		NewRXRDLocation.Val = RXSTOP; 
00C56:  MOVLW  1B
00C58:  MOVWF  x2F
00C5A:  MOVLW  F7
00C5C:  MOVWF  x2E
.................... 	} 
....................  
.................... 	// Decrement the RX packet counter register, EPKTCNT 
.................... 	BFSReg(ECON2, ECON2_PKTDEC); 
00C5E:  MOVLW  1E
00C60:  MOVWF  x8F
00C62:  MOVLW  40
00C64:  MOVWF  x90
00C66:  MOVLB  0
00C68:  RCALL  0570
....................  
.................... 	// Move the receive read pointer to unwrite-protect the memory used by the 
.................... 	// last packet.  The writing order is important: set the low byte first, 
.................... 	// high byte last. 
.................... 	BankSel(ERXRDPTL); 
00C6A:  MOVLB  2
00C6C:  CLRF   x8B
00C6E:  MOVLW  0C
00C70:  MOVWF  x8A
00C72:  MOVLB  0
00C74:  RCALL  058A
.................... 	WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
00C76:  MOVLW  0C
00C78:  MOVLB  2
00C7A:  MOVWF  x8D
00C7C:  MOVFF  22E,28E
00C80:  MOVLB  0
00C82:  RCALL  053C
.................... 	WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
00C84:  MOVLW  0D
00C86:  MOVLB  2
00C88:  MOVWF  x8D
00C8A:  MOVFF  22F,28E
00C8E:  MOVLB  0
00C90:  RCALL  053C
.................... } 
00C92:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *					the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
.................... 	WORD_VAL ReadPT, WritePT; 
....................  
.................... 	// Read the Ethernet hardware buffer write pointer.  Because packets can be 
.................... 	// received at any time, it can change between reading the low and high 
.................... 	// bytes.  A loop is necessary to make certain a proper low/high byte pair 
.................... 	// is read. 
.................... 	BankSel(EPKTCNT); 
*
02196:  MOVLW  01
02198:  MOVLB  2
0219A:  MOVWF  x8B
0219C:  MOVLW  19
0219E:  MOVWF  x8A
021A0:  MOVLB  0
021A2:  CALL   058A
.................... 	do { 
.................... 		// Save EPKTCNT in a temporary location 
.................... 		ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
021A6:  MOVLW  19
021A8:  MOVLB  2
021AA:  MOVWF  x87
021AC:  MOVLB  0
021AE:  CALL   0504
021B2:  MOVFF  01,268
....................  
.................... 		BankSel(ERXWRPTL); 
021B6:  MOVLB  2
021B8:  CLRF   x8B
021BA:  MOVLW  0E
021BC:  MOVWF  x8A
021BE:  MOVLB  0
021C0:  CALL   058A
.................... 		WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
021C4:  MOVLW  0E
021C6:  MOVLB  2
021C8:  MOVWF  x87
021CA:  MOVLB  0
021CC:  CALL   0504
021D0:  MOVFF  01,26A
.................... 		WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
021D4:  MOVLW  0F
021D6:  MOVLB  2
021D8:  MOVWF  x87
021DA:  MOVLB  0
021DC:  CALL   0504
021E0:  MOVFF  01,26B
....................  
.................... 		BankSel(EPKTCNT); 
021E4:  MOVLW  01
021E6:  MOVLB  2
021E8:  MOVWF  x8B
021EA:  MOVLW  19
021EC:  MOVWF  x8A
021EE:  MOVLB  0
021F0:  CALL   058A
.................... 	} while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
021F4:  MOVLW  19
021F6:  MOVLB  2
021F8:  MOVWF  x87
021FA:  MOVLB  0
021FC:  CALL   0504
02200:  MOVFF  01,26C
02204:  MOVLB  2
02206:  MOVF   x68,W
02208:  SUBWF  01,W
0220A:  BTFSC  FD8.2
0220C:  BRA    2212
0220E:  MOVLB  0
02210:  BRA    21A6
....................  
.................... 	// Determine where the write protection pointer is 
.................... 	BankSel(ERXRDPTL); 
02212:  CLRF   x8B
02214:  MOVLW  0C
02216:  MOVWF  x8A
02218:  MOVLB  0
0221A:  CALL   058A
.................... 	ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
0221E:  MOVLW  0C
02220:  MOVLB  2
02222:  MOVWF  x87
02224:  MOVLB  0
02226:  CALL   0504
0222A:  MOVFF  01,268
.................... 	ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
0222E:  MOVLW  0D
02230:  MOVLB  2
02232:  MOVWF  x87
02234:  MOVLB  0
02236:  CALL   0504
0223A:  MOVFF  01,269
....................  
.................... 	// Calculate the difference between the pointers, taking care to account 
.................... 	// for buffer wrapping conditions 
.................... 	if ( WritePT.Val > ReadPT.Val ) 
0223E:  MOVLB  2
02240:  MOVF   x69,W
02242:  SUBWF  x6B,W
02244:  BNC   2272
02246:  BNZ   224E
02248:  MOVF   x6A,W
0224A:  SUBWF  x68,W
0224C:  BC    2272
.................... 	{ 
.................... 		return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
0224E:  MOVF   x68,W
02250:  SUBWF  x6A,W
02252:  MOVWF  00
02254:  MOVF   x69,W
02256:  SUBWFB x6B,W
02258:  MOVWF  03
0225A:  MOVF   00,W
0225C:  XORLW  FF
0225E:  ADDLW  F8
02260:  MOVWF  00
02262:  MOVLW  1B
02264:  SUBFWB 03,F
02266:  MOVFF  00,01
0226A:  MOVFF  03,02
0226E:  BRA    22AA
.................... 	} 
.................... 	else if ( WritePT.Val == ReadPT.Val ) 
02270:  BRA    22AA
02272:  MOVF   x68,W
02274:  SUBWF  x6A,W
02276:  BNZ   228A
02278:  MOVF   x69,W
0227A:  SUBWF  x6B,W
0227C:  BNZ   228A
.................... 	{ 
.................... 		return RXSIZE - 1; 
0227E:  MOVLW  F7
02280:  MOVWF  01
02282:  MOVLW  1B
02284:  MOVWF  02
02286:  BRA    22AA
.................... 	} 
.................... 	else 
02288:  BRA    22AA
....................     { 
.................... 		return ReadPT.Val - WritePT.Val - 1; 
0228A:  MOVF   x6A,W
0228C:  SUBWF  x68,W
0228E:  MOVWF  x6C
02290:  MOVF   x6B,W
02292:  SUBWFB x69,W
02294:  MOVWF  x6D
02296:  MOVLW  01
02298:  SUBWF  x6C,W
0229A:  MOVWF  00
0229C:  MOVLW  00
0229E:  SUBWFB x6D,W
022A0:  MOVWF  03
022A2:  MOVFF  00,01
022A6:  MOVWF  02
022A8:  BRA    22AA
.................... 	} 
.................... } 
022AA:  MOVLB  0
022AC:  GOTO   2534 (RETURN)
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *							 received frame. 
....................  *					*type: Location of a BYTE to store the constant 
....................  *						   MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *						   the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *						  remote, and type values are updated. 
....................  *					FALSE: If a packet was not pending.  remote and type are 
....................  *						   not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *					been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
.................... 	ENC_PREAMBLE header; 
....................  
.................... 	// Test if at least one packet has been received and is waiting 
.................... 	BankSel(EPKTCNT); 
*
00D06:  MOVLW  01
00D08:  MOVLB  2
00D0A:  MOVWF  x8B
00D0C:  MOVLW  19
00D0E:  MOVWF  x8A
00D10:  MOVLB  0
00D12:  RCALL  058A
.................... 	if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
00D14:  MOVLW  19
00D16:  MOVLB  2
00D18:  MOVWF  x87
00D1A:  MOVLB  0
00D1C:  CALL   0504
00D20:  MOVFF  01,1FA
00D24:  MOVLB  1
00D26:  MOVF   xFA,F
00D28:  BNZ   0D30
.................... 		return FALSE; 
00D2A:  MOVLW  00
00D2C:  MOVWF  01
00D2E:  BRA    0E38
....................  
.................... 	// Make absolutely certain that any previous packet was discarded 
.................... 	if(WasDiscarded == FALSE) 
00D30:  BTFSC  58.0
00D32:  BRA    0D40
.................... 	{ 
.................... 		MACDiscardRx(); 
00D34:  MOVLB  0
00D36:  RCALL  0C30
.................... 		return FALSE; 
00D38:  MOVLW  00
00D3A:  MOVWF  01
00D3C:  MOVLB  1
00D3E:  BRA    0E38
.................... 	} 
....................  
.................... 	// Save the location of this packet 
.................... 	CurrentPacketLocation.Val = NextPacketLocation.Val; 
00D40:  MOVFF  55,57
00D44:  MOVFF  54,56
....................  
.................... 	// Set the SPI read pointer to the beginning of the next unprocessed packet 
.................... 	BankSel(ERDPTL); 
00D48:  MOVLB  2
00D4A:  CLRF   x8B
00D4C:  CLRF   x8A
00D4E:  MOVLB  0
00D50:  RCALL  058A
.................... 	WriteReg(ERDPTL, NextPacketLocation.v[0]); 
00D52:  MOVLB  2
00D54:  CLRF   x8D
00D56:  MOVFF  54,28E
00D5A:  MOVLB  0
00D5C:  CALL   053C
.................... 	WriteReg(ERDPTH, NextPacketLocation.v[1]); 
00D60:  MOVLW  01
00D62:  MOVLB  2
00D64:  MOVWF  x8D
00D66:  MOVFF  55,28E
00D6A:  MOVLB  0
00D6C:  CALL   053C
....................  
.................... 	// Obtain the MAC header from the Ethernet buffer 
.................... 	MACGetArray((BYTE*)&header, sizeof(header)); 
00D70:  MOVLW  01
00D72:  MOVLB  1
00D74:  MOVWF  xFB
00D76:  MOVLW  E6
00D78:  MOVFF  1FB,277
00D7C:  MOVFF  FE8,276
00D80:  MOVLB  2
00D82:  CLRF   x79
00D84:  MOVLW  14
00D86:  MOVWF  x78
00D88:  MOVLB  0
00D8A:  RCALL  0C94
....................  
.................... 	// The EtherType field, like most items transmitted on the Ethernet medium 
.................... 	// are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
00D8C:  MOVFF  1F9,288
00D90:  MOVFF  1F8,287
00D94:  RCALL  0CF0
00D96:  MOVFF  02,1F9
00D9A:  MOVFF  01,1F8
....................  
.................... 	// Validate the data returned from the ENC28J60.  Random data corruption, 
.................... 	// such as if a single SPI bit error occurs while communicating or a 
.................... 	// momentary power glitch could cause this to occur in rare circumstances. 
.................... 	if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
.................... 	   header.StatusVector.bits.Zero || 
.................... 	   header.StatusVector.bits.CRCError || 
.................... 	   header.StatusVector.bits.ByteCount > 1518 || 
.................... 	   !header.StatusVector.bits.ReceiveOk) 
00D9E:  MOVLB  1
00DA0:  MOVF   xE7,W
00DA2:  SUBLW  1A
00DA4:  BC    0DB0
00DA6:  XORLW  FF
00DA8:  BNZ   0DDC
00DAA:  MOVF   xE6,W
00DAC:  SUBLW  F7
00DAE:  BNC   0DDC
00DB0:  MOVLW  01
00DB2:  MOVWF  xFB
00DB4:  MOVLW  E6
00DB6:  MOVWF  FE9
00DB8:  MOVFF  1FB,FEA
00DBC:  BTFSC  FEF.0
00DBE:  BRA    0DDC
00DC0:  BTFSC  xEB.7
00DC2:  BRA    0DDC
00DC4:  BTFSC  xEA.4
00DC6:  BRA    0DDC
00DC8:  MOVF   xE9,W
00DCA:  SUBLW  04
00DCC:  BC    0DD8
00DCE:  XORLW  FF
00DD0:  BNZ   0DDC
00DD2:  MOVF   xE8,W
00DD4:  SUBLW  EE
00DD6:  BNC   0DDC
00DD8:  BTFSC  xEA.7
00DDA:  BRA    0DDE
.................... 	{ 
.................... 		//Reset(); 
....................       reset_cpu(); 
00DDC:  RESET
.................... 	} 
....................  
.................... 	// Save the location where the hardware will write the next packet to 
.................... 	NextPacketLocation.Val = header.NextPacketPointer; 
00DDE:  MOVFF  1E7,55
00DE2:  MOVFF  1E6,54
....................  
.................... 	// Return the Ethernet frame's Source MAC address field to the caller 
.................... 	// This parameter is useful for replying to requests without requiring an 
.................... 	// ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
00DE6:  MOVFF  1E2,1FA
00DEA:  MOVFF  1E3,1FB
00DEE:  MOVFF  1E3,FEA
00DF2:  MOVFF  1E2,FE9
00DF6:  MOVLW  01
00DF8:  MOVWF  FE2
00DFA:  MOVLW  F2
00DFC:  MOVWF  FE1
00DFE:  MOVLW  06
00E00:  MOVWF  01
00E02:  MOVFF  FE6,FEE
00E06:  DECFSZ 01,F
00E08:  BRA    0E02
....................  
.................... 	// Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
00E0A:  MOVFF  1E4,FE9
00E0E:  MOVFF  1E5,FEA
00E12:  MOVLW  FF
00E14:  MOVWF  FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................     	((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
00E16:  MOVF   xF9,W
00E18:  SUBLW  08
00E1A:  BNZ   0E32
00E1C:  MOVF   xF8,F
00E1E:  BZ    0E26
00E20:  MOVF   xF8,W
00E22:  SUBLW  06
00E24:  BNZ   0E32
....................     { 
....................     	*type = header.Type.v[0]; 
00E26:  MOVFF  1E4,FE9
00E2A:  MOVFF  1E5,FEA
00E2E:  MOVFF  1F8,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
00E32:  BCF    58.0
.................... 	return TRUE; 
00E34:  MOVLW  01
00E36:  MOVWF  01
.................... } 
00E38:  MOVLB  0
00E3A:  GOTO   3B8A (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *					                     BYTE type, 
....................  *                   					 WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  * 							 MAC address (6 bytes) 
....................  *					type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *						  value to write into the Ethernet header's type field. 
....................  *					dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *					advantagous to call this function immediately before 
....................  *					transmitting a packet rather than initially when the 
....................  *					packet is first created.  The order in which the packet 
....................  *					is constructed (header first or data first) is not 
....................  *					important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
.................... 	BankSel(EWRPTL); 
*
01134:  MOVLB  2
01136:  CLRF   x8B
01138:  MOVLW  02
0113A:  MOVWF  x8A
0113C:  MOVLB  0
0113E:  CALL   058A
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
.................... 	TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
.................... 	// Set the SPI write pointer to the beginning of the transmit buffer 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
01142:  MOVLW  02
01144:  MOVLB  2
01146:  MOVWF  x8D
01148:  MOVLW  F8
0114A:  MOVWF  x8E
0114C:  MOVLB  0
0114E:  CALL   053C
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
01152:  MOVLW  03
01154:  MOVLB  2
01156:  MOVWF  x8D
01158:  MOVLW  1B
0115A:  MOVWF  x8E
0115C:  MOVLB  0
0115E:  CALL   053C
....................  
.................... 	// Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01162:  MOVLW  06
01164:  MOVLB  2
01166:  ADDWF  x88,F
01168:  MOVLW  1C
0116A:  ADDWFC x89,F
....................  
.................... 	// Write the TXND pointer into the registers, given the dataLen given 
.................... 	WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
0116C:  MOVLW  02
0116E:  MOVWF  x8B
01170:  MOVLW  88
01172:  MOVWF  FE9
01174:  MOVFF  28B,FEA
01178:  MOVFF  FEF,28C
0117C:  MOVLW  06
0117E:  MOVWF  x8D
01180:  MOVFF  28C,28E
01184:  MOVLB  0
01186:  CALL   053C
.................... 	WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
0118A:  MOVLW  02
0118C:  MOVLB  2
0118E:  MOVWF  x8B
01190:  MOVLW  88
01192:  MOVWF  x8A
01194:  MOVLW  01
01196:  ADDWF  x8A,W
01198:  MOVWF  FE9
0119A:  MOVLW  00
0119C:  ADDWFC x8B,W
0119E:  MOVWF  FEA
011A0:  MOVFF  FEF,28C
011A4:  MOVLW  07
011A6:  MOVWF  x8D
011A8:  MOVFF  28C,28E
011AC:  MOVLB  0
011AE:  CALL   053C
.................... #endif 
....................  
....................  
.................... 	// Set the per-packet control byte and write the Ethernet destination 
.................... 	// address 
.................... 	MACPut(0x00);	// Use default control configuration 
011B2:  MOVLB  2
011B4:  CLRF   x8B
011B6:  MOVLB  0
011B8:  RCALL  10D0
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
011BA:  MOVFF  286,28D
011BE:  MOVFF  285,28C
011C2:  MOVLB  2
011C4:  CLRF   x8F
011C6:  MOVLW  06
011C8:  MOVWF  x8E
011CA:  MOVLB  0
011CC:  RCALL  10EA
....................  
.................... 	// Write our MAC address in the Ethernet source field 
.................... 	MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
011CE:  MOVLB  2
011D0:  CLRF   x8B
011D2:  MOVLW  1C
011D4:  MOVFF  28B,28D
011D8:  MOVWF  x8C
011DA:  CLRF   x8F
011DC:  MOVLW  06
011DE:  MOVWF  x8E
011E0:  MOVLB  0
011E2:  RCALL  10EA
....................  
.................... 	// Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
011E4:  MOVLW  08
011E6:  MOVLB  2
011E8:  MOVWF  x8B
011EA:  MOVLB  0
011EC:  RCALL  10D0
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
011EE:  MOVLB  2
011F0:  MOVF   x87,F
011F2:  BNZ   11F8
011F4:  MOVLW  00
011F6:  BRA    11FA
011F8:  MOVLW  06
011FA:  MOVWF  x8B
011FC:  MOVLB  0
011FE:  RCALL  10D0
.................... } 
01200:  RETLW  00
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *					MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *					the Ethernet medium.  The hardware MAC will take control 
....................  *					and handle CRC generation, collision retransmission and 
....................  *					other details. 
....................  * 
....................  * Note:			After transmission completes (MACIsTxReady() returns TRUE), 
....................  *					the packet can be modified and transmitted again by calling 
....................  *					MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *					called (in the TX data area), the data in the TX buffer 
....................  *					will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	// Set the packet start and end address pointers 
.................... 	BankSel(ETXSTL); 
.................... 	WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
.................... 	WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
.................... 	WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
.................... 	WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
.................... 	LastTXedBuffer = CurrentTxBuffer; 
.................... 	TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
.................... 	// Reset transmit logic if a TX Error has previously occured 
.................... 	// This is a silicon errata workaround 
.................... 	if(ReadETHReg(EIR).EIRbits.TXERIF) 
01202:  MOVLW  1C
01204:  MOVLB  2
01206:  MOVWF  x87
01208:  MOVLB  0
0120A:  CALL   0504
0120E:  MOVFF  01,274
01212:  MOVLW  00
01214:  MOVLB  2
01216:  BTFSC  01.1
01218:  MOVLW  01
0121A:  XORLW  00
0121C:  BZ    123E
.................... 	{ 
.................... 		BFSReg(ECON1, ECON1_TXRST); 
0121E:  MOVLW  1F
01220:  MOVWF  x8F
01222:  MOVLW  80
01224:  MOVWF  x90
01226:  MOVLB  0
01228:  CALL   0570
.................... 		BFCReg(ECON1, ECON1_TXRST); 
0122C:  MOVLW  1F
0122E:  MOVLB  2
01230:  MOVWF  x8C
01232:  MOVLW  80
01234:  MOVWF  x8D
01236:  MOVLB  0
01238:  CALL   0556
0123C:  MOVLB  2
.................... 	} 
.................... 	BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
0123E:  MOVLW  1C
01240:  MOVWF  x8C
01242:  MOVLW  0A
01244:  MOVWF  x8D
01246:  MOVLB  0
01248:  CALL   0556
....................  
.................... 	// Start the transmission 
.................... 	// After transmission completes (MACIsTxReady() returns TRUE), the packet 
.................... 	// can be modified and transmitted again by calling MACFlush() again. 
.................... 	// Until MACPutHeader() is called, the data in the TX buffer will not be 
.................... 	// corrupted. 
.................... 	BFSReg(ECON1, ECON1_TXRTS); 
0124C:  MOVLW  1F
0124E:  MOVLB  2
01250:  MOVWF  x8F
01252:  MOVLW  08
01254:  MOVWF  x90
01256:  MOVLB  0
01258:  CALL   0570
....................  
.................... 	// Revision B5 silicon errata workaround 
.................... 	if(ENCRevID == 0x05) 
0125C:  MOVF   59,W
0125E:  SUBLW  05
01260:  BTFSS  FD8.2
01262:  BRA    1424
.................... 	{ 
.................... 		while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01264:  MOVLW  1C
01266:  MOVLB  2
01268:  MOVWF  x87
0126A:  MOVLB  0
0126C:  CALL   0504
01270:  MOVFF  01,274
01274:  MOVLB  2
01276:  MOVF   01,W
01278:  ANDLW  0A
0127A:  BTFSS  FD8.2
0127C:  BRA    1282
0127E:  MOVLB  0
01280:  BRA    1264
.................... 		if(ReadETHReg(EIR).EIRbits.TXERIF) 
01282:  MOVLW  1C
01284:  MOVWF  x87
01286:  MOVLB  0
01288:  CALL   0504
0128C:  MOVFF  01,274
01290:  MOVLW  00
01292:  MOVLB  2
01294:  BTFSC  01.1
01296:  MOVLW  01
01298:  XORLW  00
0129A:  BTFSC  FD8.2
0129C:  BRA    1426
.................... 		{ 
.................... 			WORD_VAL ReadPtrSave; 
.................... 			WORD_VAL TXEnd; 
.................... 			TXSTATUS TXStatus; 
.................... 			BYTE i; 
....................  
.................... 			// Cancel the previous transmission if it has become stuck set 
.................... 			BFCReg(ECON1, ECON1_TXRTS); 
0129E:  MOVLW  1F
012A0:  MOVWF  x8C
012A2:  MOVLW  08
012A4:  MOVWF  x8D
012A6:  MOVLB  0
012A8:  CALL   0556
....................  
.................... 			// Save the current read pointer (controlled by application) 
.................... 			BankSel(ERDPTL); 
012AC:  MOVLB  2
012AE:  CLRF   x8B
012B0:  CLRF   x8A
012B2:  MOVLB  0
012B4:  CALL   058A
.................... 			ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
012B8:  MOVLB  2
012BA:  CLRF   x87
012BC:  MOVLB  0
012BE:  CALL   0504
012C2:  MOVFF  01,268
.................... 			ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
012C6:  MOVLW  01
012C8:  MOVLB  2
012CA:  MOVWF  x87
012CC:  MOVLB  0
012CE:  CALL   0504
012D2:  MOVFF  01,269
....................  
.................... 			// Get the location of the transmit status vector 
.................... 			TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
012D6:  MOVLW  06
012D8:  MOVLB  2
012DA:  MOVWF  x87
012DC:  MOVLB  0
012DE:  CALL   0504
012E2:  MOVFF  01,26A
.................... 			TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
012E6:  MOVLW  07
012E8:  MOVLB  2
012EA:  MOVWF  x87
012EC:  MOVLB  0
012EE:  CALL   0504
012F2:  MOVFF  01,26B
.................... 			TXEnd.Val++; 
012F6:  MOVLB  2
012F8:  INCF   x6A,F
012FA:  BTFSC  FD8.2
012FC:  INCF   x6B,F
....................  
.................... 			// Read the transmit status vector 
.................... 			WriteReg(ERDPTL, TXEnd.v[0]); 
012FE:  CLRF   x8D
01300:  MOVFF  26A,28E
01304:  MOVLB  0
01306:  CALL   053C
.................... 			WriteReg(ERDPTH, TXEnd.v[1]); 
0130A:  MOVLW  01
0130C:  MOVLB  2
0130E:  MOVWF  x8D
01310:  MOVFF  26B,28E
01314:  MOVLB  0
01316:  CALL   053C
.................... 			MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
0131A:  MOVLW  02
0131C:  MOVLB  2
0131E:  MOVWF  x75
01320:  MOVLW  6C
01322:  MOVFF  275,277
01326:  MOVWF  x76
01328:  CLRF   x79
0132A:  MOVLW  07
0132C:  MOVWF  x78
0132E:  MOVLB  0
01330:  RCALL  0C94
....................  
.................... 			// Implement retransmission if a late collision occured (this can 
.................... 			// happen on B5 when certain link pulses arrive at the same time 
.................... 			// as the transmission) 
.................... 			for(i = 0; i < 16; i++) 
01332:  MOVLB  2
01334:  CLRF   x73
01336:  MOVF   x73,W
01338:  SUBLW  0F
0133A:  BNC   1408
.................... 			{ 
.................... 				if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
0133C:  MOVLW  1C
0133E:  MOVWF  x87
01340:  MOVLB  0
01342:  CALL   0504
01346:  MOVFF  01,274
0134A:  MOVLW  00
0134C:  MOVLB  2
0134E:  BTFSC  01.1
01350:  MOVLW  01
01352:  XORLW  00
01354:  BZ    13FE
01356:  BTFSS  x6F.5
01358:  BRA    13FE
.................... 				{ 
.................... 					// Reset the TX logic 
.................... 					BFSReg(ECON1, ECON1_TXRST); 
0135A:  MOVLW  1F
0135C:  MOVWF  x8F
0135E:  MOVLW  80
01360:  MOVWF  x90
01362:  MOVLB  0
01364:  CALL   0570
.................... 					BFCReg(ECON1, ECON1_TXRST); 
01368:  MOVLW  1F
0136A:  MOVLB  2
0136C:  MOVWF  x8C
0136E:  MOVLW  80
01370:  MOVWF  x8D
01372:  MOVLB  0
01374:  CALL   0556
.................... 					BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01378:  MOVLW  1C
0137A:  MOVLB  2
0137C:  MOVWF  x8C
0137E:  MOVLW  0A
01380:  MOVWF  x8D
01382:  MOVLB  0
01384:  CALL   0556
....................  
.................... 					// Transmit the packet again 
.................... 					BFSReg(ECON1, ECON1_TXRTS); 
01388:  MOVLW  1F
0138A:  MOVLB  2
0138C:  MOVWF  x8F
0138E:  MOVLW  08
01390:  MOVWF  x90
01392:  MOVLB  0
01394:  CALL   0570
.................... 					while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01398:  MOVLW  1C
0139A:  MOVLB  2
0139C:  MOVWF  x87
0139E:  MOVLB  0
013A0:  CALL   0504
013A4:  MOVFF  01,274
013A8:  MOVLB  2
013AA:  MOVF   01,W
013AC:  ANDLW  0A
013AE:  BTFSS  FD8.2
013B0:  BRA    13B6
013B2:  MOVLB  0
013B4:  BRA    1398
....................  
.................... 					// Cancel the previous transmission if it has become stuck set 
.................... 					BFCReg(ECON1, ECON1_TXRTS); 
013B6:  MOVLW  1F
013B8:  MOVWF  x8C
013BA:  MOVLW  08
013BC:  MOVWF  x8D
013BE:  MOVLB  0
013C0:  CALL   0556
....................  
.................... 					// Read transmit status vector 
.................... 					WriteReg(ERDPTL, TXEnd.v[0]); 
013C4:  MOVLB  2
013C6:  CLRF   x8D
013C8:  MOVFF  26A,28E
013CC:  MOVLB  0
013CE:  CALL   053C
.................... 					WriteReg(ERDPTH, TXEnd.v[1]); 
013D2:  MOVLW  01
013D4:  MOVLB  2
013D6:  MOVWF  x8D
013D8:  MOVFF  26B,28E
013DC:  MOVLB  0
013DE:  CALL   053C
.................... 					MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
013E2:  MOVLW  02
013E4:  MOVLB  2
013E6:  MOVWF  x75
013E8:  MOVLW  6C
013EA:  MOVFF  275,277
013EE:  MOVWF  x76
013F0:  CLRF   x79
013F2:  MOVLW  07
013F4:  MOVWF  x78
013F6:  MOVLB  0
013F8:  RCALL  0C94
.................... 				} 
.................... 				else 
013FA:  BRA    1402
013FC:  MOVLB  2
.................... 				{ 
.................... 					break; 
013FE:  BRA    1408
01400:  MOVLB  0
.................... 				} 
.................... 			} 
01402:  MOVLB  2
01404:  INCF   x73,F
01406:  BRA    1336
....................  
.................... 			// Restore the current read pointer 
.................... 			WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01408:  CLRF   x8D
0140A:  MOVFF  268,28E
0140E:  MOVLB  0
01410:  CALL   053C
.................... 			WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01414:  MOVLW  01
01416:  MOVLB  2
01418:  MOVWF  x8D
0141A:  MOVFF  269,28E
0141E:  MOVLB  0
01420:  CALL   053C
01424:  MOVLB  2
.................... 		} 
.................... 	} 
.................... } 
01426:  MOVLB  0
01428:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *					getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			RXSTOP must be statically defined as being > RXSTART for 
....................  *					this function to work correctly.  In other words, do not 
....................  *					define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *					boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
.................... 	WORD_VAL ReadPT; 
....................  
.................... 	// Determine the address of the beginning of the entire packet 
.................... 	// and adjust the address to the desired location 
.................... 	ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
01760:  MOVLW  14
01762:  ADDWF  56,W
01764:  MOVLB  2
01766:  MOVWF  x18
01768:  MOVLW  00
0176A:  ADDWFC 57,W
0176C:  MOVWF  x19
0176E:  MOVF   x14,W
01770:  ADDWF  x18,W
01772:  MOVWF  x16
01774:  MOVF   x15,W
01776:  ADDWFC x19,W
01778:  MOVWF  x17
....................  
.................... 	// Since the receive buffer is circular, adjust if a wraparound is needed 
.................... 	if ( ReadPT.Val > RXSTOP ) 
0177A:  MOVF   x17,W
0177C:  SUBLW  1A
0177E:  BC    1792
01780:  XORLW  FF
01782:  BNZ   178A
01784:  MOVF   x16,W
01786:  SUBLW  F7
01788:  BC    1792
.................... 		ReadPT.Val -= RXSIZE; 
0178A:  MOVLW  F8
0178C:  SUBWF  x16,F
0178E:  MOVLW  1B
01790:  SUBWFB x17,F
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(ERDPTL); 
01792:  CLRF   x8B
01794:  CLRF   x8A
01796:  MOVLB  0
01798:  CALL   058A
.................... 	WriteReg(ERDPTL, ReadPT.v[0]); 
0179C:  MOVLB  2
0179E:  CLRF   x8D
017A0:  MOVFF  216,28E
017A4:  MOVLB  0
017A6:  CALL   053C
.................... 	WriteReg(ERDPTH, ReadPT.v[1]); 
017AA:  MOVLW  01
017AC:  MOVLB  2
017AE:  MOVWF  x8D
017B0:  MOVFF  217,28E
017B4:  MOVLB  0
017B6:  CALL   053C
.................... 	WriteReg(EWRPTL, ReadPT.v[0]); 
017BA:  MOVLW  02
017BC:  MOVLB  2
017BE:  MOVWF  x8D
017C0:  MOVFF  216,28E
017C4:  MOVLB  0
017C6:  CALL   053C
.................... 	WriteReg(EWRPTH, ReadPT.v[1]); 
017CA:  MOVLW  03
017CC:  MOVLB  2
017CE:  MOVWF  x8D
017D0:  MOVFF  217,28E
017D4:  MOVLB  0
017D6:  CALL   053C
.................... } 
017DA:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *							within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *							parameter is not used. 
....................  *					offset: WORD specifying how many bytes beyond the Ethernet 
....................  *							header's type field to relocate the SPI read and 
....................  *							write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *					MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *					and various other functions will use these new values. 
....................  * 
....................  * Note:			None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01026:  MOVFF  281,4F
....................  
.................... 	// Calculate the proper address.  Since the TX memory area is not circular, 
.................... 	// no wrapparound checks are necessary. +1 adjustment is needed because of 
.................... 	// the per packet control byte which preceeds the packet in the TX memory 
.................... 	// area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
.................... 	offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
0102A:  MOVLW  07
0102C:  MOVLB  2
0102E:  ADDWF  x82,F
01030:  MOVLW  1C
01032:  ADDWFC x83,F
.................... #endif 
....................  
.................... 	// Set the SPI read and write pointers to the new calculated value 
.................... 	BankSel(EWRPTL); 
01034:  CLRF   x8B
01036:  MOVLW  02
01038:  MOVWF  x8A
0103A:  MOVLB  0
0103C:  CALL   058A
.................... 	WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01040:  MOVLW  02
01042:  MOVLB  2
01044:  MOVWF  x85
01046:  MOVLW  82
01048:  MOVWF  FE9
0104A:  MOVFF  285,FEA
0104E:  MOVFF  FEF,286
01052:  CLRF   x8D
01054:  MOVFF  286,28E
01058:  MOVLB  0
0105A:  CALL   053C
.................... 	WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
0105E:  MOVLW  02
01060:  MOVLB  2
01062:  MOVWF  x85
01064:  MOVLW  82
01066:  MOVWF  x84
01068:  MOVLW  01
0106A:  ADDWF  x84,W
0106C:  MOVWF  FE9
0106E:  MOVLW  00
01070:  ADDWFC x85,W
01072:  MOVWF  FEA
01074:  MOVFF  FEF,286
01078:  MOVLW  01
0107A:  MOVWF  x8D
0107C:  MOVFF  286,28E
01080:  MOVLB  0
01082:  CALL   053C
.................... 	WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01086:  MOVLW  02
01088:  MOVLB  2
0108A:  MOVWF  x85
0108C:  MOVLW  82
0108E:  MOVWF  FE9
01090:  MOVFF  285,FEA
01094:  MOVFF  FEF,286
01098:  MOVLW  02
0109A:  MOVWF  x8D
0109C:  MOVFF  286,28E
010A0:  MOVLB  0
010A2:  CALL   053C
.................... 	WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
010A6:  MOVLW  02
010A8:  MOVLB  2
010AA:  MOVWF  x85
010AC:  MOVLW  82
010AE:  MOVWF  x84
010B0:  MOVLW  01
010B2:  ADDWF  x84,W
010B4:  MOVWF  FE9
010B6:  MOVLW  00
010B8:  ADDWFC x85,W
010BA:  MOVWF  FEA
010BC:  MOVFF  FEF,286
010C0:  MOVLW  03
010C2:  MOVWF  x8D
010C4:  MOVFF  286,28E
010C8:  MOVLB  0
010CA:  CALL   053C
.................... } 
010CE:  RETLW  00
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Add the offset requested by firmware plus the Ethernet header 
.................... 	temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
01658:  MOVLW  14
0165A:  ADDWF  56,W
0165C:  MOVLB  2
0165E:  MOVWF  x41
01660:  MOVLW  00
01662:  ADDWFC 57,W
01664:  MOVWF  x42
01666:  MOVF   x3B,W
01668:  ADDWF  x41,W
0166A:  MOVWF  x3F
0166C:  MOVF   x3C,W
0166E:  ADDWFC x42,W
01670:  MOVWF  x40
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
01672:  MOVF   x40,W
01674:  SUBLW  1A
01676:  BC    168A
01678:  XORLW  FF
0167A:  BNZ   1682
0167C:  MOVF   x3F,W
0167E:  SUBLW  F7
01680:  BC    168A
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
01682:  MOVLW  F8
01684:  SUBWF  x3F,F
01686:  MOVLW  1B
01688:  SUBWFB x40,F
.................... 	} 
....................  
.................... 	// Program the start address of the DMA 
.................... 	BankSel(EDMASTL); 
0168A:  CLRF   x8B
0168C:  MOVLW  10
0168E:  MOVWF  x8A
01690:  MOVLB  0
01692:  CALL   058A
.................... 	WriteReg(EDMASTL, temp.v[0]); 
01696:  MOVLW  10
01698:  MOVLB  2
0169A:  MOVWF  x8D
0169C:  MOVFF  23F,28E
016A0:  MOVLB  0
016A2:  CALL   053C
.................... 	WriteReg(EDMASTH, temp.v[1]); 
016A6:  MOVLW  11
016A8:  MOVLB  2
016AA:  MOVWF  x8D
016AC:  MOVFF  240,28E
016B0:  MOVLB  0
016B2:  CALL   053C
....................  
.................... 	// Calculate the end address, given the start address and len 
.................... 	temp.Val += len-1; 
016B6:  MOVLW  01
016B8:  MOVLB  2
016BA:  SUBWF  x3D,W
016BC:  MOVWF  00
016BE:  MOVLW  00
016C0:  SUBWFB x3E,W
016C2:  MOVWF  03
016C4:  MOVF   00,W
016C6:  ADDWF  x3F,F
016C8:  MOVF   03,W
016CA:  ADDWFC x40,F
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
016CC:  MOVF   x40,W
016CE:  SUBLW  1A
016D0:  BC    16E4
016D2:  XORLW  FF
016D4:  BNZ   16DC
016D6:  MOVF   x3F,W
016D8:  SUBLW  F7
016DA:  BC    16E4
.................... 	{ 
.................... 		temp.Val -= RXSIZE; 
016DC:  MOVLW  F8
016DE:  SUBWF  x3F,F
016E0:  MOVLW  1B
016E2:  SUBWFB x40,F
.................... 	} 
....................  
.................... 	// Program the end address of the DMA 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
016E4:  MOVLW  12
016E6:  MOVWF  x8D
016E8:  MOVFF  23F,28E
016EC:  MOVLB  0
016EE:  CALL   053C
.................... 	WriteReg(EDMANDH, temp.v[1]); 
016F2:  MOVLW  13
016F4:  MOVLB  2
016F6:  MOVWF  x8D
016F8:  MOVFF  240,28E
016FC:  MOVLB  0
016FE:  CALL   053C
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
01702:  MOVLW  1F
01704:  MOVLB  2
01706:  MOVWF  x8F
01708:  MOVLW  30
0170A:  MOVWF  x90
0170C:  MOVLB  0
0170E:  CALL   0570
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
01712:  MOVLW  1F
01714:  MOVLB  2
01716:  MOVWF  x87
01718:  MOVLB  0
0171A:  CALL   0504
0171E:  MOVFF  01,241
01722:  MOVLW  00
01724:  MOVLB  2
01726:  BTFSC  01.5
01728:  MOVLW  01
0172A:  XORLW  00
0172C:  BTFSC  FD8.2
0172E:  BRA    1734
01730:  MOVLB  0
01732:  BRA    1712
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
01734:  MOVLW  16
01736:  MOVWF  x87
01738:  MOVLB  0
0173A:  CALL   0504
0173E:  MOVFF  01,240
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
01742:  MOVLW  17
01744:  MOVLB  2
01746:  MOVWF  x87
01748:  MOVLB  0
0174A:  CALL   0504
0174E:  MOVFF  01,23F
.................... 	return temp.Val; 
01752:  MOVLB  2
01754:  MOVFF  23F,01
01758:  MOVFF  240,02
.................... } 
0175C:  MOVLB  0
0175E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset	- Number of bytes beyond the beginning of the 
....................  *							Ethernet data (first byte after the type field) 
....................  *							where the checksum should begin 
....................  *					len		- Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Program the start address of the DMA, after adjusting for the Ethernet 
.................... 	// header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... 	temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
.................... #else 
.................... 	temp.Val = TXSTART + sizeof(ETHER_HEADER) 
.................... 				+ offset + 1;	// +1 needed to account for per packet control byte 
*
022B0:  MOVLW  06
022B2:  MOVLB  2
022B4:  ADDWF  x81,W
022B6:  MOVWF  x87
022B8:  MOVLW  1C
022BA:  ADDWFC x82,W
022BC:  MOVWF  x88
022BE:  MOVLW  01
022C0:  ADDWF  x87,W
022C2:  MOVWF  x85
022C4:  MOVLW  00
022C6:  ADDWFC x88,W
022C8:  MOVWF  x86
.................... #endif 
.................... 	BankSel(EDMASTL); 
022CA:  CLRF   x8B
022CC:  MOVLW  10
022CE:  MOVWF  x8A
022D0:  MOVLB  0
022D2:  CALL   058A
.................... 	WriteReg(EDMASTL, temp.v[0]); 
022D6:  MOVLW  10
022D8:  MOVLB  2
022DA:  MOVWF  x8D
022DC:  MOVFF  285,28E
022E0:  MOVLB  0
022E2:  CALL   053C
.................... 	WriteReg(EDMASTH, temp.v[1]); 
022E6:  MOVLW  11
022E8:  MOVLB  2
022EA:  MOVWF  x8D
022EC:  MOVFF  286,28E
022F0:  MOVLB  0
022F2:  CALL   053C
....................  
.................... 	// Program the end address of the DMA. 
.................... 	temp.Val += len-1; 
022F6:  MOVLW  01
022F8:  MOVLB  2
022FA:  SUBWF  x83,W
022FC:  MOVWF  00
022FE:  MOVLW  00
02300:  SUBWFB x84,W
02302:  MOVWF  03
02304:  MOVF   00,W
02306:  ADDWF  x85,F
02308:  MOVF   03,W
0230A:  ADDWFC x86,F
.................... 	WriteReg(EDMANDL, temp.v[0]); 
0230C:  MOVLW  12
0230E:  MOVWF  x8D
02310:  MOVFF  285,28E
02314:  MOVLB  0
02316:  CALL   053C
.................... 	WriteReg(EDMANDH, temp.v[1]); 
0231A:  MOVLW  13
0231C:  MOVLB  2
0231E:  MOVWF  x8D
02320:  MOVFF  286,28E
02324:  MOVLB  0
02326:  CALL   053C
....................  
.................... 	// Do the checksum calculation 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
0232A:  MOVLW  1F
0232C:  MOVLB  2
0232E:  MOVWF  x8F
02330:  MOVLW  30
02332:  MOVWF  x90
02334:  MOVLB  0
02336:  CALL   0570
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0233A:  MOVLW  1F
0233C:  MOVLB  2
0233E:  MOVWF  x87
02340:  MOVLB  0
02342:  CALL   0504
02346:  MOVFF  01,287
0234A:  MOVLW  00
0234C:  MOVLB  2
0234E:  BTFSC  01.5
02350:  MOVLW  01
02352:  XORLW  00
02354:  BTFSC  FD8.2
02356:  BRA    235C
02358:  MOVLB  0
0235A:  BRA    233A
....................  
.................... 	// Swap endianness and return 
.................... 	temp.v[1] = ReadETHReg(EDMACSL).Val; 
0235C:  MOVLW  16
0235E:  MOVWF  x87
02360:  MOVLB  0
02362:  CALL   0504
02366:  MOVFF  01,286
.................... 	temp.v[0] = ReadETHReg(EDMACSH).Val; 
0236A:  MOVLW  17
0236C:  MOVLB  2
0236E:  MOVWF  x87
02370:  MOVLB  0
02372:  CALL   0504
02376:  MOVFF  01,285
.................... 	return temp.Val; 
0237A:  MOVLB  2
0237C:  MOVFF  285,01
02380:  MOVFF  286,02
.................... } 
02384:  MOVLB  0
02386:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *						 The first byte included in the checksum is the byte 
....................  *						 pointed to by ERDPT, which is updated by calls to 
....................  *						 MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *					which can calculate the checksum faster than software, so 
....................  *					this function replaces the CaclIPBufferChecksum() function 
....................  *					defined in the helpers.c file.  Through the use of 
....................  *					preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *					buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	// Take care of special cases which the DMA cannot be used for 
.................... 	if(len == 0u) 
*
01AB6:  MOVLB  2
01AB8:  MOVF   x68,F
01ABA:  BNZ   1ACA
01ABC:  MOVF   x69,F
01ABE:  BNZ   1ACA
.................... 	{ 
.................... 		return 0xFFFF; 
01AC0:  MOVLW  FF
01AC2:  MOVWF  01
01AC4:  MOVWF  02
01AC6:  BRA    1C0A
.................... 	} 
.................... 	else if(len == 1u) 
01AC8:  BRA    1AF8
01ACA:  DECFSZ x68,W
01ACC:  BRA    1AF8
01ACE:  MOVF   x69,F
01AD0:  BNZ   1AF8
.................... 	{ 
.................... 		return ~(((WORD)MACGet())<<8); 
01AD2:  MOVLB  0
01AD4:  RCALL  1A8E
01AD6:  MOVLB  2
01AD8:  CLRF   x6D
01ADA:  MOVFF  01,26C
01ADE:  MOVFF  01,03
01AE2:  MOVLW  00
01AE4:  CLRF   00
01AE6:  DECF   00,F
01AE8:  XORWF  00,F
01AEA:  MOVLW  FF
01AEC:  XORWF  03,F
01AEE:  MOVFF  00,01
01AF2:  MOVFF  03,02
01AF6:  BRA    1C0A
.................... 	} 
....................  
....................  
.................... 	// Set the DMA starting address to the SPI read pointer value 
.................... 	BankSel(ERDPTL); 
01AF8:  CLRF   x8B
01AFA:  CLRF   x8A
01AFC:  MOVLB  0
01AFE:  CALL   058A
.................... 	temp.v[0] = ReadETHReg(ERDPTL).Val; 
01B02:  MOVLB  2
01B04:  CLRF   x87
01B06:  MOVLB  0
01B08:  CALL   0504
01B0C:  MOVFF  01,26A
.................... 	temp.v[1] = ReadETHReg(ERDPTH).Val; 
01B10:  MOVLW  01
01B12:  MOVLB  2
01B14:  MOVWF  x87
01B16:  MOVLB  0
01B18:  CALL   0504
01B1C:  MOVFF  01,26B
.................... 	WriteReg(EDMASTL, temp.v[0]); 
01B20:  MOVLW  10
01B22:  MOVLB  2
01B24:  MOVWF  x8D
01B26:  MOVFF  26A,28E
01B2A:  MOVLB  0
01B2C:  CALL   053C
.................... 	WriteReg(EDMASTH, temp.v[1]); 
01B30:  MOVLW  11
01B32:  MOVLB  2
01B34:  MOVWF  x8D
01B36:  MOVFF  26B,28E
01B3A:  MOVLB  0
01B3C:  CALL   053C
....................  
.................... 	// See if we are calculating a checksum within the RX buffer (where 
.................... 	// wrapping rules apply) or TX/unused area (where wrapping rules are 
.................... 	// not applied) 
.................... #if RXSTART == 0 
.................... 	if(temp.Val <= RXSTOP) 
01B40:  MOVLB  2
01B42:  MOVF   x6B,W
01B44:  SUBLW  1B
01B46:  BNC   1B7E
01B48:  BNZ   1B50
01B4A:  MOVF   x6A,W
01B4C:  SUBLW  F7
01B4E:  BNC   1B7E
.................... #else 
.................... 	if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
.................... 	{ 
.................... 		// Calculate the DMA ending address given the starting address and len 
.................... 		// parameter.  The DMA will follow the receive buffer wrapping boundary. 
.................... 		temp.Val += len-1; 
01B50:  MOVLW  01
01B52:  SUBWF  x68,W
01B54:  MOVWF  00
01B56:  MOVLW  00
01B58:  SUBWFB x69,W
01B5A:  MOVWF  03
01B5C:  MOVF   00,W
01B5E:  ADDWF  x6A,F
01B60:  MOVF   03,W
01B62:  ADDWFC x6B,F
.................... 		if(temp.Val > RXSTOP) 
01B64:  MOVF   x6B,W
01B66:  SUBLW  1A
01B68:  BC    1B7C
01B6A:  XORLW  FF
01B6C:  BNZ   1B74
01B6E:  MOVF   x6A,W
01B70:  SUBLW  F7
01B72:  BC    1B7C
.................... 		{ 
.................... 			temp.Val -= RXSIZE; 
01B74:  MOVLW  F8
01B76:  SUBWF  x6A,F
01B78:  MOVLW  1B
01B7A:  SUBWFB x6B,F
.................... 		} 
.................... 	} 
.................... 	else 
01B7C:  BRA    1B92
.................... 	{ 
.................... 		temp.Val += len-1; 
01B7E:  MOVLW  01
01B80:  SUBWF  x68,W
01B82:  MOVWF  00
01B84:  MOVLW  00
01B86:  SUBWFB x69,W
01B88:  MOVWF  03
01B8A:  MOVF   00,W
01B8C:  ADDWF  x6A,F
01B8E:  MOVF   03,W
01B90:  ADDWFC x6B,F
.................... 	} 
....................  
.................... 	// Write the DMA end address 
.................... 	WriteReg(EDMANDL, temp.v[0]); 
01B92:  MOVLW  12
01B94:  MOVWF  x8D
01B96:  MOVFF  26A,28E
01B9A:  MOVLB  0
01B9C:  CALL   053C
.................... 	WriteReg(EDMANDH, temp.v[1]); 
01BA0:  MOVLW  13
01BA2:  MOVLB  2
01BA4:  MOVWF  x8D
01BA6:  MOVFF  26B,28E
01BAA:  MOVLB  0
01BAC:  CALL   053C
....................  
.................... 	// Begin the DMA checksum calculation and wait until it is finished 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
01BB0:  MOVLW  1F
01BB2:  MOVLB  2
01BB4:  MOVWF  x8F
01BB6:  MOVLW  30
01BB8:  MOVWF  x90
01BBA:  MOVLB  0
01BBC:  CALL   0570
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
01BC0:  MOVLW  1F
01BC2:  MOVLB  2
01BC4:  MOVWF  x87
01BC6:  MOVLB  0
01BC8:  CALL   0504
01BCC:  MOVFF  01,26C
01BD0:  MOVLW  00
01BD2:  MOVLB  2
01BD4:  BTFSC  01.5
01BD6:  MOVLW  01
01BD8:  XORLW  00
01BDA:  BTFSC  FD8.2
01BDC:  BRA    1BE2
01BDE:  MOVLB  0
01BE0:  BRA    1BC0
....................  
.................... 	// Return the resulting good stuff 
.................... 	temp.v[0] = ReadETHReg(EDMACSL).Val; 
01BE2:  MOVLW  16
01BE4:  MOVWF  x87
01BE6:  MOVLB  0
01BE8:  CALL   0504
01BEC:  MOVFF  01,26A
.................... 	temp.v[1] = ReadETHReg(EDMACSH).Val; 
01BF0:  MOVLW  17
01BF2:  MOVLB  2
01BF4:  MOVWF  x87
01BF6:  MOVLB  0
01BF8:  CALL   0504
01BFC:  MOVFF  01,26B
.................... 	return temp.Val; 
01C00:  MOVLB  2
01C02:  MOVFF  26A,01
01C06:  MOVFF  26B,02
.................... } 
01C0A:  MOVLB  0
01C0C:  RETLW  00
.................... #endif	// End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  * 							  destination MAC address) to copy from. 
....................  *					TxOffset: Offset in the TX buffer (0=first byte of 
....................  *							  destination MAC address) to copy to. 
....................  *					len:	  Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *					set), the hardware will wait until it is finished.  Then, 
....................  *					the DMA module will copy the data from the receive buffer 
....................  *					to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
.................... 	WORD_VAL temp; 
....................  
.................... 	temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	BankSel(EDMASTL); 
.................... 	WriteReg(EDMASTL, temp.v[0]); 
.................... 	WriteReg(EDMASTH, temp.v[1]); 
....................  
.................... 	temp.Val += len-1; 
.................... 	if ( temp.Val > RXSTOP )		// Adjust value if a wrap is needed 
.................... 		temp.Val -= RXSIZE; 
....................  
.................... 	WriteReg(EDMANDL, temp.v[0]); 
.................... 	WriteReg(EDMANDH, temp.v[1]); 
....................  
.................... 	TxOffset += TXSTART+1; 
.................... 	WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
.................... 	WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
.................... 	// Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
.................... 	// before starting the copy. 
.................... 	BFCReg(ECON1, ECON1_CSUMEN); 
.................... 	BFSReg(ECON1, ECON1_DMAST); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *										BYTE *PatternMask, 
....................  *										WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *					*PatternMask: Pointer to an 8 byte pattern mask which 
....................  *								  defines which bytes of the pattern are 
....................  *								  important.  At least one bit must be set. 
....................  *					PatternOffset: Offset from the beginning of the Ethernet 
....................  *								   frame (1st byte of destination address), to 
....................  *								   begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *					CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *					subset of the broadcast packets which are normally 
....................  *					received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
.................... 					BYTE *PatternMask, 
.................... 					WORD PatternOffset) 
.................... { 
.................... 	WORD_VAL i; 
.................... 	BYTE *MaskPtr; 
.................... 	BYTE UnmaskedPatternLen; 
....................  
.................... 	// Set the SPI write pointer and DMA startting address to the beginning of 
.................... 	// the transmit buffer 
.................... 	BankSel(EWRPTL); 
.................... 	WriteReg(EWRPTL, LOW(TXSTART)); 
.................... 	WriteReg(EWRPTH, HIGH(TXSTART)); 
.................... 	WriteReg(EDMASTL, LOW(TXSTART)); 
.................... 	WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
.................... 	// Fill the transmit buffer with the pattern to match against.  Only the 
.................... 	// bytes which have a mask bit of 1 are written into the buffer and will 
.................... 	// subsequently be used for checksum computation. 
.................... 	MaskPtr = PatternMask; 
.................... 	for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
.................... 	{ 
.................... 		if( *MaskPtr & i.v[1] ) 
.................... 		{ 
.................... 			MACPut(*Pattern); 
.................... 			UnmaskedPatternLen++; 
.................... 		} 
.................... 		Pattern++; 
....................  
.................... 		i.v[1] <<= 1; 
.................... 		if( i.v[1] == 0u ) 
.................... 		{ 
.................... 			i.v[1] = 0x01; 
.................... 			MaskPtr++; 
.................... 		} 
.................... 	} 
....................  
.................... 	// Calculate and set the DMA end address 
.................... 	i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
.................... 	WriteReg(EDMANDL, i.v[0]); 
.................... 	WriteReg(EDMANDH, i.v[1]); 
....................  
.................... 	// Calculate the checksum on the given pattern using the DMA module 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Make certain that the PM filter isn't enabled while it is 
.................... 	// being reconfigured. 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
.................... 	// Get the calculated DMA checksum and store it in the PM 
.................... 	// checksum registers 
.................... 	i.v[0] == ReadETHReg(EDMACSL).Val; 
.................... 	i.v[1] == ReadETHReg(EDMACSH).Val; 
.................... 	WriteReg(EPMCSL, i.v[0]); 
.................... 	WriteReg(EPMCSH, i.v[0]); 
....................  
.................... 	// Set the Pattern Match offset and 8 byte mask 
.................... 	WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
.................... 	WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
.................... 	for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
.................... 	{ 
.................... 		WriteReg(i.Val, *PatternMask++); 
.................... 	} 
....................  
.................... 	// Begin using the new Pattern Match filter instead of the 
.................... 	// broadcast filter 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *					filter (if enabled) and returns to the default filter 
....................  *					configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
.................... 	BankSel(ERXFCON); 
.................... 	WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
.................... 	return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *					increments ERDPT so MACGet() can be called again.  The 
....................  *					increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
01A8E:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
01A90:  MOVLW  3A
01A92:  MOVLB  2
01A94:  MOVWF  x92
01A96:  MOVLB  0
01A98:  CALL   04F4
....................    c=ENCSPIXfer(0); 
01A9C:  MOVLB  2
01A9E:  CLRF   x92
01AA0:  MOVLB  0
01AA2:  CALL   04F4
01AA6:  MOVFF  01,26C
....................    SPIUnselectEthernet(); 
01AAA:  BSF    F8C.1
....................    return(c); 
01AAC:  MOVLB  2
01AAE:  MOVFF  26C,01
.................... }//end MACGet 
01AB2:  MOVLB  0
01AB4:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *					len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *					and places them into local memory.  With SPI burst support, 
....................  *					it performs much faster than multiple MACGet() calls. 
....................  *					ERDPT is incremented after each byte, following the same 
....................  *					rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	int16 i; 
....................  
.................... 	// Start the burst operation 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RBM;			// Send the Read Buffer Memory opcode. 
.................... 	i = 0; 
.................... 	val--; 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Read the data 
.................... 	while(i<len) 
.................... 	{ 
.................... 		SSPBUF = 0;			// Send a dummy byte to receive a byte 
.................... 		i++; 
.................... 		val++; 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is received. 
.................... 		PIR1_SSPIF = 0; 
.................... 		*val = SSPBUF; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return i; 
.................... */ 
....................  
....................    int16 i=0; 
*
00C94:  MOVLB  2
00C96:  CLRF   x7A
00C98:  CLRF   x7B
....................  
....................    SPISelectEthernet(); 
00C9A:  BCF    F8C.1
....................    ENCSPIXfer(RBM); 
00C9C:  MOVLW  3A
00C9E:  MOVWF  x92
00CA0:  MOVLB  0
00CA2:  RCALL  04F4
....................    while(i<len) 
....................    { 
00CA4:  MOVLB  2
00CA6:  MOVF   x7B,W
00CA8:  SUBWF  x79,W
00CAA:  BNC   0CE2
00CAC:  BNZ   0CB4
00CAE:  MOVF   x78,W
00CB0:  SUBWF  x7A,W
00CB2:  BC    0CE2
....................       *val=ENCSPIXfer(0); 
00CB4:  MOVFF  277,03
00CB8:  MOVFF  276,27C
00CBC:  MOVFF  277,27D
00CC0:  CLRF   x92
00CC2:  MOVLB  0
00CC4:  RCALL  04F4
00CC6:  MOVFF  27D,FEA
00CCA:  MOVFF  27C,FE9
00CCE:  MOVFF  01,FEF
....................       val++; 
00CD2:  MOVLB  2
00CD4:  INCF   x76,F
00CD6:  BTFSC  FD8.2
00CD8:  INCF   x77,F
....................       i++; 
00CDA:  INCF   x7A,F
00CDC:  BTFSC  FD8.2
00CDE:  INCF   x7B,F
....................    } 
00CE0:  BRA    0CA6
....................    SPIUnselectEthernet(); 
00CE2:  BSF    F8C.1
....................  
....................    return(i); 
00CE4:  MOVFF  27A,01
00CE8:  MOVFF  27B,02
.................... }//end MACGetArray 
00CEC:  MOVLB  0
00CEE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *					(8 bits) and data to write (8 bits) over the SPI. 
....................  *					EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the opcode and constant. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = val;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until byte is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
010D0:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
010D2:  MOVLW  7A
010D4:  MOVLB  2
010D6:  MOVWF  x92
010D8:  MOVLB  0
010DA:  CALL   04F4
....................    ENCSPIXfer(val); 
010DE:  MOVFF  28B,292
010E2:  CALL   04F4
....................    SPIUnselectEthernet(); 
010E6:  BSF    F8C.1
.................... }//end MACPut 
010E8:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *					len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *					ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *					calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
.................... 	// Select the chip and send the proper opcode 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WBM;			// Send the Write Buffer Memory opcode 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/constant is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	// Send the data 
.................... 	while(len) 
.................... 	{ 
.................... 		SSPBUF = *val;		// Start sending the byte 
.................... 		val++;				// Increment after writing to SSPBUF to increase speed 
.................... 		len--;				// Decrement after writing to SSPBUF to increase speed 
.................... 		while(!PIR1_SSPIF);	// Wait until byte is transmitted 
.................... 		PIR1_SSPIF = 0; 
.................... 	}; 
....................  
.................... 	// Terminate the burst operation 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
010EA:  BCF    F8C.1
....................    ENCSPIXfer(WBM); 
010EC:  MOVLW  7A
010EE:  MOVLB  2
010F0:  MOVWF  x92
010F2:  MOVLB  0
010F4:  CALL   04F4
....................    while(len--) 
....................    { 
010F8:  MOVLB  2
010FA:  MOVFF  28F,03
010FE:  MOVF   x8E,W
01100:  BTFSC  FD8.2
01102:  DECF   x8F,F
01104:  DECF   x8E,F
01106:  IORWF  03,W
01108:  BZ    112E
....................       ENCSPIXfer(*val); 
0110A:  MOVFF  28D,03
0110E:  MOVFF  28C,FE9
01112:  MOVFF  28D,FEA
01116:  MOVFF  FEF,290
0111A:  MOVFF  290,292
0111E:  MOVLB  0
01120:  CALL   04F4
....................       val++; 
01124:  MOVLB  2
01126:  INCF   x8C,F
01128:  BTFSC  FD8.2
0112A:  INCF   x8D,F
....................    } 
0112C:  BRA    10FA
....................    SPIUnselectEthernet(); 
0112E:  BSF    F8C.1
.................... }//end MACPutArray 
01130:  MOVLB  0
01132:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *					the Ethernet controller.  It resets all register contents 
....................  *					(except for ECOCON) and returns the device to the power 
....................  *					on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = SR; 
.................... 	while(!PIR1_SSPIF);		// Wait until the command is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0052A:  BCF    F8C.1
....................    ENCSPIXfer(SR); 
0052C:  MOVLW  FF
0052E:  MOVLB  2
00530:  MOVWF  x92
00532:  MOVLB  0
00534:  RCALL  04F4
....................    SPIUnselectEthernet(); 
00536:  BSF    F8C.1
.................... }//end SendSystemReset 
00538:  GOTO   07EE (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *					the SPI and then retrives the register contents in the 
....................  *					next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *					registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	// Select the chip and send the Read Control Register opcode/address 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = RCR | Address; 
....................  
.................... 	while(!PIR1_SSPIF);		// Wait until the opcode/address is transmitted 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = 0;				// Send a dummy byte to receive the register 
.................... 							//   contents 
.................... 	while(!PIR1_SSPIF);		// Wait until the register is received 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
00504:  BCF    F8C.1
....................    ENCSPIXfer(RCR | Address); 
00506:  MOVFF  287,289
0050A:  MOVFF  287,292
0050E:  MOVLB  0
00510:  RCALL  04F4
....................    c=ENCSPIXfer(0); 
00512:  MOVLB  2
00514:  CLRF   x92
00516:  MOVLB  0
00518:  RCALL  04F4
0051A:  MOVFF  01,288
....................    SPIUnselectEthernet(); 
0051E:  BSF    F8C.1
....................    return(c); 
00520:  MOVLB  2
00522:  MOVFF  288,01
.................... }//end ReadETHReg 
00526:  MOVLB  0
00528:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  * 					to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *					  The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *					as a dummy byte over the SPI and then retrives the 
....................  *					register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *					registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *					purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
.................... 	SPISelectEthernet(); 
....................  
.................... 	SSPBUF = RCR | Address;	// Send the Read Control Register opcode and 
.................... 							//   address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send a dummy byte 
.................... 	while(!PIR1_SSPIF);		// Wait for the dummy byte to be transmitted 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SSPBUF = 0;				// Send another dummy byte to receive the register 
.................... 							//   contents. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is received. 
.................... 	PIR1_SSPIF = 0; 
....................  
.................... 	SPIUnselectEthernet(); 
....................  
.................... 	return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
005C0:  BCF    F8C.1
....................  
....................    ENCSPIXfer(RCR | Address); 
005C2:  MOVFF  1E4,1E6
005C6:  MOVFF  1E4,292
005CA:  MOVLB  0
005CC:  RCALL  04F4
....................    ENCSPIXfer(0); 
005CE:  MOVLB  2
005D0:  CLRF   x92
005D2:  MOVLB  0
005D4:  RCALL  04F4
....................    c=ENCSPIXfer(0); 
005D6:  MOVLB  2
005D8:  CLRF   x92
005DA:  MOVLB  0
005DC:  RCALL  04F4
005DE:  MOVFF  01,1E5
....................  
....................    SPIUnselectEthernet(); 
005E2:  BSF    F8C.1
....................  
....................    return(c); 
005E4:  MOVLB  1
005E6:  MOVFF  1E5,01
.................... }//end ReadMACReg 
005EA:  MOVLB  0
005EC:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
.................... 	PHYREG Result; 
....................  
.................... 	// Set the right address and start the register read operation 
.................... 	BankSel(MIREGADR); 
*
00684:  MOVLW  02
00686:  MOVLB  2
00688:  MOVWF  x8B
0068A:  MOVLW  14
0068C:  MOVWF  x8A
0068E:  MOVLB  0
00690:  RCALL  058A
.................... 	WriteReg(MIREGADR, Register); 
00692:  MOVLW  14
00694:  MOVLB  2
00696:  MOVWF  x8D
00698:  MOVFF  1E1,28E
0069C:  MOVLB  0
0069E:  RCALL  053C
.................... 	WriteReg(MICMD, MICMD_MIIRD); 
006A0:  MOVLW  12
006A2:  MOVLB  2
006A4:  MOVWF  x8D
006A6:  MOVLW  01
006A8:  MOVWF  x8E
006AA:  MOVLB  0
006AC:  RCALL  053C
....................  
.................... 	// Loop to wait until the PHY register has been read through the MII 
.................... 	// This requires 10.24us 
.................... 	BankSel(MISTAT); 
006AE:  MOVLW  03
006B0:  MOVLB  2
006B2:  MOVWF  x8B
006B4:  MOVLW  0A
006B6:  MOVWF  x8A
006B8:  MOVLB  0
006BA:  RCALL  058A
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
006BC:  MOVLW  0A
006BE:  MOVLB  1
006C0:  MOVWF  xE4
006C2:  MOVLB  0
006C4:  RCALL  05C0
006C6:  MOVFF  01,1E4
006CA:  MOVLW  00
006CC:  MOVLB  1
006CE:  BTFSC  01.0
006D0:  MOVLW  01
006D2:  XORLW  00
006D4:  BTFSC  FD8.2
006D6:  BRA    06DC
006D8:  MOVLB  0
006DA:  BRA    06BC
....................  
.................... 	// Stop reading 
.................... 	BankSel(MIREGADR); 
006DC:  MOVLW  02
006DE:  MOVLB  2
006E0:  MOVWF  x8B
006E2:  MOVLW  14
006E4:  MOVWF  x8A
006E6:  MOVLB  0
006E8:  RCALL  058A
.................... 	WriteReg(MICMD, 0x00); 
006EA:  MOVLW  12
006EC:  MOVLB  2
006EE:  MOVWF  x8D
006F0:  CLRF   x8E
006F2:  MOVLB  0
006F4:  RCALL  053C
....................  
.................... 	// Obtain results and return 
.................... 	Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
006F6:  MOVLW  18
006F8:  MOVLB  1
006FA:  MOVWF  xE4
006FC:  MOVLB  0
006FE:  RCALL  05C0
00700:  MOVFF  01,1E2
.................... 	Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
00704:  MOVLW  19
00706:  MOVLB  1
00708:  MOVWF  xE4
0070A:  MOVLB  0
0070C:  RCALL  05C0
0070E:  MOVFF  01,1E3
.................... 	return Result; 
00712:  MOVLB  1
00714:  MOVFF  1E2,01
00718:  MOVFF  1E3,02
.................... }//end ReadPHYReg 
0071C:  MOVLB  0
0071E:  GOTO   0738 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *					  The top 3 bits must be 0. 
....................  *					Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *					SPI and then sends the data to write in the next 8 SPI 
....................  *					clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *					BFSReg() functions.  It is seperate to maximize speed. 
....................  *					Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *					can write to any ETH or MAC register.  Writing to PHY 
....................  *					registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = WCR | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
0053C:  BCF    F8C.1
....................    ENCSPIXfer(WCR | Address); 
0053E:  MOVLB  2
00540:  MOVF   x8D,W
00542:  IORLW  40
00544:  MOVWF  x8F
00546:  MOVWF  x92
00548:  MOVLB  0
0054A:  RCALL  04F4
....................    ENCSPIXfer(Data); 
0054C:  MOVFF  28E,292
00550:  RCALL  04F4
....................    SPIUnselectEthernet(); 
00552:  BSF    F8C.1
.................... }//end WriteReg 
00554:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					  to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFSReg() functions.  It is separate to maximize speed. 
....................  *					BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFC | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00556:  BCF    F8C.1
....................    ENCSPIXfer(BFC | Address); 
00558:  MOVLB  2
0055A:  MOVF   x8C,W
0055C:  IORLW  A0
0055E:  MOVWF  x8E
00560:  MOVWF  x92
00562:  MOVLB  0
00564:  RCALL  04F4
....................    ENCSPIXfer(Data); 
00566:  MOVFF  28D,292
0056A:  RCALL  04F4
....................    SPIUnselectEthernet(); 
0056C:  BSF    F8C.1
.................... }//end BFCReg 
0056E:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 					Bank select bits must be set corresponding to the register 
....................  *					to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *					  must be 0. 
....................  *					Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *					SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *					BFCReg() functions.  It is separate to maximize speed. 
....................  *					BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
.................... 	SPISelectEthernet(); 
.................... 	SSPBUF = BFS | Address;	// Send the opcode and address. 
.................... 	while(!PIR1_SSPIF);		// Wait until opcode/address is transmitted. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SSPBUF = Data;			// Send the byte to be writen. 
.................... 	while(!PIR1_SSPIF);		// Wait until register is written. 
.................... 	PIR1_SSPIF = 0; 
.................... 	SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00570:  BCF    F8C.1
....................    ENCSPIXfer(BFS | Address); 
00572:  MOVLB  2
00574:  MOVF   x8F,W
00576:  IORLW  80
00578:  MOVWF  x91
0057A:  MOVWF  x92
0057C:  MOVLB  0
0057E:  RCALL  04F4
....................    ENCSPIXfer(Data); 
00580:  MOVFF  290,292
00584:  RCALL  04F4
....................    SPIUnselectEthernet(); 
00586:  BSF    F8C.1
.................... }//end BFSReg 
00588:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *					16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *					progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
.................... 	// Write the register address 
.................... 	BankSel(MIREGADR); 
*
005EE:  MOVLW  02
005F0:  MOVLB  2
005F2:  MOVWF  x8B
005F4:  MOVLW  14
005F6:  MOVWF  x8A
005F8:  MOVLB  0
005FA:  RCALL  058A
.................... 	WriteReg(MIREGADR, Register); 
005FC:  MOVLW  14
005FE:  MOVLB  2
00600:  MOVWF  x8D
00602:  MOVFF  1E1,28E
00606:  MOVLB  0
00608:  RCALL  053C
....................  
.................... 	// Write the data 
.................... 	// Order is important: write low byte first, high byte last 
.................... 	WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
0060A:  MOVLW  01
0060C:  MOVLB  1
0060E:  MOVWF  xE5
00610:  MOVLW  E2
00612:  MOVWF  FE9
00614:  MOVFF  1E5,FEA
00618:  MOVFF  FEF,1E6
0061C:  MOVLW  16
0061E:  MOVLB  2
00620:  MOVWF  x8D
00622:  MOVFF  1E6,28E
00626:  MOVLB  0
00628:  RCALL  053C
.................... 	WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
0062A:  MOVLW  01
0062C:  MOVLB  1
0062E:  MOVWF  xE5
00630:  MOVLW  E2
00632:  MOVWF  xE4
00634:  MOVLW  01
00636:  ADDWF  xE4,W
00638:  MOVWF  FE9
0063A:  MOVLW  00
0063C:  ADDWFC xE5,W
0063E:  MOVWF  FEA
00640:  MOVFF  FEF,1E6
00644:  MOVLW  17
00646:  MOVLB  2
00648:  MOVWF  x8D
0064A:  MOVFF  1E6,28E
0064E:  MOVLB  0
00650:  RCALL  053C
....................  
.................... 	// Wait until the PHY register has been written 
.................... 	BankSel(MISTAT); 
00652:  MOVLW  03
00654:  MOVLB  2
00656:  MOVWF  x8B
00658:  MOVLW  0A
0065A:  MOVWF  x8A
0065C:  MOVLB  0
0065E:  RCALL  058A
.................... 	while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00660:  MOVLW  0A
00662:  MOVLB  1
00664:  MOVWF  xE4
00666:  MOVLB  0
00668:  RCALL  05C0
0066A:  MOVFF  01,1E4
0066E:  MOVLW  00
00670:  MOVLB  1
00672:  BTFSC  01.0
00674:  MOVLW  01
00676:  XORLW  00
00678:  BTFSC  FD8.2
0067A:  BRA    0680
0067C:  MOVLB  0
0067E:  BRA    0660
.................... }//end WritePHYReg 
00680:  MOVLB  0
00682:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *					  select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *					changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
.................... 	BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
0058A:  MOVLW  1F
0058C:  MOVLB  2
0058E:  MOVWF  x8C
00590:  MOVLW  03
00592:  MOVWF  x8D
00594:  MOVLB  0
00596:  RCALL  0556
.................... 	BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00598:  MOVLW  02
0059A:  MOVLB  2
0059C:  MOVWF  x8D
0059E:  MOVLW  8A
005A0:  MOVWF  x8C
005A2:  MOVLW  01
005A4:  ADDWF  x8C,W
005A6:  MOVWF  FE9
005A8:  MOVLW  00
005AA:  ADDWFC x8D,W
005AC:  MOVWF  FEA
005AE:  MOVFF  FEF,28E
005B2:  MOVLW  1F
005B4:  MOVWF  x8F
005B6:  MOVFF  28E,290
005BA:  MOVLB  0
005BC:  RCALL  0570
.................... }//end BankSel 
005BE:  RETLW  00
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *					FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *					RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *					entire dual port memory and calculate a checksum of the 
....................  *					data stored within.  Address and Random fill modes are 
....................  *					used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *					seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *					is running, additional confidence that the memory is 
....................  *					working can be obtained by calling TestMemory multiple 
....................  *					times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
.................... 	#define RANDOM_FILL		0b0000 
.................... 	#define ADDRESS_FILL	0b0100 
.................... 	#define PATTERN_SHIFT	0b1000 
....................  
.................... 	WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
.................... 	// Select Bank 0 and disable anything that could have been in progress 
.................... 	WriteReg(ECON1, 0x00); 
....................  
.................... 	// Set up necessary pointers for the DMA to calculate over the entire 
.................... 	// memory 
.................... 	WriteReg(EDMASTL, 0x00); 
.................... 	WriteReg(EDMASTH, 0x00); 
.................... 	WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
.................... 	WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
.................... 	// Enable Test Mode and do an Address Fill 
.................... 	BankSel(EBSTCON); 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 						 EBSTCON_BISTST | 
.................... 						 ADDRESS_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode before 
.................... 	// starting any DMA operations. 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
.................... 	// Compare the results 
.................... 	// 0xF807 should always be generated in Address fill mode 
.................... 	if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
.................... 		return FALSE; 
....................  
.................... 	// Seed the random number generator and begin another Random Fill test 
.................... 	// with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
.................... 	WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
.................... 	WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
.................... 	WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
.................... 					  EBSTCON_PSEL | 
.................... 					  EBSTCON_BISTST | 
.................... 					  RANDOM_FILL); 
....................  
....................  
.................... 	// Wait for the BIST to complete and disable test mode since 
.................... 	// we won't be needing it anymore 
.................... 	while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
.................... 	BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
.................... 	// Begin reading the memory and calculating a checksum over it 
.................... 	// Block until the checksum is generated 
.................... 	BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
.................... 	BankSel(EDMACSL); 
.................... 	while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
.................... 	// Obtain the resulting DMA checksum and the expected BIST checksum 
.................... 	DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
.................... 	DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
.................... 	BankSel(EBSTCSL); 
.................... 	BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
.................... 	BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
.................... 	return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *						FULL: Set full duplex mode 
....................  *						HALF: Set half duplex mode 
....................  *						USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *								 PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *					operation, sets PHY up for full duplex operation, and 
....................  *					reenables RX logic.  The back-to-back inter-packet gap 
....................  *					register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *					function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
.................... 	REG Register; 
.................... 	PHYREG PhyReg; 
....................  
.................... 	// Disable receive logic and abort any packets currently being transmitted 
.................... 	BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
00722:  MOVLW  1F
00724:  MOVLB  2
00726:  MOVWF  x8C
00728:  MOVLW  0C
0072A:  MOVWF  x8D
0072C:  MOVLB  0
0072E:  RCALL  0556
....................  
.................... 	// Set the PHY to the proper duplex mode 
.................... 	PhyReg = ReadPHYReg(PHCON1); 
00730:  MOVLB  1
00732:  CLRF   xE1
00734:  MOVLB  0
00736:  BRA    0684
00738:  MOVFF  02,1E0
0073C:  MOVFF  01,1DF
.................... 	if(DuplexState == USE_PHY) 
00740:  MOVLB  1
00742:  MOVF   xDD,W
00744:  SUBLW  02
00746:  BNZ   0750
.................... 	{ 
.................... 		DuplexState = PhyReg.PHCON1bits.PDPXMD; 
00748:  CLRF   xDD
0074A:  BTFSC  xE0.0
0074C:  INCF   xDD,F
.................... 	} 
.................... 	else 
0074E:  BRA    0764
.................... 	{ 
.................... 		PhyReg.PHCON1bits.PDPXMD = DuplexState; 
00750:  BCF    xE0.0
00752:  BTFSC  xDD.0
00754:  BSF    xE0.0
.................... 		WritePHYReg(PHCON1, PhyReg.Val); 
00756:  CLRF   xE1
00758:  MOVFF  1E0,1E3
0075C:  MOVFF  1DF,1E2
00760:  MOVLB  0
00762:  RCALL  05EE
.................... 	} 
....................  
.................... 	// Set the MAC to the proper duplex mode 
.................... 	BankSel(MACON3); 
00764:  MOVLW  02
00766:  MOVLB  2
00768:  MOVWF  x8B
0076A:  MOVWF  x8A
0076C:  MOVLB  0
0076E:  RCALL  058A
.................... 	Register = ReadMACReg(MACON3); 
00770:  MOVLW  02
00772:  MOVLB  1
00774:  MOVWF  xE4
00776:  MOVLB  0
00778:  RCALL  05C0
0077A:  MOVFF  01,1DE
.................... 	Register.MACON3bits.FULDPX = DuplexState; 
0077E:  MOVLB  1
00780:  BCF    xDE.0
00782:  BTFSC  xDD.0
00784:  BSF    xDE.0
.................... 	WriteReg(MACON3, Register.Val); 
00786:  MOVLW  02
00788:  MOVLB  2
0078A:  MOVWF  x8D
0078C:  MOVFF  1DE,28E
00790:  MOVLB  0
00792:  RCALL  053C
....................  
.................... 	// Set the back-to-back inter-packet gap time to IEEE specified 
.................... 	// requirements.  The meaning of the MABBIPG value changes with the duplex 
.................... 	// state, so it must be updated in this function. 
.................... 	// In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
.................... 	WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
00794:  MOVLB  1
00796:  MOVF   xDD,F
00798:  BZ    079E
0079A:  MOVLW  15
0079C:  BRA    07A0
0079E:  MOVLW  12
007A0:  MOVWF  xE1
007A2:  MOVLW  04
007A4:  MOVLB  2
007A6:  MOVWF  x8D
007A8:  MOVFF  1E1,28E
007AC:  MOVLB  0
007AE:  RCALL  053C
....................  
.................... 	// Reenable receive logic 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
007B0:  MOVLW  1F
007B2:  MOVLB  2
007B4:  MOVWF  x8F
007B6:  MOVLW  04
007B8:  MOVWF  x90
007BA:  MOVLB  0
007BC:  RCALL  0570
.................... }//end MACSetDuplex 
007BE:  GOTO   097E (RETURN)
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *					sleep mode, no packets can be transmitted or received. 
....................  *					All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  * 					called, this function will block until it is it complete. 
....................  *					If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
.................... 	// Disable packet reception 
.................... 	BFCReg(ECON1, ECON1_RXEN); 
....................  
.................... 	// Make sure any last packet which was in-progress when RXEN was cleared 
.................... 	// is completed 
.................... 	while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
.................... 	// If a packet is being transmitted, wait for it to finish 
.................... 	while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
.................... 	// Enter sleep mode 
.................... 	BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *					after a previous call to MACPowerDown().  Calling this 
....................  *					function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *					you don't wait for the link to go up first.  MACIsLinked() 
....................  *					can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
.................... 	// Leave power down mode 
.................... 	BFCReg(ECON2, ECON2_PWRSV); 
....................  
.................... 	// Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
.................... 	// delay is required for the PHY module to return to an operational state. 
.................... 	while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
.................... 	// Enable packet reception 
.................... 	BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *								0x01: Divide by 1 (25 MHz) 
....................  *								0x02: Divide by 2 (12.5 MHz) 
....................  *								0x03: Divide by 3 (8.333333 MHz) 
....................  *								0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *								0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *					The CLKOUT pin will beginning outputting the new frequency 
....................  *					immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *						   0x01: Divide by 1 (25 MHz) 
....................  *						   0x02: Divide by 2 (12.5 MHz) 
....................  *						   0x03: Divide by 3 (8.333333 MHz) 
....................  *						   0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *						   0x05: Divide by 8 (3.125 MHz) 
....................  *						   0x06: Reserved 
....................  *						   0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
.................... 	BankSel(ECOCON); 
.................... 	return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
018BC:  MOVLW  01
018BE:  MOVLB  2
018C0:  MOVWF  x01
018C2:  MOVLW  EC
018C4:  MOVFF  201,277
018C8:  MOVWF  x76
018CA:  CLRF   x79
018CC:  MOVLW  14
018CE:  MOVWF  x78
018D0:  MOVLB  0
018D2:  CALL   0C94
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
018D6:  MOVLB  1
018D8:  MOVF   xEC,W
018DA:  ANDLW  F0
018DC:  SUBLW  40
018DE:  BZ    18E6
....................     	return FALSE; 
018E0:  MOVLW  00
018E2:  MOVWF  01
018E4:  BRA    199A
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
018E6:  MOVF   xEC,W
018E8:  ANDLW  0F
018EA:  MOVWF  00
018EC:  RLCF   00,W
018EE:  MOVWF  5C
018F0:  RLCF   5C,F
018F2:  MOVLW  FC
018F4:  ANDWF  5C,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
018F6:  MOVLB  2
018F8:  CLRF   x3C
018FA:  CLRF   x3B
018FC:  CLRF   x3E
018FE:  MOVFF  5C,23D
01902:  MOVLB  0
01904:  RCALL  1658
01906:  MOVFF  02,1EB
0190A:  MOVFF  01,1EA
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
0190E:  MOVLB  2
01910:  CLRF   x15
01912:  MOVFF  5C,214
01916:  MOVLB  0
01918:  RCALL  1760
....................  
....................     if(CalcChecksum.Val) 
0191A:  MOVLB  1
0191C:  MOVF   xEA,W
0191E:  IORWF  xEB,W
01920:  BZ    1928
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
01922:  MOVLW  00
01924:  MOVWF  01
01926:  BRA    199A
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
01928:  MOVLW  01
0192A:  MOVLB  2
0192C:  MOVWF  x82
0192E:  MOVLW  EC
01930:  MOVWF  x81
01932:  MOVLB  0
01934:  RCALL  17DC
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
01936:  MOVLB  1
01938:  MOVF   xE2,W
0193A:  IORWF  xE3,W
0193C:  BZ    1956
....................         localIP->Val    = header.DestAddress.Val; 
0193E:  MOVFF  1E2,FE9
01942:  MOVFF  1E3,FEA
01946:  MOVFF  1FC,FEF
0194A:  MOVFF  1FD,FEC
0194E:  MOVFF  1FE,FEC
01952:  MOVFF  1FF,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
01956:  MOVLW  06
01958:  ADDWF  xE4,W
0195A:  MOVWF  FE9
0195C:  MOVLW  00
0195E:  ADDWFC xE5,W
01960:  MOVWF  FEA
01962:  MOVFF  1F8,FEF
01966:  MOVFF  1F9,FEC
0196A:  MOVFF  1FA,FEC
0196E:  MOVFF  1FB,FEC
....................     *protocol           = header.Protocol; 
01972:  MOVFF  1E6,FE9
01976:  MOVFF  1E7,FEA
0197A:  MOVFF  1F5,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
0197E:  MOVFF  1E8,FE9
01982:  MOVFF  1E9,FEA
01986:  MOVF   5C,W
01988:  SUBWF  xEE,W
0198A:  MOVWF  00
0198C:  MOVLW  00
0198E:  SUBWFB xEF,W
01990:  MOVFF  00,FEF
01994:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
01996:  MOVLW  01
01998:  MOVWF  01
.................... } 
0199A:  MOVLB  0
0199C:  GOTO   3BF0 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02388:  MOVLW  14
0238A:  MOVWF  5C
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
0238C:  MOVLW  45
0238E:  MOVLB  2
02390:  MOVWF  x6D
....................     header.TypeOfService    = IP_SERVICE; 
02392:  CLRF   x6E
....................     header.TotalLength      = sizeof(header) + len; 
02394:  MOVLW  14
02396:  ADDWF  x6B,W
02398:  MOVWF  x6F
0239A:  MOVLW  00
0239C:  ADDWFC x6C,W
0239E:  MOVWF  x70
....................     header.Identification   = ++_Identifier; 
023A0:  INCF   5A,F
023A2:  BTFSC  FD8.2
023A4:  INCF   5B,F
023A6:  MOVFF  5B,272
023AA:  MOVFF  5A,271
....................     header.FragmentInfo     = 0; 
023AE:  CLRF   x74
023B0:  CLRF   x73
....................     header.TimeToLive       = MY_IP_TTL; 
023B2:  MOVLW  64
023B4:  MOVWF  x75
....................     header.Protocol         = protocol; 
023B6:  MOVFF  26A,276
....................     header.HeaderChecksum   = 0; 
023BA:  CLRF   x78
023BC:  CLRF   x77
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
023BE:  MOVFF  1B,27C
023C2:  MOVFF  1A,27B
023C6:  MOVFF  19,27A
023CA:  MOVFF  18,279
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
023CE:  MOVLW  06
023D0:  ADDWF  x68,W
023D2:  MOVWF  FE9
023D4:  MOVLW  00
023D6:  ADDWFC x69,W
023D8:  MOVWF  FEA
023DA:  MOVFF  FEF,00
023DE:  MOVFF  FEC,01
023E2:  MOVFF  FEC,02
023E6:  MOVFF  FEC,03
023EA:  MOVFF  03,280
023EE:  MOVFF  02,27F
023F2:  MOVFF  01,27E
023F6:  MOVFF  00,27D
....................  
....................     SwapIPHeader(&header); 
023FA:  MOVLW  02
023FC:  MOVWF  x82
023FE:  MOVLW  6D
02400:  MOVWF  x81
02402:  MOVLB  0
02404:  CALL   17DC
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
02408:  MOVLB  2
0240A:  MOVFF  268,01
0240E:  MOVFF  269,03
02412:  MOVFF  268,281
02416:  MOVFF  269,282
0241A:  MOVLW  14
0241C:  ADDWF  x6B,W
0241E:  MOVWF  x83
02420:  MOVLW  00
02422:  ADDWFC x6C,W
02424:  MOVWF  x84
02426:  MOVFF  269,286
0242A:  MOVFF  268,285
0242E:  CLRF   x87
02430:  MOVWF  x89
02432:  MOVFF  283,288
02436:  MOVLB  0
02438:  CALL   1134
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
0243C:  MOVLW  02
0243E:  MOVLB  2
02440:  MOVWF  x82
02442:  MOVLW  6D
02444:  MOVFF  282,28D
02448:  MOVWF  x8C
0244A:  CLRF   x8F
0244C:  MOVLW  14
0244E:  MOVWF  x8E
02450:  MOVLB  0
02452:  CALL   10EA
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
02456:  MOVLB  2
02458:  CLRF   x82
0245A:  CLRF   x81
0245C:  CLRF   x84
0245E:  MOVLW  14
02460:  MOVWF  x83
02462:  MOVLB  0
02464:  RCALL  22B0
02466:  MOVFF  02,278
0246A:  MOVFF  01,277
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
0246E:  MOVFF  4F,281
02472:  MOVLB  2
02474:  CLRF   x83
02476:  MOVLW  0A
02478:  MOVWF  x82
0247A:  MOVLB  0
0247C:  CALL   1026
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02480:  MOVLW  02
02482:  MOVLB  2
02484:  MOVWF  x82
02486:  MOVLW  77
02488:  MOVFF  282,28D
0248C:  MOVWF  x8C
0248E:  CLRF   x8F
02490:  MOVLW  02
02492:  MOVWF  x8E
02494:  MOVLB  0
02496:  CALL   10EA
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
0249A:  MOVFF  4F,281
0249E:  MOVLB  2
024A0:  CLRF   x83
024A2:  MOVLW  14
024A4:  MOVWF  x82
024A6:  MOVLB  0
024A8:  CALL   1026
.................... #endif 
....................  
....................     return 0x0; 
024AC:  MOVLW  00
024AE:  MOVWF  01
024B0:  MOVWF  02
.................... } 
024B2:  RETLW  00
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
01C0E:  MOVF   5C,W
01C10:  MOVLB  2
01C12:  ADDWF  x10,W
01C14:  MOVWF  x12
01C16:  MOVLW  00
01C18:  ADDWFC x11,W
01C1A:  MOVWF  x13
01C1C:  MOVWF  x15
01C1E:  MOVFF  212,214
01C22:  MOVLB  0
01C24:  RCALL  1760
.................... } 
01C26:  RETLW  00
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
017DC:  MOVLW  02
017DE:  MOVLB  2
017E0:  ADDWF  x81,W
017E2:  MOVWF  01
017E4:  MOVLW  00
017E6:  ADDWFC x82,W
017E8:  MOVWF  03
017EA:  MOVFF  01,283
017EE:  MOVWF  x84
017F0:  MOVLW  02
017F2:  ADDWF  x81,W
017F4:  MOVWF  FE9
017F6:  MOVLW  00
017F8:  ADDWFC x82,W
017FA:  MOVWF  FEA
017FC:  MOVFF  FEC,286
01800:  MOVF   FED,F
01802:  MOVFF  FEF,285
01806:  MOVFF  286,288
0180A:  MOVFF  285,287
0180E:  MOVLB  0
01810:  CALL   0CF0
01814:  MOVFF  284,FEA
01818:  MOVFF  283,FE9
0181C:  MOVFF  02,FEC
01820:  MOVF   FED,F
01822:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
01826:  MOVLW  04
01828:  MOVLB  2
0182A:  ADDWF  x81,W
0182C:  MOVWF  01
0182E:  MOVLW  00
01830:  ADDWFC x82,W
01832:  MOVWF  03
01834:  MOVFF  01,283
01838:  MOVWF  x84
0183A:  MOVLW  04
0183C:  ADDWF  x81,W
0183E:  MOVWF  FE9
01840:  MOVLW  00
01842:  ADDWFC x82,W
01844:  MOVWF  FEA
01846:  MOVFF  FEC,286
0184A:  MOVF   FED,F
0184C:  MOVFF  FEF,285
01850:  MOVFF  286,288
01854:  MOVFF  285,287
01858:  MOVLB  0
0185A:  CALL   0CF0
0185E:  MOVFF  284,FEA
01862:  MOVFF  283,FE9
01866:  MOVFF  02,FEC
0186A:  MOVF   FED,F
0186C:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
01870:  MOVLW  0A
01872:  MOVLB  2
01874:  ADDWF  x81,W
01876:  MOVWF  01
01878:  MOVLW  00
0187A:  ADDWFC x82,W
0187C:  MOVWF  03
0187E:  MOVFF  01,283
01882:  MOVWF  x84
01884:  MOVLW  0A
01886:  ADDWF  x81,W
01888:  MOVWF  FE9
0188A:  MOVLW  00
0188C:  ADDWFC x82,W
0188E:  MOVWF  FEA
01890:  MOVFF  FEC,286
01894:  MOVF   FED,F
01896:  MOVFF  FEF,285
0189A:  MOVFF  286,288
0189E:  MOVFF  285,287
018A2:  MOVLB  0
018A4:  CALL   0CF0
018A8:  MOVFF  284,FEA
018AC:  MOVFF  283,FE9
018B0:  MOVFF  02,FEC
018B4:  MOVF   FED,F
018B6:  MOVFF  01,FEF
.................... } 
018BA:  RETLW  00
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               10 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
.................... 	TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
.................... 	WORD RemoteWindow; 
.................... 	 
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
00ADC:  MOVLB  1
00ADE:  CLRF   xDC
00AE0:  MOVF   xDC,W
00AE2:  SUBLW  04
00AE4:  BNC   0BB8
....................     { 
....................         ps = &TCB[s]; 
00AE6:  MOVF   xDC,W
00AE8:  MULLW  24
00AEA:  MOVF   FF3,W
00AEC:  CLRF   03
00AEE:  ADDLW  5F
00AF0:  MOVWF  01
00AF2:  MOVLW  00
00AF4:  ADDWFC 03,F
00AF6:  MOVFF  01,1DD
00AFA:  MOVFF  03,1DE
....................  
....................         ps->smState             = TCP_CLOSED; 
00AFE:  MOVFF  1DD,FE9
00B02:  MOVFF  1DE,FEA
00B06:  MOVLW  0A
00B08:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
00B0A:  MOVLW  23
00B0C:  ADDWF  xDD,W
00B0E:  MOVWF  FE9
00B10:  MOVLW  00
00B12:  ADDWFC xDE,W
00B14:  MOVWF  FEA
00B16:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
00B18:  MOVLW  23
00B1A:  ADDWF  xDD,W
00B1C:  MOVWF  FE9
00B1E:  MOVLW  00
00B20:  ADDWFC xDE,W
00B22:  MOVWF  FEA
00B24:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
00B26:  MOVLW  23
00B28:  ADDWF  xDD,W
00B2A:  MOVWF  FE9
00B2C:  MOVLW  00
00B2E:  ADDWFC xDE,W
00B30:  MOVWF  FEA
00B32:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
00B34:  MOVLW  23
00B36:  ADDWF  xDD,W
00B38:  MOVWF  FE9
00B3A:  MOVLW  00
00B3C:  ADDWFC xDE,W
00B3E:  MOVWF  FEA
00B40:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
00B42:  MOVLW  23
00B44:  ADDWF  xDD,W
00B46:  MOVWF  FE9
00B48:  MOVLW  00
00B4A:  ADDWFC xDE,W
00B4C:  MOVWF  FEA
00B4E:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
00B50:  MOVLW  0F
00B52:  ADDWF  xDD,W
00B54:  MOVWF  FE9
00B56:  MOVLW  00
00B58:  ADDWFC xDE,W
00B5A:  MOVWF  FEA
00B5C:  INCFSZ FEF,W
00B5E:  BRA    0B62
00B60:  BRA    0B8E
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
00B62:  MOVLW  0F
00B64:  ADDWF  xDD,W
00B66:  MOVWF  FE9
00B68:  MOVLW  00
00B6A:  ADDWFC xDE,W
00B6C:  MOVWF  FEA
00B6E:  MOVFF  FEF,1DF
00B72:  MOVFF  1DF,22F
00B76:  MOVLB  0
00B78:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
00B7C:  MOVLW  0F
00B7E:  MOVLB  1
00B80:  ADDWF  xDD,W
00B82:  MOVWF  FE9
00B84:  MOVLW  00
00B86:  ADDWFC xDE,W
00B88:  MOVWF  FEA
00B8A:  MOVLW  FF
00B8C:  MOVWF  FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
00B8E:  MOVLW  21
00B90:  ADDWF  xDD,W
00B92:  MOVWF  FE9
00B94:  MOVLW  00
00B96:  ADDWFC xDE,W
00B98:  MOVWF  FEA
00B9A:  CLRF   FEC
00B9C:  MOVF   FED,F
00B9E:  MOVLW  1E
00BA0:  MOVWF  FEF
....................       ps->TxCount            = 0; 
00BA2:  MOVLW  10
00BA4:  ADDWF  xDD,W
00BA6:  MOVWF  FE9
00BA8:  MOVLW  00
00BAA:  ADDWFC xDE,W
00BAC:  MOVWF  FEA
00BAE:  CLRF   FEC
00BB0:  MOVF   FED,F
00BB2:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
00BB4:  INCF   xDC,F
00BB6:  BRA    0AE0
....................     TCPInit_RandSeed+=get_timer0(); 
00BB8:  MOVF   FD6,W
00BBA:  ADDWF  x13,F
00BBC:  MOVF   FD7,W
00BBE:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
00BC0:  MOVF   FCE,W
00BC2:  ADDWF  x13,F
00BC4:  MOVF   FCF,W
00BC6:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
00BC8:  MOVF   FCC,W
00BCA:  ADDWF  x13,F
00BCC:  MOVLW  00
00BCE:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
00BD0:  MOVF   FB2,W
00BD2:  ADDWF  x13,F
00BD4:  MOVF   FB3,W
00BD6:  ADDWFC x14,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
00BD8:  CLRF   xE2
00BDA:  CLRF   xE1
00BDC:  MOVFF  114,1E0
00BE0:  MOVFF  113,1DF
00BE4:  MOVLB  0
00BE6:  BRA    09B0
....................     _NextPort=rand(); 
00BE8:  BRA    0A68
00BEA:  MOVFF  02,5E
00BEE:  MOVFF  01,5D
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
00BF2:  MOVLW  04
00BF4:  ADDWF  5E,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
00BF6:  MOVF   5E,W
00BF8:  SUBLW  12
00BFA:  BC    0C10
00BFC:  XORLW  FF
00BFE:  BNZ   0C06
00C00:  MOVF   5D,W
00C02:  SUBLW  87
00C04:  BC    0C10
00C06:  MOVLW  88
00C08:  SUBWF  5D,F
00C0A:  MOVLW  13
00C0C:  SUBWFB 5E,F
00C0E:  BRA    0BF6
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
00C10:  MOVF   5E,W
00C12:  SUBLW  03
00C14:  BNC   0C1A
00C16:  MOVLW  04
00C18:  ADDWF  5E,F
.................... } 
00C1A:  GOTO   0C2C (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
*
03D38:  MOVLB  1
03D3A:  CLRF   xE4
03D3C:  MOVF   xE4,W
03D3E:  SUBLW  04
03D40:  BNC   3E2A
....................    { 
....................       ps = &TCB[s]; 
03D42:  MOVF   xE4,W
03D44:  MULLW  24
03D46:  MOVF   FF3,W
03D48:  CLRF   03
03D4A:  ADDLW  5F
03D4C:  MOVWF  01
03D4E:  MOVLW  00
03D50:  ADDWFC 03,F
03D52:  MOVFF  01,1E5
03D56:  MOVFF  03,1E6
....................  
....................       if(ps->smState == TCP_CLOSED) 
03D5A:  MOVFF  1E5,FE9
03D5E:  MOVFF  1E6,FEA
03D62:  MOVF   FEF,W
03D64:  SUBLW  0A
03D66:  BNZ   3E26
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
03D68:  MOVFF  1E5,FE9
03D6C:  MOVFF  1E6,FEA
03D70:  CLRF   FEF
....................          ps->localPort           = port; 
03D72:  MOVLW  0B
03D74:  ADDWF  xE5,W
03D76:  MOVWF  FE9
03D78:  MOVLW  00
03D7A:  ADDWFC xE6,W
03D7C:  MOVWF  FEA
03D7E:  MOVFF  1E3,FEC
03D82:  MOVF   FED,F
03D84:  MOVFF  1E2,FEF
....................          ps->remotePort          = 0; 
03D88:  MOVLW  0D
03D8A:  ADDWF  xE5,W
03D8C:  MOVWF  FE9
03D8E:  MOVLW  00
03D90:  ADDWFC xE6,W
03D92:  MOVWF  FEA
03D94:  CLRF   FEC
03D96:  MOVF   FED,F
03D98:  CLRF   FEF
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
03D9A:  MOVLW  07
03D9C:  ADDWF  xE5,W
03D9E:  MOVWF  FE9
03DA0:  MOVLW  00
03DA2:  ADDWFC xE6,W
03DA4:  MOVWF  FEA
03DA6:  MOVF   FEE,F
03DA8:  MOVF   FEE,F
03DAA:  CLRF   FEC
03DAC:  MOVF   FED,F
03DAE:  CLRF   FEF
03DB0:  MOVF   FED,F
03DB2:  CLRF   FEF
03DB4:  MOVF   FED,F
03DB6:  CLRF   FEF
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
03DB8:  MOVLW  23
03DBA:  ADDWF  xE5,W
03DBC:  MOVWF  FE9
03DBE:  MOVLW  00
03DC0:  ADDWFC xE6,W
03DC2:  MOVWF  FEA
03DC4:  BSF    FEF.0
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
03DC6:  MOVLW  23
03DC8:  ADDWF  xE5,W
03DCA:  MOVWF  FE9
03DCC:  MOVLW  00
03DCE:  ADDWFC xE6,W
03DD0:  MOVWF  FEA
03DD2:  BCF    FEF.3
....................          if(ps->TxBuffer != INVALID_BUFFER) 
03DD4:  MOVLW  0F
03DD6:  ADDWF  xE5,W
03DD8:  MOVWF  FE9
03DDA:  MOVLW  00
03DDC:  ADDWFC xE6,W
03DDE:  MOVWF  FEA
03DE0:  INCFSZ FEF,W
03DE2:  BRA    3DE6
03DE4:  BRA    3E12
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
03DE6:  MOVLW  0F
03DE8:  ADDWF  xE5,W
03DEA:  MOVWF  FE9
03DEC:  MOVLW  00
03DEE:  ADDWFC xE6,W
03DF0:  MOVWF  FEA
03DF2:  MOVFF  FEF,1E7
03DF6:  MOVFF  1E7,22F
03DFA:  MOVLB  0
03DFC:  CALL   0004
....................             ps->TxBuffer        = INVALID_BUFFER; 
03E00:  MOVLW  0F
03E02:  MOVLB  1
03E04:  ADDWF  xE5,W
03E06:  MOVWF  FE9
03E08:  MOVLW  00
03E0A:  ADDWFC xE6,W
03E0C:  MOVWF  FEA
03E0E:  MOVLW  FF
03E10:  MOVWF  FEF
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
03E12:  MOVLW  23
03E14:  ADDWF  xE5,W
03E16:  MOVWF  FE9
03E18:  MOVLW  00
03E1A:  ADDWFC xE6,W
03E1C:  MOVWF  FEA
03E1E:  BSF    FEF.1
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
03E20:  MOVFF  1E4,01
03E24:  BRA    3E2E
....................       } 
....................    } 
03E26:  INCF   xE4,F
03E28:  BRA    3D3C
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
03E2A:  MOVLW  FE
03E2C:  MOVWF  01
.................... } 
03E2E:  MOVLB  0
03E30:  GOTO   48CA (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          lbFound = TRUE; 
....................          break; 
....................       } 
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
....................       return INVALID_SOCKET; 
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
....................    ps->SND_ACK = 0; 
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
....................  
....................    ps->smState = TCP_SYN_SENT; 
....................    ps->SND_SEQ++; 
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
03E34:  MOVLB  1
03E36:  MOVF   xE1,W
03E38:  MULLW  24
03E3A:  MOVF   FF3,W
03E3C:  CLRF   xE3
03E3E:  MOVWF  xE2
03E40:  MOVLW  5F
03E42:  ADDWF  xE2,W
03E44:  MOVWF  FE9
03E46:  MOVLW  00
03E48:  ADDWFC xE3,W
03E4A:  MOVWF  FEA
03E4C:  MOVF   FEF,W
03E4E:  SUBLW  03
03E50:  BZ    3E56
03E52:  MOVLW  00
03E54:  BRA    3E58
03E56:  MOVLW  01
03E58:  MOVWF  01
.................... } 
03E5A:  MOVLB  0
03E5C:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0472E:  MOVLB  1
04730:  MOVF   xE1,W
04732:  MULLW  24
04734:  MOVF   FF3,W
04736:  CLRF   03
04738:  ADDLW  5F
0473A:  MOVWF  01
0473C:  MOVLW  00
0473E:  ADDWFC 03,F
04740:  MOVFF  01,1E2
04744:  MOVFF  03,1E3
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
04748:  MOVFF  1E2,FE9
0474C:  MOVFF  1E3,FEA
04750:  MOVF   FEF,W
04752:  SUBLW  03
04754:  BZ    4774
04756:  MOVFF  1E2,FE9
0475A:  MOVFF  1E3,FEA
0475E:  MOVF   FEF,W
04760:  SUBLW  02
04762:  BZ    4774
....................    { 
....................       CloseSocket(ps); 
04764:  MOVFF  1E3,22D
04768:  MOVFF  1E2,22C
0476C:  MOVLB  0
0476E:  CALL   2068
....................       return; 
04772:  BRA    486A
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
04774:  MOVFF  1E1,1E4
04778:  MOVLB  0
0477A:  BRA    46DE
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
0477C:  MOVLW  01
0477E:  MOVLB  1
04780:  ADDWF  xE2,W
04782:  MOVWF  01
04784:  MOVLW  00
04786:  ADDWFC xE3,W
04788:  MOVWF  03
0478A:  MOVFF  01,1E4
0478E:  MOVWF  xE5
04790:  MOVLW  0B
04792:  ADDWF  xE2,W
04794:  MOVWF  FE9
04796:  MOVLW  00
04798:  ADDWFC xE3,W
0479A:  MOVWF  FEA
0479C:  MOVFF  FEC,1E7
047A0:  MOVF   FED,F
047A2:  MOVFF  FEF,1E6
047A6:  MOVLW  0D
047A8:  ADDWF  xE2,W
047AA:  MOVWF  FE9
047AC:  MOVLW  00
047AE:  ADDWFC xE3,W
047B0:  MOVWF  FEA
047B2:  MOVFF  FEC,1E9
047B6:  MOVF   FED,F
047B8:  MOVFF  FEF,1E8
047BC:  MOVLW  16
047BE:  ADDWF  xE2,W
047C0:  MOVWF  FE9
047C2:  MOVLW  00
047C4:  ADDWFC xE3,W
047C6:  MOVWF  FEA
047C8:  MOVFF  FEF,1EA
047CC:  MOVFF  FEC,1EB
047D0:  MOVFF  FEC,1EC
047D4:  MOVFF  FEC,1ED
047D8:  MOVLW  1A
047DA:  ADDWF  xE2,W
047DC:  MOVWF  FE9
047DE:  MOVLW  00
047E0:  ADDWFC xE3,W
047E2:  MOVWF  FEA
047E4:  MOVFF  FEF,1EE
047E8:  MOVFF  FEC,1EF
047EC:  MOVFF  FEC,1F0
047F0:  MOVFF  FEC,1F1
047F4:  MOVFF  03,231
047F8:  MOVFF  01,230
047FC:  MOVFF  1E7,233
04800:  MOVFF  1E6,232
04804:  MOVFF  1E9,235
04808:  MOVFF  1E8,234
0480C:  MOVFF  1ED,239
04810:  MOVFF  1EC,238
04814:  MOVFF  1EB,237
04818:  MOVFF  1EA,236
0481C:  MOVFF  1F1,23D
04820:  MOVFF  1F0,23C
04824:  MOVFF  1EF,23B
04828:  MOVFF  1EE,23A
0482C:  MOVLW  11
0482E:  MOVLB  2
04830:  MOVWF  x3E
04832:  MOVLW  FF
04834:  MOVWF  x3F
04836:  CLRF   x41
04838:  CLRF   x40
0483A:  MOVLB  0
0483C:  CALL   24B4
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
04840:  MOVLW  16
04842:  MOVLB  1
04844:  ADDWF  xE2,W
04846:  MOVWF  FE9
04848:  MOVLW  00
0484A:  ADDWFC xE3,W
0484C:  MOVWF  FEA
0484E:  MOVLW  01
04850:  ADDWF  FEE,F
04852:  BNZ   485E
04854:  INCF   FEE,F
04856:  BNZ   485E
04858:  INCF   FEE,F
0485A:  BNZ   485E
0485C:  INCF   FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
0485E:  MOVFF  1E2,FE9
04862:  MOVFF  1E3,FEA
04866:  MOVLW  04
04868:  MOVWF  FEF
0486A:  MOVLB  0
....................  
....................    return; 
.................... } 
0486C:  GOTO   4C9E (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
041F2:  MOVLB  2
041F4:  MOVF   x03,W
041F6:  MULLW  24
041F8:  MOVF   FF3,W
041FA:  CLRF   03
041FC:  ADDLW  5F
041FE:  MOVWF  01
04200:  MOVLW  00
04202:  ADDWFC 03,F
04204:  MOVFF  01,204
04208:  MOVFF  03,205
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
0420C:  MOVLW  0F
0420E:  ADDWF  x04,W
04210:  MOVWF  FE9
04212:  MOVLW  00
04214:  ADDWFC x05,W
04216:  MOVWF  FEA
04218:  INCFSZ FEF,W
0421A:  BRA    4222
....................       return FALSE; 
0421C:  MOVLW  00
0421E:  MOVWF  01
04220:  BRA    43B8
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
04222:  MOVLW  23
04224:  ADDWF  x04,W
04226:  MOVWF  FE9
04228:  MOVLW  00
0422A:  ADDWFC x05,W
0422C:  MOVWF  FEA
0422E:  MOVLW  00
04230:  BTFSC  FEF.1
04232:  MOVLW  01
04234:  ANDLW  01
04236:  BNZ   423E
....................       return FALSE; 
04238:  MOVLW  00
0423A:  MOVWF  01
0423C:  BRA    43B8
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
0423E:  MOVLW  01
04240:  ADDWF  x04,W
04242:  MOVWF  01
04244:  MOVLW  00
04246:  ADDWFC x05,W
04248:  MOVWF  03
0424A:  MOVFF  01,206
0424E:  MOVWF  x07
04250:  MOVLW  0B
04252:  ADDWF  x04,W
04254:  MOVWF  FE9
04256:  MOVLW  00
04258:  ADDWFC x05,W
0425A:  MOVWF  FEA
0425C:  MOVFF  FEC,209
04260:  MOVF   FED,F
04262:  MOVFF  FEF,208
04266:  MOVLW  0D
04268:  ADDWF  x04,W
0426A:  MOVWF  FE9
0426C:  MOVLW  00
0426E:  ADDWFC x05,W
04270:  MOVWF  FEA
04272:  MOVFF  FEC,20B
04276:  MOVF   FED,F
04278:  MOVFF  FEF,20A
0427C:  MOVLW  16
0427E:  ADDWF  x04,W
04280:  MOVWF  FE9
04282:  MOVLW  00
04284:  ADDWFC x05,W
04286:  MOVWF  FEA
04288:  MOVFF  FEF,20C
0428C:  MOVFF  FEC,20D
04290:  MOVFF  FEC,20E
04294:  MOVFF  FEC,20F
04298:  MOVLW  1A
0429A:  ADDWF  x04,W
0429C:  MOVWF  FE9
0429E:  MOVLW  00
042A0:  ADDWFC x05,W
042A2:  MOVWF  FEA
042A4:  MOVFF  FEF,210
042A8:  MOVFF  FEC,211
042AC:  MOVFF  FEC,212
042B0:  MOVFF  FEC,213
042B4:  MOVLW  0F
042B6:  ADDWF  x04,W
042B8:  MOVWF  FE9
042BA:  MOVLW  00
042BC:  ADDWFC x05,W
042BE:  MOVWF  FEA
042C0:  MOVFF  FEF,214
042C4:  MOVLW  10
042C6:  ADDWF  x04,W
042C8:  MOVWF  FE9
042CA:  MOVLW  00
042CC:  ADDWFC x05,W
042CE:  MOVWF  FEA
042D0:  MOVFF  FEC,216
042D4:  MOVF   FED,F
042D6:  MOVFF  FEF,215
042DA:  MOVFF  03,231
042DE:  MOVFF  01,230
042E2:  MOVFF  209,233
042E6:  MOVFF  208,232
042EA:  MOVFF  20B,235
042EE:  MOVFF  20A,234
042F2:  MOVFF  20F,239
042F6:  MOVFF  20E,238
042FA:  MOVFF  20D,237
042FE:  MOVFF  20C,236
04302:  MOVFF  213,23D
04306:  MOVFF  212,23C
0430A:  MOVFF  211,23B
0430E:  MOVFF  210,23A
04312:  MOVLW  18
04314:  MOVWF  x3E
04316:  MOVFF  214,23F
0431A:  MOVFF  216,241
0431E:  MOVFF  215,240
04322:  MOVLB  0
04324:  CALL   24B4
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
04328:  MOVLW  16
0432A:  MOVLB  2
0432C:  ADDWF  x04,W
0432E:  MOVWF  01
04330:  MOVLW  00
04332:  ADDWFC x05,W
04334:  MOVWF  03
04336:  MOVFF  01,206
0433A:  MOVWF  x07
0433C:  MOVWF  FEA
0433E:  MOVFF  01,FE9
04342:  MOVFF  FEF,208
04346:  MOVFF  FEC,209
0434A:  MOVFF  FEC,20A
0434E:  MOVFF  FEC,20B
04352:  MOVLW  10
04354:  ADDWF  x04,W
04356:  MOVWF  FE9
04358:  MOVLW  00
0435A:  ADDWFC x05,W
0435C:  MOVWF  FEA
0435E:  MOVFF  FEC,03
04362:  MOVF   FED,F
04364:  MOVFF  FEF,00
04368:  MOVFF  03,01
0436C:  CLRF   02
0436E:  CLRF   03
04370:  MOVF   x08,W
04372:  ADDWF  00,F
04374:  MOVF   x09,W
04376:  ADDWFC 01,F
04378:  MOVF   x0A,W
0437A:  ADDWFC 02,F
0437C:  MOVF   x0B,W
0437E:  ADDWFC 03,F
04380:  MOVFF  207,FEA
04384:  MOVFF  206,FE9
04388:  MOVFF  00,FEF
0438C:  MOVFF  01,FEC
04390:  MOVFF  02,FEC
04394:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
04398:  MOVLW  23
0439A:  ADDWF  x04,W
0439C:  MOVWF  FE9
0439E:  MOVLW  00
043A0:  ADDWFC x05,W
043A2:  MOVWF  FEA
043A4:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
043A6:  MOVLW  23
043A8:  ADDWF  x04,W
043AA:  MOVWF  FE9
043AC:  MOVLW  00
043AE:  ADDWFC x05,W
043B0:  MOVWF  FEA
043B2:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
043B4:  MOVLW  01
043B6:  MOVWF  01
.................... } 
043B8:  MOVLB  0
043BA:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
03FA2:  MOVLB  2
03FA4:  MOVF   x08,W
03FA6:  MULLW  24
03FA8:  MOVF   FF3,W
03FAA:  CLRF   x0A
03FAC:  MOVWF  x09
03FAE:  MOVLW  14
03FB0:  ADDWF  x09,W
03FB2:  MOVWF  01
03FB4:  MOVLW  00
03FB6:  ADDWFC x0A,W
03FB8:  MOVWF  03
03FBA:  MOVF   01,W
03FBC:  ADDLW  5F
03FBE:  MOVWF  FE9
03FC0:  MOVLW  00
03FC2:  ADDWFC 03,W
03FC4:  MOVWF  FEA
03FC6:  MOVFF  FEC,20C
03FCA:  MOVF   FED,F
03FCC:  MOVFF  FEF,20B
03FD0:  MOVF   x0B,F
03FD2:  BNZ   3FDE
03FD4:  MOVF   x0C,F
03FD6:  BNZ   3FDE
....................       return FALSE; 
03FD8:  MOVLW  00
03FDA:  MOVWF  01
03FDC:  BRA    4040
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
03FDE:  MOVF   x08,W
03FE0:  MULLW  24
03FE2:  MOVF   FF3,W
03FE4:  CLRF   x0A
03FE6:  MOVWF  x09
03FE8:  MOVLW  0F
03FEA:  ADDWF  x09,W
03FEC:  MOVWF  01
03FEE:  MOVLW  00
03FF0:  ADDWFC x0A,W
03FF2:  MOVWF  03
03FF4:  MOVF   01,W
03FF6:  ADDLW  5F
03FF8:  MOVWF  FE9
03FFA:  MOVLW  00
03FFC:  ADDWFC 03,W
03FFE:  MOVWF  FEA
04000:  INCFSZ FEF,W
04002:  BRA    4014
....................       return IPIsTxReady(FALSE); 
04004:  CLRF   x68
04006:  MOVLB  0
04008:  CALL   216C
0400C:  MOVF   01,W
0400E:  MOVLB  2
04010:  BRA    4040
....................    else 
04012:  BRA    4040
....................       return TCB[s].Flags.bIsPutReady; 
04014:  MOVF   x08,W
04016:  MULLW  24
04018:  MOVF   FF3,W
0401A:  CLRF   x0A
0401C:  MOVWF  x09
0401E:  MOVLW  23
04020:  ADDWF  x09,W
04022:  MOVWF  x0B
04024:  MOVLW  00
04026:  ADDWFC x0A,W
04028:  MOVWF  x0C
0402A:  MOVLW  5F
0402C:  ADDWF  x0B,W
0402E:  MOVWF  FE9
04030:  MOVLW  00
04032:  ADDWFC x0C,W
04034:  MOVWF  FEA
04036:  MOVLW  00
04038:  BTFSC  FEF.1
0403A:  MOVLW  01
0403C:  MOVWF  01
0403E:  BRA    4040
.................... } 
04040:  MOVLB  0
04042:  RETLW  00
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
*
040F4:  MOVFF  203,208
040F8:  RCALL  3FA2
040FA:  MOVF   01,F
040FC:  BNZ   4106
....................       return(0); 
040FE:  MOVLW  00
04100:  MOVWF  01
04102:  MOVWF  02
04104:  BRA    41EC
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04106:  MOVLB  2
04108:  MOVF   x03,W
0410A:  MULLW  24
0410C:  MOVF   FF3,W
0410E:  CLRF   x09
04110:  MOVWF  x08
04112:  MOVLW  0F
04114:  ADDWF  x08,W
04116:  MOVWF  01
04118:  MOVLW  00
0411A:  ADDWFC x09,W
0411C:  MOVWF  03
0411E:  MOVF   01,W
04120:  ADDLW  5F
04122:  MOVWF  FE9
04124:  MOVLW  00
04126:  ADDWFC 03,W
04128:  MOVWF  FEA
0412A:  INCFSZ FEF,W
0412C:  BRA    4134
....................       txCount = 0; 
0412E:  CLRF   x05
04130:  CLRF   x04
....................    else 
04132:  BRA    4164
....................       txCount = TCB[s].TxCount; 
04134:  MOVF   x03,W
04136:  MULLW  24
04138:  MOVF   FF3,W
0413A:  CLRF   x09
0413C:  MOVWF  x08
0413E:  MOVLW  10
04140:  ADDWF  x08,W
04142:  MOVWF  01
04144:  MOVLW  00
04146:  ADDWFC x09,W
04148:  MOVWF  03
0414A:  MOVF   01,W
0414C:  ADDLW  5F
0414E:  MOVWF  FE9
04150:  MOVLW  00
04152:  ADDWFC 03,W
04154:  MOVWF  FEA
04156:  MOVFF  FEC,03
0415A:  MOVF   FED,F
0415C:  MOVFF  FEF,204
04160:  MOVFF  03,205
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
04164:  MOVLW  CA
04166:  BSF    FD8.0
04168:  SUBFWB x04,W
0416A:  MOVWF  x06
0416C:  MOVLW  03
0416E:  SUBFWB x05,W
04170:  MOVWF  x07
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
04172:  MOVF   x03,W
04174:  MULLW  24
04176:  MOVF   FF3,W
04178:  CLRF   x09
0417A:  MOVWF  x08
0417C:  MOVLW  14
0417E:  ADDWF  x08,W
04180:  MOVWF  01
04182:  MOVLW  00
04184:  ADDWFC x09,W
04186:  MOVWF  03
04188:  MOVF   01,W
0418A:  ADDLW  5F
0418C:  MOVWF  FE9
0418E:  MOVLW  00
04190:  ADDWFC 03,W
04192:  MOVWF  FEA
04194:  MOVFF  FEC,03
04198:  MOVF   FED,F
0419A:  MOVFF  FEF,01
0419E:  MOVF   03,W
041A0:  SUBWF  x07,W
041A2:  BNC   41D8
041A4:  BNZ   41AC
041A6:  MOVF   x06,W
041A8:  SUBWF  01,W
041AA:  BC    41D8
041AC:  MOVF   x03,W
041AE:  MULLW  24
041B0:  MOVF   FF3,W
041B2:  CLRF   x0B
041B4:  MOVWF  x0A
041B6:  MOVLW  14
041B8:  ADDWF  x0A,W
041BA:  MOVWF  01
041BC:  MOVLW  00
041BE:  ADDWFC x0B,W
041C0:  MOVWF  03
041C2:  MOVF   01,W
041C4:  ADDLW  5F
041C6:  MOVWF  FE9
041C8:  MOVLW  00
041CA:  ADDWFC 03,W
041CC:  MOVWF  FEA
041CE:  MOVFF  FEC,03
041D2:  MOVF   FED,F
041D4:  MOVF   FEF,W
041D6:  BRA    41DE
041D8:  MOVFF  207,03
041DC:  MOVF   x06,W
041DE:  MOVWF  x06
041E0:  MOVFF  03,207
....................  
....................    return(txAvail); 
041E4:  MOVFF  206,01
041E8:  MOVFF  207,02
041EC:  MOVLB  0
.................... } 
041EE:  GOTO   449A (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
043BC:  MOVLB  1
043BE:  MOVF   xFA,W
043C0:  MULLW  24
043C2:  MOVF   FF3,W
043C4:  CLRF   03
043C6:  ADDLW  5F
043C8:  MOVWF  01
043CA:  MOVLW  00
043CC:  ADDWFC 03,F
043CE:  MOVFF  01,1FF
043D2:  MOVFF  03,200
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
043D6:  MOVLW  14
043D8:  ADDWF  xFF,W
043DA:  MOVWF  FE9
043DC:  MOVLW  00
043DE:  MOVLB  2
043E0:  ADDWFC x00,W
043E2:  MOVWF  FEA
043E4:  MOVFF  FEC,204
043E8:  MOVF   FED,F
043EA:  MOVFF  FEF,203
043EE:  MOVF   x03,F
043F0:  BNZ   43FE
043F2:  MOVF   x04,F
043F4:  BNZ   43FE
....................       return 0; 
043F6:  MOVLW  00
043F8:  MOVWF  01
043FA:  MOVWF  02
043FC:  BRA    456E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
043FE:  MOVLW  0F
04400:  MOVLB  1
04402:  ADDWF  xFF,W
04404:  MOVWF  FE9
04406:  MOVLW  00
04408:  MOVLB  2
0440A:  ADDWFC x00,W
0440C:  MOVWF  FEA
0440E:  INCFSZ FEF,W
04410:  BRA    4492
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
04412:  MOVLW  0F
04414:  MOVLB  1
04416:  ADDWF  xFF,W
04418:  MOVWF  01
0441A:  MOVLW  00
0441C:  MOVLB  2
0441E:  ADDWFC x00,W
04420:  MOVWF  03
04422:  MOVFF  01,203
04426:  MOVWF  x04
04428:  CLRF   x68
0442A:  MOVLB  0
0442C:  CALL   0FFC
04430:  MOVFF  204,FEA
04434:  MOVFF  203,FE9
04438:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
0443C:  MOVLW  0F
0443E:  MOVLB  1
04440:  ADDWF  xFF,W
04442:  MOVWF  FE9
04444:  MOVLW  00
04446:  MOVLB  2
04448:  ADDWFC x00,W
0444A:  MOVWF  FEA
0444C:  INCFSZ FEF,W
0444E:  BRA    4458
....................          return 0; 
04450:  MOVLW  00
04452:  MOVWF  01
04454:  MOVWF  02
04456:  BRA    456E
....................  
....................       ps->TxCount = 0; 
04458:  MOVLW  10
0445A:  MOVLB  1
0445C:  ADDWF  xFF,W
0445E:  MOVWF  FE9
04460:  MOVLW  00
04462:  MOVLB  2
04464:  ADDWFC x00,W
04466:  MOVWF  FEA
04468:  CLRF   FEC
0446A:  MOVF   FED,F
0446C:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
0446E:  MOVLW  0F
04470:  MOVLB  1
04472:  ADDWF  xFF,W
04474:  MOVWF  FE9
04476:  MOVLW  00
04478:  MOVLB  2
0447A:  ADDWFC x00,W
0447C:  MOVWF  FEA
0447E:  MOVFF  FEF,203
04482:  MOVFF  203,281
04486:  CLRF   x83
04488:  MOVLW  28
0448A:  MOVWF  x82
0448C:  MOVLB  0
0448E:  CALL   1026
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
04492:  MOVFF  1FA,203
04496:  MOVLB  0
04498:  BRA    40F4
0449A:  MOVFF  02,202
0449E:  MOVFF  01,201
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
044A2:  MOVLW  23
044A4:  MOVLB  1
044A6:  ADDWF  xFF,W
044A8:  MOVWF  FE9
044AA:  MOVLW  00
044AC:  MOVLB  2
044AE:  ADDWFC x00,W
044B0:  MOVWF  FEA
044B2:  BSF    FEF.4
....................  
....................    while (n--) 
....................    { 
044B4:  MOVFF  202,03
044B8:  MOVF   x01,W
044BA:  BTFSC  FD8.2
044BC:  DECF   x02,F
044BE:  DECF   x01,F
044C0:  IORWF  03,W
044C2:  BZ    4530
....................       MACPut(*ptr++); 
044C4:  MOVLB  1
044C6:  MOVFF  1FC,03
044CA:  MOVF   xFB,W
044CC:  INCF   xFB,F
044CE:  BTFSC  FD8.2
044D0:  INCF   xFC,F
044D2:  MOVWF  FE9
044D4:  MOVFF  03,FEA
044D8:  MOVFF  FEF,203
044DC:  MOVFF  203,28B
044E0:  MOVLB  0
044E2:  CALL   10D0
....................       ps->RemoteWindow -= 1; 
044E6:  MOVLW  14
044E8:  MOVLB  1
044EA:  ADDWF  xFF,W
044EC:  MOVWF  FE9
044EE:  MOVLW  00
044F0:  MOVLB  2
044F2:  ADDWFC x00,W
044F4:  MOVWF  FEA
044F6:  MOVLW  01
044F8:  SUBWF  FEF,W
044FA:  MOVWF  00
044FC:  MOVLW  00
044FE:  SUBWFB FEC,W
04500:  MOVWF  03
04502:  MOVF   00,W
04504:  MOVF   FED,F
04506:  MOVWF  FEF
04508:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
0450C:  MOVLW  10
0450E:  MOVLB  1
04510:  ADDWF  xFF,W
04512:  MOVWF  FE9
04514:  MOVLW  00
04516:  MOVLB  2
04518:  ADDWFC x00,W
0451A:  MOVWF  FEA
0451C:  MOVLW  01
0451E:  ADDWF  FEF,W
04520:  MOVWF  01
04522:  MOVLW  00
04524:  ADDWFC FEC,W
04526:  MOVF   FED,F
04528:  MOVFF  01,FEF
0452C:  MOVWF  FEC
....................    } 
0452E:  BRA    44B4
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
04530:  MOVLW  10
04532:  MOVLB  1
04534:  ADDWF  xFF,W
04536:  MOVWF  FE9
04538:  MOVLW  00
0453A:  MOVLB  2
0453C:  ADDWFC x00,W
0453E:  MOVWF  FEA
04540:  MOVFF  FEC,204
04544:  MOVF   FED,F
04546:  MOVFF  FEF,203
0454A:  MOVF   x04,W
0454C:  SUBLW  02
0454E:  BC    4562
04550:  XORLW  FF
04552:  BNZ   455A
04554:  MOVF   x03,W
04556:  SUBLW  C9
04558:  BC    4562
....................       TCPFlush(s); 
0455A:  MOVFF  1FA,203
0455E:  MOVLB  0
04560:  RCALL  41F2
....................  
....................    return(len); 
04562:  MOVLB  1
04564:  MOVFF  1FD,01
04568:  MOVFF  1FE,02
0456C:  MOVLB  2
.................... } 
0456E:  MOVLB  0
04570:  GOTO   46B8 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
046DE:  MOVLB  1
046E0:  MOVF   xE4,W
046E2:  MULLW  24
046E4:  MOVF   FF3,W
046E6:  CLRF   03
046E8:  ADDLW  5F
046EA:  MOVWF  01
046EC:  MOVLW  00
046EE:  ADDWFC 03,F
046F0:  MOVFF  01,1E5
046F4:  MOVFF  03,1E6
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
046F8:  MOVLW  23
046FA:  ADDWF  xE5,W
046FC:  MOVWF  FE9
046FE:  MOVLW  00
04700:  ADDWFC xE6,W
04702:  MOVWF  FEA
04704:  BTFSC  FEF.3
04706:  BRA    470E
....................         return FALSE; 
04708:  MOVLW  00
0470A:  MOVWF  01
0470C:  BRA    4728
....................  
....................     MACDiscardRx(); 
0470E:  MOVLB  0
04710:  CALL   0C30
....................     ps->Flags.bIsGetReady = FALSE; 
04714:  MOVLW  23
04716:  MOVLB  1
04718:  ADDWF  xE5,W
0471A:  MOVWF  FE9
0471C:  MOVLW  00
0471E:  ADDWFC xE6,W
04720:  MOVWF  FEA
04722:  BCF    FEF.3
....................  
....................     return TRUE; 
04724:  MOVLW  01
04726:  MOVWF  01
.................... } 
04728:  MOVLB  0
0472A:  GOTO   477C (RETURN)
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
03E90:  MOVLB  1
03E92:  MOVF   xF9,W
03E94:  MULLW  24
03E96:  MOVF   FF3,W
03E98:  CLRF   03
03E9A:  ADDLW  5F
03E9C:  MOVWF  01
03E9E:  MOVLW  00
03EA0:  ADDWFC 03,F
03EA2:  MOVFF  01,1FC
03EA6:  MOVFF  03,1FD
....................  
....................     if ( ps->Flags.bIsGetReady ) 
03EAA:  MOVLW  23
03EAC:  ADDWF  xFC,W
03EAE:  MOVWF  FE9
03EB0:  MOVLW  00
03EB2:  ADDWFC xFD,W
03EB4:  MOVWF  FEA
03EB6:  BTFSS  FEF.3
03EB8:  BRA    3F5E
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
03EBA:  MOVLW  23
03EBC:  ADDWF  xFC,W
03EBE:  MOVWF  FE9
03EC0:  MOVLW  00
03EC2:  ADDWFC xFD,W
03EC4:  MOVWF  FEA
03EC6:  BTFSS  FEF.2
03EC8:  BRA    3EE8
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
03ECA:  MOVLB  2
03ECC:  CLRF   x11
03ECE:  MOVLW  14
03ED0:  MOVWF  x10
03ED2:  MOVLB  0
03ED4:  CALL   1C0E
....................  
....................             ps->Flags.bFirstRead = FALSE; 
03ED8:  MOVLW  23
03EDA:  MOVLB  1
03EDC:  ADDWF  xFC,W
03EDE:  MOVWF  FE9
03EE0:  MOVLW  00
03EE2:  ADDWFC xFD,W
03EE4:  MOVWF  FEA
03EE6:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
03EE8:  MOVLW  12
03EEA:  ADDWF  xFC,W
03EEC:  MOVWF  FE9
03EEE:  MOVLW  00
03EF0:  ADDWFC xFD,W
03EF2:  MOVWF  FEA
03EF4:  MOVFF  FEC,1FF
03EF8:  MOVF   FED,F
03EFA:  MOVFF  FEF,1FE
03EFE:  MOVF   xFE,F
03F00:  BNZ   3F22
03F02:  MOVF   xFF,F
03F04:  BNZ   3F22
....................         { 
....................             MACDiscardRx(); 
03F06:  MOVLB  0
03F08:  CALL   0C30
....................             ps->Flags.bIsGetReady = FALSE; 
03F0C:  MOVLW  23
03F0E:  MOVLB  1
03F10:  ADDWF  xFC,W
03F12:  MOVWF  FE9
03F14:  MOVLW  00
03F16:  ADDWFC xFD,W
03F18:  MOVWF  FEA
03F1A:  BCF    FEF.3
....................             return FALSE; 
03F1C:  MOVLW  00
03F1E:  MOVWF  01
03F20:  BRA    3F62
....................         } 
....................  
....................          ps->RxCount--; 
03F22:  MOVLW  12
03F24:  ADDWF  xFC,W
03F26:  MOVWF  FE9
03F28:  MOVLW  00
03F2A:  ADDWFC xFD,W
03F2C:  MOVWF  FEA
03F2E:  MOVLW  FF
03F30:  ADDWF  FEF,F
03F32:  BC    3F38
03F34:  MOVF   FEE,F
03F36:  DECF   FED,F
....................          *data = MACGet(); 
03F38:  MOVFF  1FB,03
03F3C:  MOVFF  1FA,1FE
03F40:  MOVFF  1FB,1FF
03F44:  MOVLB  0
03F46:  CALL   1A8E
03F4A:  MOVFF  1FF,FEA
03F4E:  MOVFF  1FE,FE9
03F52:  MOVFF  01,FEF
....................         return TRUE; 
03F56:  MOVLW  01
03F58:  MOVWF  01
03F5A:  MOVLB  1
03F5C:  BRA    3F62
....................     } 
....................     return FALSE; 
03F5E:  MOVLW  00
03F60:  MOVWF  01
.................... } 
03F62:  MOVLB  0
03F64:  GOTO   4596 (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
03E5E:  MOVLB  1
03E60:  MOVF   xF9,W
03E62:  MULLW  24
03E64:  MOVF   FF3,W
03E66:  CLRF   xFB
03E68:  MOVWF  xFA
03E6A:  MOVLW  23
03E6C:  ADDWF  xFA,W
03E6E:  MOVWF  xFC
03E70:  MOVLW  00
03E72:  ADDWFC xFB,W
03E74:  MOVWF  xFD
03E76:  MOVLW  5F
03E78:  ADDWF  xFC,W
03E7A:  MOVWF  FE9
03E7C:  MOVLW  00
03E7E:  ADDWFC xFD,W
03E80:  MOVWF  FEA
03E82:  MOVLW  00
03E84:  BTFSC  FEF.3
03E86:  MOVLW  01
03E88:  MOVWF  01
.................... } 
03E8A:  MOVLB  0
03E8C:  GOTO   4580 (RETURN)
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
03680:  MOVLB  1
03682:  CLRF   xED
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
03684:  CLRF   xE2
03686:  MOVF   xE2,W
03688:  SUBLW  04
0368A:  BTFSS  FD8.0
0368C:  BRA    3B20
....................    { 
....................       ps = &TCB[s]; 
0368E:  MOVF   xE2,W
03690:  MULLW  24
03692:  MOVF   FF3,W
03694:  CLRF   03
03696:  ADDLW  5F
03698:  MOVWF  01
0369A:  MOVLW  00
0369C:  ADDWFC 03,F
0369E:  MOVFF  01,1E7
036A2:  MOVFF  03,1E8
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
036A6:  MOVLW  23
036A8:  ADDWF  xE7,W
036AA:  MOVWF  FE9
036AC:  MOVLW  00
036AE:  ADDWFC xE8,W
036B0:  MOVWF  FEA
036B2:  BTFSC  FEF.3
036B4:  BRA    36C6
036B6:  MOVLW  23
036B8:  ADDWF  xE7,W
036BA:  MOVWF  FE9
036BC:  MOVLW  00
036BE:  ADDWFC xE8,W
036C0:  MOVWF  FEA
036C2:  BTFSS  FEF.4
036C4:  BRA    36C8
....................          continue; 
036C6:  BRA    3B1C
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
036C8:  MOVFF  1E7,FE9
036CC:  MOVFF  1E8,FEA
036D0:  MOVF   FEF,W
036D2:  SUBLW  0A
036D4:  BZ    36FA
036D6:  MOVFF  1E7,FE9
036DA:  MOVFF  1E8,FEA
036DE:  MOVF   FEF,F
036E0:  BNZ   36FC
036E2:  MOVLW  23
036E4:  ADDWF  xE7,W
036E6:  MOVWF  FE9
036E8:  MOVLW  00
036EA:  ADDWFC xE8,W
036EC:  MOVWF  FEA
036EE:  MOVLW  00
036F0:  BTFSC  FEF.0
036F2:  MOVLW  01
036F4:  ANDLW  01
036F6:  SUBLW  01
036F8:  BNZ   36FC
....................          continue; 
036FA:  BRA    3B1C
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
036FC:  MOVFF  1E7,FE9
03700:  MOVFF  1E8,FEA
03704:  MOVF   FEF,W
03706:  SUBLW  03
03708:  BNZ   3724
0370A:  MOVLW  23
0370C:  ADDWF  xE7,W
0370E:  MOVWF  FE9
03710:  MOVLW  00
03712:  ADDWFC xE8,W
03714:  MOVWF  FEA
03716:  MOVLW  00
03718:  BTFSC  FEF.0
0371A:  MOVLW  01
0371C:  ANDLW  01
0371E:  SUBLW  01
03720:  BNZ   3724
....................          continue; 
03722:  BRA    3B1C
....................  
....................  
....................       tick = TickGet(); 
03724:  MOVLB  0
03726:  CALL   204E
0372A:  MOVFF  02,1E6
0372E:  MOVFF  01,1E5
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
03732:  MOVLW  1F
03734:  MOVLB  1
03736:  ADDWF  xE7,W
03738:  MOVWF  FE9
0373A:  MOVLW  00
0373C:  ADDWFC xE8,W
0373E:  MOVWF  FEA
03740:  MOVFF  FEC,03
03744:  MOVF   FED,F
03746:  MOVFF  FEF,01
0374A:  MOVF   xE6,W
0374C:  SUBWF  03,W
0374E:  BNC   3758
03750:  BNZ   375C
03752:  MOVF   01,W
03754:  SUBWF  xE5,W
03756:  BNC   375C
03758:  MOVLW  00
0375A:  BRA    375E
0375C:  MOVLW  01
0375E:  CLRF   03
03760:  IORWF  03,W
03762:  BZ    379E
03764:  MOVLW  1F
03766:  ADDWF  xE7,W
03768:  MOVWF  FE9
0376A:  MOVLW  00
0376C:  ADDWFC xE8,W
0376E:  MOVWF  FEA
03770:  MOVFF  FEC,03
03774:  MOVF   FED,F
03776:  MOVF   FEF,W
03778:  SUBLW  FF
0377A:  MOVWF  xEE
0377C:  MOVLW  FF
0377E:  SUBFWB 03,W
03780:  MOVWF  xEF
03782:  MOVF   xE5,W
03784:  ADDWF  xEE,W
03786:  MOVWF  xF0
03788:  MOVF   xE6,W
0378A:  ADDWFC xEF,W
0378C:  MOVWF  xF1
0378E:  MOVLW  01
03790:  ADDWF  xF0,W
03792:  MOVWF  01
03794:  MOVLW  00
03796:  ADDWFC xF1,W
03798:  MOVWF  03
0379A:  MOVF   01,W
0379C:  BRA    37BE
0379E:  MOVLW  1F
037A0:  ADDWF  xE7,W
037A2:  MOVWF  FE9
037A4:  MOVLW  00
037A6:  ADDWFC xE8,W
037A8:  MOVWF  FEA
037AA:  MOVFF  FEC,03
037AE:  MOVF   FED,F
037B0:  MOVF   FEF,W
037B2:  SUBWF  xE5,W
037B4:  MOVWF  00
037B6:  MOVF   03,W
037B8:  SUBWFB xE6,W
037BA:  MOVWF  03
037BC:  MOVF   00,W
037BE:  MOVWF  xE3
037C0:  MOVFF  03,1E4
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
037C4:  MOVLW  21
037C6:  ADDWF  xE7,W
037C8:  MOVWF  FE9
037CA:  MOVLW  00
037CC:  ADDWFC xE8,W
037CE:  MOVWF  FEA
037D0:  MOVFF  FEC,03
037D4:  MOVF   FED,F
037D6:  MOVFF  FEF,01
037DA:  MOVF   xE4,W
037DC:  SUBWF  03,W
037DE:  BNC   37EA
037E0:  BNZ   37E8
037E2:  MOVF   xE3,W
037E4:  SUBWF  01,W
037E6:  BNC   37EA
....................          continue; 
037E8:  BRA    3B1C
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
037EA:  MOVLW  01
037EC:  MOVLB  2
037EE:  MOVWF  x68
037F0:  MOVLB  0
037F2:  CALL   216C
037F6:  MOVF   01,F
037F8:  BNZ   37FC
....................          return; 
037FA:  BRA    3B20
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
037FC:  MOVLW  1F
037FE:  MOVLB  1
03800:  ADDWF  xE7,W
03802:  MOVWF  01
03804:  MOVLW  00
03806:  ADDWFC xE8,W
03808:  MOVWF  03
0380A:  MOVFF  01,1EE
0380E:  MOVWF  xEF
03810:  MOVLB  0
03812:  CALL   204E
03816:  MOVFF  1EF,FEA
0381A:  MOVFF  1EE,FE9
0381E:  MOVFF  02,FEC
03822:  MOVF   FED,F
03824:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
03828:  MOVLW  21
0382A:  MOVLB  1
0382C:  ADDWF  xE7,W
0382E:  MOVWF  FE9
03830:  MOVLW  00
03832:  ADDWFC xE8,W
03834:  MOVWF  FEA
03836:  BCF    FD8.0
03838:  RLCF   FEF,W
0383A:  MOVWF  02
0383C:  RLCF   FEC,W
0383E:  MOVWF  03
03840:  MOVF   02,W
03842:  MOVF   FED,F
03844:  MOVWF  FEF
03846:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
0384A:  MOVLW  1E
0384C:  ADDWF  xE7,W
0384E:  MOVWF  FE9
03850:  MOVLW  00
03852:  ADDWFC xE8,W
03854:  MOVWF  FEA
03856:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
....................       { 
03858:  MOVFF  1E7,FE9
0385C:  MOVFF  1E8,FEA
03860:  MOVLW  01
03862:  SUBWF  FEF,W
03864:  ADDLW  F7
03866:  BTFSC  FD8.0
03868:  BRA    39FA
0386A:  ADDLW  09
0386C:  MOVLB  0
0386E:  GOTO   3B26
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
03872:  MOVLW  02
03874:  MOVLB  1
03876:  MOVWF  xED
....................          break; 
03878:  BRA    39FA
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0387A:  MOVLW  1E
0387C:  MOVLB  1
0387E:  ADDWF  xE7,W
03880:  MOVWF  FE9
03882:  MOVLW  00
03884:  ADDWFC xE8,W
03886:  MOVWF  FEA
03888:  MOVF   FEF,W
0388A:  SUBLW  03
0388C:  BNC   3894
....................          { 
....................             flags = SYN | ACK; 
0388E:  MOVLW  12
03890:  MOVWF  xED
....................          } 
....................          else 
03892:  BRA    38C0
....................          { 
....................             if(ps->Flags.bServer) 
03894:  MOVLW  23
03896:  ADDWF  xE7,W
03898:  MOVWF  FE9
0389A:  MOVLW  00
0389C:  ADDWFC xE8,W
0389E:  MOVWF  FEA
038A0:  BTFSS  FEF.0
038A2:  BRA    38B0
....................             { 
....................                ps->smState = TCP_LISTEN; 
038A4:  MOVFF  1E7,FE9
038A8:  MOVFF  1E8,FEA
038AC:  CLRF   FEF
....................             } 
....................             else 
038AE:  BRA    38C0
....................             { 
....................                flags = SYN; 
038B0:  MOVLW  02
038B2:  MOVWF  xED
....................                ps->smState = TCP_SYN_SENT; 
038B4:  MOVFF  1E7,FE9
038B8:  MOVFF  1E8,FEA
038BC:  MOVLW  01
038BE:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
038C0:  BRA    39FA
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
038C2:  MOVLW  1E
038C4:  MOVLB  1
038C6:  ADDWF  xE7,W
038C8:  MOVWF  FE9
038CA:  MOVLW  00
038CC:  ADDWFC xE8,W
038CE:  MOVWF  FEA
038D0:  MOVF   FEF,W
038D2:  SUBLW  03
038D4:  BNC   391A
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
038D6:  MOVLW  0F
038D8:  ADDWF  xE7,W
038DA:  MOVWF  FE9
038DC:  MOVLW  00
038DE:  ADDWFC xE8,W
038E0:  MOVWF  FEA
038E2:  INCFSZ FEF,W
038E4:  BRA    38E8
038E6:  BRA    3910
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
038E8:  MOVLW  0F
038EA:  ADDWF  xE7,W
038EC:  MOVWF  FE9
038EE:  MOVLW  00
038F0:  ADDWFC xE8,W
038F2:  MOVWF  FEA
038F4:  MOVFF  FEF,1EE
038F8:  MOVFF  1EE,281
038FC:  MOVLB  2
038FE:  CLRF   x83
03900:  CLRF   x82
03902:  MOVLB  0
03904:  CALL   1026
....................                MACFlush(); 
03908:  CALL   1202
....................             } 
....................             else 
0390C:  BRA    3916
0390E:  MOVLB  1
....................                flags = ACK; 
03910:  MOVLW  10
03912:  MOVWF  xED
03914:  MOVLB  0
....................          } 
....................          else 
03916:  BRA    3968
03918:  MOVLB  1
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
0391A:  MOVLW  0F
0391C:  ADDWF  xE7,W
0391E:  MOVWF  FE9
03920:  MOVLW  00
03922:  ADDWFC xE8,W
03924:  MOVWF  FEA
03926:  INCFSZ FEF,W
03928:  BRA    392C
0392A:  BRA    3958
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
0392C:  MOVLW  0F
0392E:  ADDWF  xE7,W
03930:  MOVWF  FE9
03932:  MOVLW  00
03934:  ADDWFC xE8,W
03936:  MOVWF  FEA
03938:  MOVFF  FEF,1EE
0393C:  MOVFF  1EE,22F
03940:  MOVLB  0
03942:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
03946:  MOVLW  0F
03948:  MOVLB  1
0394A:  ADDWF  xE7,W
0394C:  MOVWF  FE9
0394E:  MOVLW  00
03950:  ADDWFC xE8,W
03952:  MOVWF  FEA
03954:  MOVLW  FF
03956:  MOVWF  FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
03958:  MOVLW  11
0395A:  MOVWF  xED
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
0395C:  MOVFF  1E7,FE9
03960:  MOVFF  1E8,FEA
03964:  MOVLW  04
03966:  MOVWF  FEF
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
03968:  MOVLB  1
0396A:  BRA    39FA
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0396C:  MOVLW  1E
0396E:  MOVLB  1
03970:  ADDWF  xE7,W
03972:  MOVWF  FE9
03974:  MOVLW  00
03976:  ADDWFC xE8,W
03978:  MOVWF  FEA
0397A:  MOVF   FEF,W
0397C:  SUBLW  03
0397E:  BNC   3986
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
03980:  MOVLW  01
03982:  MOVWF  xED
....................          } 
....................          else 
03984:  BRA    3996
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
03986:  MOVFF  1E8,22D
0398A:  MOVFF  1E7,22C
0398E:  MOVLB  0
03990:  CALL   2068
03994:  MOVLB  1
....................          } 
....................          break; 
03996:  BRA    39FA
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
03998:  MOVFF  1E8,22D
0399C:  MOVFF  1E7,22C
039A0:  CALL   2068
....................          break; 
039A4:  MOVLB  1
039A6:  BRA    39FA
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
039A8:  MOVFF  1E8,22D
039AC:  MOVFF  1E7,22C
039B0:  CALL   2068
....................          break; 
039B4:  MOVLB  1
039B6:  BRA    39FA
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
039B8:  MOVLW  01
039BA:  MOVLB  1
039BC:  MOVWF  xED
....................          ps->smState = TCP_LAST_ACK; 
039BE:  MOVFF  1E7,FE9
039C2:  MOVFF  1E8,FEA
039C6:  MOVLW  09
039C8:  MOVWF  FEF
....................          break; 
039CA:  BRA    39FA
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
039CC:  MOVLW  1E
039CE:  MOVLB  1
039D0:  ADDWF  xE7,W
039D2:  MOVWF  FE9
039D4:  MOVLW  00
039D6:  ADDWFC xE8,W
039D8:  MOVWF  FEA
039DA:  MOVF   FEF,W
039DC:  SUBLW  03
039DE:  BNC   39E6
....................             flags = FIN; 
039E0:  MOVLW  01
039E2:  MOVWF  xED
....................          else 
039E4:  BRA    39F6
....................             CloseSocket(ps); 
039E6:  MOVFF  1E8,22D
039EA:  MOVFF  1E7,22C
039EE:  MOVLB  0
039F0:  CALL   2068
039F4:  MOVLB  1
....................          break; 
039F6:  BRA    39FA
039F8:  MOVLB  1
....................       } 
....................  
....................  
....................       if(flags) 
039FA:  MOVF   xED,F
039FC:  BTFSC  FD8.2
039FE:  BRA    3B1C
....................       { 
....................          if(flags & ACK) 
03A00:  BTFSS  xED.4
03A02:  BRA    3A32
....................             seq = ps->SND_SEQ; 
03A04:  MOVLW  16
03A06:  ADDWF  xE7,W
03A08:  MOVWF  FE9
03A0A:  MOVLW  00
03A0C:  ADDWFC xE8,W
03A0E:  MOVWF  FEA
03A10:  MOVFF  FEF,00
03A14:  MOVFF  FEC,01
03A18:  MOVFF  FEC,02
03A1C:  MOVFF  FEC,03
03A20:  MOVFF  03,1EC
03A24:  MOVFF  02,1EB
03A28:  MOVFF  01,1EA
03A2C:  MOVFF  00,1E9
....................          else 
03A30:  BRA    3A74
....................             seq = ps->SND_SEQ++; 
03A32:  MOVLW  16
03A34:  ADDWF  xE7,W
03A36:  MOVWF  FE9
03A38:  MOVLW  00
03A3A:  ADDWFC xE8,W
03A3C:  MOVWF  FEA
03A3E:  MOVF   FEE,F
03A40:  MOVF   FEE,F
03A42:  MOVF   FEE,F
03A44:  MOVFF  FED,03
03A48:  MOVFF  FED,02
03A4C:  MOVFF  FED,01
03A50:  MOVFF  FEF,00
03A54:  MOVLW  01
03A56:  ADDWF  FEE,F
03A58:  BNZ   3A64
03A5A:  INCF   FEE,F
03A5C:  BNZ   3A64
03A5E:  INCF   FEE,F
03A60:  BNZ   3A64
03A62:  INCF   FED,F
03A64:  MOVFF  03,1EC
03A68:  MOVFF  02,1EB
03A6C:  MOVFF  01,1EA
03A70:  MOVFF  00,1E9
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
03A74:  MOVLW  01
03A76:  ADDWF  xE7,W
03A78:  MOVWF  01
03A7A:  MOVLW  00
03A7C:  ADDWFC xE8,W
03A7E:  MOVWF  03
03A80:  MOVFF  01,1EE
03A84:  MOVWF  xEF
03A86:  MOVLW  0B
03A88:  ADDWF  xE7,W
03A8A:  MOVWF  FE9
03A8C:  MOVLW  00
03A8E:  ADDWFC xE8,W
03A90:  MOVWF  FEA
03A92:  MOVFF  FEC,1F1
03A96:  MOVF   FED,F
03A98:  MOVFF  FEF,1F0
03A9C:  MOVLW  0D
03A9E:  ADDWF  xE7,W
03AA0:  MOVWF  FE9
03AA2:  MOVLW  00
03AA4:  ADDWFC xE8,W
03AA6:  MOVWF  FEA
03AA8:  MOVFF  FEC,1F3
03AAC:  MOVF   FED,F
03AAE:  MOVFF  FEF,1F2
03AB2:  MOVLW  1A
03AB4:  ADDWF  xE7,W
03AB6:  MOVWF  FE9
03AB8:  MOVLW  00
03ABA:  ADDWFC xE8,W
03ABC:  MOVWF  FEA
03ABE:  MOVFF  FEF,1F4
03AC2:  MOVFF  FEC,1F5
03AC6:  MOVFF  FEC,1F6
03ACA:  MOVFF  FEC,1F7
03ACE:  MOVFF  03,231
03AD2:  MOVFF  01,230
03AD6:  MOVFF  1F1,233
03ADA:  MOVFF  1F0,232
03ADE:  MOVFF  1F3,235
03AE2:  MOVFF  1F2,234
03AE6:  MOVFF  1EC,239
03AEA:  MOVFF  1EB,238
03AEE:  MOVFF  1EA,237
03AF2:  MOVFF  1E9,236
03AF6:  MOVFF  1F7,23D
03AFA:  MOVFF  1F6,23C
03AFE:  MOVFF  1F5,23B
03B02:  MOVFF  1F4,23A
03B06:  MOVFF  1ED,23E
03B0A:  MOVLW  FF
03B0C:  MOVLB  2
03B0E:  MOVWF  x3F
03B10:  CLRF   x41
03B12:  CLRF   x40
03B14:  MOVLB  0
03B16:  CALL   24B4
03B1A:  MOVLB  1
....................       } 
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
03B1C:  INCF   xE2,F
03B1E:  BRA    3686
03B20:  MOVLB  0
.................... } 
03B22:  GOTO   3D02 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
031D8:  MOVLW  06
031DA:  MOVLB  1
031DC:  ADDWF  xE2,W
031DE:  MOVWF  FE9
031E0:  MOVLW  00
031E2:  ADDWFC xE3,W
031E4:  MOVWF  FEA
031E6:  MOVFF  FEF,00
031EA:  MOVFF  FEC,01
031EE:  MOVFF  FEC,02
031F2:  MOVFF  FEC,03
031F6:  MOVFF  03,1FF
031FA:  MOVFF  02,1FE
031FE:  MOVFF  01,1FD
03202:  MOVFF  00,1FC
....................    pseudoHeader.DestAddress        = *localIP; 
03206:  MOVFF  1E4,FE9
0320A:  MOVFF  1E5,FEA
0320E:  MOVFF  FEF,00
03212:  MOVFF  FEC,01
03216:  MOVFF  FEC,02
0321A:  MOVFF  FEC,03
0321E:  MOVFF  03,203
03222:  MOVFF  02,202
03226:  MOVFF  01,201
0322A:  MOVFF  00,200
....................    pseudoHeader.Zero               = 0x0; 
0322E:  MOVLB  2
03230:  CLRF   x04
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
03232:  MOVLW  06
03234:  MOVWF  x05
....................    pseudoHeader.TCPLength          = len; 
03236:  MOVFF  1E7,207
0323A:  MOVFF  1E6,206
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
0323E:  MOVFF  207,288
03242:  MOVFF  206,287
03246:  MOVLB  0
03248:  CALL   0CF0
0324C:  MOVFF  02,207
03250:  MOVFF  01,206
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03254:  MOVLW  01
03256:  MOVLB  2
03258:  MOVWF  x0F
0325A:  MOVLW  FC
0325C:  MOVFF  20F,26B
03260:  MOVWF  x6A
03262:  CLRF   x6D
03264:  MOVLW  0C
03266:  MOVWF  x6C
03268:  MOVLB  0
0326A:  CALL   19A0
0326E:  MOVFF  01,209
03272:  MOVLB  2
03274:  COMF   x09,F
03276:  MOVFF  02,20A
0327A:  COMF   x0A,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
0327C:  MOVFF  1E7,269
03280:  MOVFF  1E6,268
03284:  MOVLB  0
03286:  CALL   1AB6
0328A:  MOVFF  02,20C
0328E:  MOVFF  01,20B
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
03292:  MOVLB  2
03294:  MOVF   x0C,W
03296:  SUBWF  x09,W
03298:  BNZ   32A0
0329A:  MOVF   x0B,W
0329C:  SUBWF  x0A,W
0329E:  BZ    32AE
....................    { 
....................       MACDiscardRx(); 
032A0:  MOVLB  0
032A2:  CALL   0C30
....................       return TRUE; 
032A6:  MOVLW  01
032A8:  MOVWF  01
032AA:  BRA    3394
032AC:  MOVLB  2
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
032AE:  CLRF   x11
032B0:  CLRF   x10
032B2:  MOVLB  0
032B4:  CALL   1C0E
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
032B8:  MOVLW  01
032BA:  MOVLB  2
032BC:  MOVWF  x0F
032BE:  MOVLW  E8
032C0:  MOVFF  20F,277
032C4:  MOVWF  x76
032C6:  CLRF   x79
032C8:  MOVLW  14
032CA:  MOVWF  x78
032CC:  MOVLB  0
032CE:  CALL   0C94
....................    SwapTCPHeader(&TCPHeader); 
032D2:  MOVLW  01
032D4:  MOVLB  2
032D6:  MOVWF  x69
032D8:  MOVLW  E8
032DA:  MOVWF  x68
032DC:  MOVLB  0
032DE:  CALL   1C4A
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
032E2:  MOVLB  1
032E4:  SWAPF  xF4,W
032E6:  ANDLW  0F
032E8:  MOVWF  00
032EA:  RLCF   00,W
032EC:  MOVLB  2
032EE:  MOVWF  x0F
032F0:  RLCF   x0F,F
032F2:  MOVLW  FC
032F4:  ANDWF  x0F,F
032F6:  MOVLW  14
032F8:  SUBWF  x0F,W
032FA:  MOVWF  x0D
....................    len = len - optionsSize - sizeof(TCPHeader); 
032FC:  MOVF   x0D,W
032FE:  MOVLB  1
03300:  SUBWF  xE6,W
03302:  MOVLB  2
03304:  MOVWF  x0E
03306:  MOVLW  00
03308:  MOVLB  1
0330A:  SUBWFB xE7,W
0330C:  MOVLB  2
0330E:  MOVWF  x0F
03310:  MOVLW  14
03312:  SUBWF  x0E,W
03314:  MOVLB  1
03316:  MOVWF  xE6
03318:  MOVLW  00
0331A:  MOVLB  2
0331C:  SUBWFB x0F,W
0331E:  MOVLB  1
03320:  MOVWF  xE7
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
03322:  SWAPF  xF4,W
03324:  ANDLW  0F
03326:  MOVWF  00
03328:  RLCF   00,W
0332A:  MOVLB  2
0332C:  MOVWF  x0F
0332E:  RLCF   x0F,F
03330:  MOVLW  FC
03332:  ANDWF  x0F,F
03334:  CLRF   x11
03336:  MOVFF  20F,210
0333A:  MOVLB  0
0333C:  CALL   1C0E
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
03340:  MOVLW  01
03342:  MOVLB  2
03344:  MOVWF  x0F
03346:  MOVLW  E8
03348:  MOVWF  x0E
0334A:  MOVFF  1E3,211
0334E:  MOVFF  1E2,210
03352:  MOVLB  0
03354:  GOTO   1E70
03358:  MOVFF  01,208
....................    if(socket != INVALID_SOCKET) 
0335C:  MOVLB  2
0335E:  MOVF   x08,W
03360:  SUBLW  FE
03362:  BZ    338A
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
03364:  MOVFF  208,20E
03368:  MOVFF  1E3,210
0336C:  MOVFF  1E2,20F
03370:  MOVLW  01
03372:  MOVWF  x12
03374:  MOVLW  E8
03376:  MOVWF  x11
03378:  MOVFF  1E7,214
0337C:  MOVFF  1E6,213
03380:  MOVLB  0
03382:  GOTO   26E2
....................    } 
....................    else 
03386:  BRA    3390
03388:  MOVLB  2
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
0338A:  MOVLB  0
0338C:  CALL   0C30
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
03390:  MOVLW  01
03392:  MOVWF  01
.................... } 
03394:  GOTO   3C48 (RETURN)
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
024B4:  MOVLW  01
024B6:  MOVLB  2
024B8:  MOVWF  x68
024BA:  MOVLB  0
024BC:  RCALL  216C
024BE:  MOVF   01,F
024C0:  BZ    24B4
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
024C2:  MOVLB  2
024C4:  INCFSZ x3F,W
024C6:  BRA    24D8
....................       buff = MACGetTxBuffer(TRUE); 
024C8:  MOVLW  01
024CA:  MOVWF  x68
024CC:  MOVLB  0
024CE:  CALL   0FFC
024D2:  MOVFF  01,23F
024D6:  MOVLB  2
....................  
....................    if(buff == INVALID_BUFFER) 
024D8:  INCFSZ x3F,W
024DA:  BRA    24DE
....................       return; 
024DC:  BRA    26DE
....................  
....................    IPSetTxBuffer(buff, 0); 
024DE:  MOVFF  23F,281
024E2:  CLRF   x83
024E4:  MOVLW  14
024E6:  MOVWF  x82
024E8:  MOVLB  0
024EA:  CALL   1026
....................  
....................    header.SourcePort           = localPort; 
024EE:  MOVFF  233,245
024F2:  MOVFF  232,244
....................    header.DestPort             = remotePort; 
024F6:  MOVFF  235,247
024FA:  MOVFF  234,246
....................    header.SeqNumber            = tseq; 
024FE:  MOVFF  239,24B
02502:  MOVFF  238,24A
02506:  MOVFF  237,249
0250A:  MOVFF  236,248
....................    header.AckNumber            = tack; 
0250E:  MOVFF  23D,24F
02512:  MOVFF  23C,24E
02516:  MOVFF  23B,24D
0251A:  MOVFF  23A,24C
....................    header.Flags.bits.Reserved2 = 0; 
0251E:  MOVLW  3F
02520:  MOVLB  2
02522:  ANDWF  x51,W
02524:  MOVWF  x51
....................    header.DataOffset.Reserved3 = 0; 
02526:  MOVLW  F0
02528:  ANDWF  x50,W
0252A:  MOVWF  x50
....................    header.Flags.b              = flags; 
0252C:  MOVFF  23E,251
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
02530:  MOVLB  0
02532:  BRA    2196
02534:  MOVFF  02,253
02538:  MOVFF  01,252
.................... #if !defined(STACK_USE_SLIP) 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
0253C:  MOVLB  2
0253E:  MOVF   x53,F
02540:  BNZ   2548
02542:  MOVF   x52,W
02544:  SUBLW  28
02546:  BC    2552
....................    { 
....................       header.Window -= 40; 
02548:  MOVLW  28
0254A:  SUBWF  x52,F
0254C:  MOVLW  00
0254E:  SUBWFB x53,F
....................    } 
....................    else 
02550:  BRA    2556
....................       header.Window = 0; 
02552:  CLRF   x53
02554:  CLRF   x52
.................... #endif 
....................  
....................    header.Checksum             = 0; 
02556:  CLRF   x55
02558:  CLRF   x54
....................    header.UrgentPointer        = 0; 
0255A:  CLRF   x57
0255C:  CLRF   x56
....................  
....................    SwapTCPHeader(&header); 
0255E:  MOVLW  02
02560:  MOVWF  x69
02562:  MOVLW  44
02564:  MOVWF  x68
02566:  MOVLB  0
02568:  CALL   1C4A
....................  
....................    len += sizeof(header); 
0256C:  MOVLW  14
0256E:  MOVLB  2
02570:  ADDWF  x40,F
02572:  MOVLW  00
02574:  ADDWFC x41,F
....................  
....................    if ( flags & SYN ) 
02576:  BTFSS  x3E.1
02578:  BRA    2598
....................    { 
....................       len += sizeof(options); 
0257A:  MOVLW  04
0257C:  ADDWF  x40,F
0257E:  MOVLW  00
02580:  ADDWFC x41,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
02582:  MOVLW  02
02584:  MOVWF  x58
....................       options.Length = 0x04; 
02586:  MOVLW  04
02588:  MOVWF  x59
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
0258A:  MOVWF  x5A
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
0258C:  CLRF   x5B
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
0258E:  MOVLW  0F
02590:  ANDWF  x50,W
02592:  IORLW  60
02594:  MOVWF  x50
....................    } 
....................    else 
02596:  BRA    25A0
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
02598:  MOVLW  0F
0259A:  ANDWF  x50,W
0259C:  IORLW  50
0259E:  MOVWF  x50
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
025A0:  MOVFF  1B,25F
025A4:  MOVFF  1A,25E
025A8:  MOVFF  19,25D
025AC:  MOVFF  18,25C
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
025B0:  MOVLW  06
025B2:  ADDWF  x30,W
025B4:  MOVWF  FE9
025B6:  MOVLW  00
025B8:  ADDWFC x31,W
025BA:  MOVWF  FEA
025BC:  MOVFF  FEF,00
025C0:  MOVFF  FEC,01
025C4:  MOVFF  FEC,02
025C8:  MOVFF  FEC,03
025CC:  MOVFF  03,263
025D0:  MOVFF  02,262
025D4:  MOVFF  01,261
025D8:  MOVFF  00,260
....................    pseudoHeader.Zero           = 0x0; 
025DC:  CLRF   x64
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
025DE:  MOVLW  06
025E0:  MOVWF  x65
....................    pseudoHeader.TCPLength      = len; 
025E2:  MOVFF  241,267
025E6:  MOVFF  240,266
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
025EA:  MOVFF  267,288
025EE:  MOVFF  266,287
025F2:  MOVLB  0
025F4:  CALL   0CF0
025F8:  MOVFF  02,267
025FC:  MOVFF  01,266
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
02600:  MOVLW  02
02602:  MOVLB  2
02604:  MOVWF  x69
02606:  MOVLW  5C
02608:  MOVFF  269,26B
0260C:  MOVWF  x6A
0260E:  CLRF   x6D
02610:  MOVLW  0C
02612:  MOVWF  x6C
02614:  MOVLB  0
02616:  CALL   19A0
0261A:  MOVFF  01,254
0261E:  MOVLB  2
02620:  COMF   x54,F
02622:  MOVFF  02,255
02626:  COMF   x55,F
....................    checkSum.Val = header.Checksum; 
02628:  MOVFF  255,243
0262C:  MOVFF  254,242
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
02630:  MOVFF  231,269
02634:  MOVFF  230,268
02638:  MOVLW  06
0263A:  MOVWF  x6A
0263C:  MOVFF  241,26C
02640:  MOVFF  240,26B
02644:  MOVLB  0
02646:  RCALL  2388
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
02648:  MOVLW  02
0264A:  MOVLB  2
0264C:  MOVWF  x69
0264E:  MOVLW  44
02650:  MOVFF  269,28D
02654:  MOVWF  x8C
02656:  CLRF   x8F
02658:  MOVLW  14
0265A:  MOVWF  x8E
0265C:  MOVLB  0
0265E:  CALL   10EA
....................  
....................    if ( flags & SYN ) 
02662:  MOVLB  2
02664:  BTFSS  x3E.1
02666:  BRA    2682
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
02668:  MOVLW  02
0266A:  MOVWF  x69
0266C:  MOVLW  58
0266E:  MOVFF  269,28D
02672:  MOVWF  x8C
02674:  CLRF   x8F
02676:  MOVLW  04
02678:  MOVWF  x8E
0267A:  MOVLB  0
0267C:  CALL   10EA
02680:  MOVLB  2
....................  
....................    IPSetTxBuffer(buff, 0); 
02682:  MOVFF  23F,281
02686:  CLRF   x83
02688:  MOVLW  14
0268A:  MOVWF  x82
0268C:  MOVLB  0
0268E:  CALL   1026
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
02692:  MOVFF  241,269
02696:  MOVFF  240,268
0269A:  CALL   1AB6
0269E:  MOVFF  02,243
026A2:  MOVFF  01,242
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
026A6:  MOVFF  23F,281
026AA:  MOVLB  2
026AC:  CLRF   x83
026AE:  MOVLW  24
026B0:  MOVWF  x82
026B2:  MOVLB  0
026B4:  CALL   1026
....................    MACPut(checkSum.v[1]); 
026B8:  MOVFF  243,28B
026BC:  CALL   10D0
....................    MACPut(checkSum.v[0]); 
026C0:  MOVFF  242,28B
026C4:  CALL   10D0
....................    MACSetTxBuffer(buff, 0); 
026C8:  MOVFF  23F,281
026CC:  MOVLB  2
026CE:  CLRF   x83
026D0:  CLRF   x82
026D2:  MOVLB  0
026D4:  CALL   1026
....................  
....................    MACFlush(); 
026D8:  CALL   1202
026DC:  MOVLB  2
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
.................... } 
026DE:  MOVLB  0
026E0:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
01E70:  MOVLW  FE
01E72:  MOVLB  2
01E74:  MOVWF  x15
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
01E76:  CLRF   x14
01E78:  MOVF   x14,W
01E7A:  SUBLW  04
01E7C:  BTFSS  FD8.0
01E7E:  BRA    1F74
....................    { 
....................       ps = &TCB[s]; 
01E80:  MOVF   x14,W
01E82:  MULLW  24
01E84:  MOVF   FF3,W
01E86:  CLRF   03
01E88:  ADDLW  5F
01E8A:  MOVWF  01
01E8C:  MOVLW  00
01E8E:  ADDWFC 03,F
01E90:  MOVFF  01,212
01E94:  MOVFF  03,213
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
01E98:  MOVFF  212,FE9
01E9C:  MOVFF  213,FEA
01EA0:  MOVF   FEF,W
01EA2:  SUBLW  0A
01EA4:  BZ    1F70
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
01EA6:  MOVLW  0B
01EA8:  ADDWF  x12,W
01EAA:  MOVWF  FE9
01EAC:  MOVLW  00
01EAE:  ADDWFC x13,W
01EB0:  MOVWF  FEA
01EB2:  MOVFF  FEC,217
01EB6:  MOVF   FED,F
01EB8:  MOVFF  FEF,216
01EBC:  MOVLW  02
01EBE:  ADDWF  x0E,W
01EC0:  MOVWF  FE9
01EC2:  MOVLW  00
01EC4:  ADDWFC x0F,W
01EC6:  MOVWF  FEA
01EC8:  MOVFF  FEC,03
01ECC:  MOVF   FED,F
01ECE:  MOVF   FEF,W
01ED0:  SUBWF  x16,W
01ED2:  BNZ   1F70
01ED4:  MOVF   03,W
01ED6:  SUBWF  x17,W
01ED8:  BNZ   1F70
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
01EDA:  MOVFF  212,FE9
01EDE:  MOVFF  213,FEA
01EE2:  MOVF   FEF,F
01EE4:  BNZ   1EEA
....................                partialMatch = s; 
01EE6:  MOVFF  214,215
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
01EEA:  MOVLW  0D
01EEC:  ADDWF  x12,W
01EEE:  MOVWF  FE9
01EF0:  MOVLW  00
01EF2:  ADDWFC x13,W
01EF4:  MOVWF  FEA
01EF6:  MOVFF  FEC,217
01EFA:  MOVF   FED,F
01EFC:  MOVFF  FEF,216
01F00:  MOVFF  20E,FE9
01F04:  MOVFF  20F,FEA
01F08:  MOVFF  FEC,03
01F0C:  MOVF   FED,F
01F0E:  MOVF   FEF,W
01F10:  SUBWF  x16,W
01F12:  BNZ   1F70
01F14:  MOVF   03,W
01F16:  SUBWF  x17,W
01F18:  BNZ   1F70
01F1A:  MOVLW  07
01F1C:  ADDWF  x12,W
01F1E:  MOVWF  FE9
01F20:  MOVLW  00
01F22:  ADDWFC x13,W
01F24:  MOVWF  FEA
01F26:  MOVFF  FEF,218
01F2A:  MOVFF  FEC,219
01F2E:  MOVFF  FEC,21A
01F32:  MOVFF  FEC,21B
01F36:  MOVLW  06
01F38:  ADDWF  x10,W
01F3A:  MOVWF  FE9
01F3C:  MOVLW  00
01F3E:  ADDWFC x11,W
01F40:  MOVWF  FEA
01F42:  MOVFF  FEF,00
01F46:  MOVFF  FEC,01
01F4A:  MOVFF  FEC,02
01F4E:  MOVFF  FEC,03
01F52:  MOVF   00,W
01F54:  SUBWF  x18,W
01F56:  BNZ   1F70
01F58:  MOVF   01,W
01F5A:  SUBWF  x19,W
01F5C:  BNZ   1F70
01F5E:  MOVF   02,W
01F60:  SUBWF  x1A,W
01F62:  BNZ   1F70
01F64:  MOVF   03,W
01F66:  SUBWF  x1B,W
01F68:  BNZ   1F70
....................             { 
....................                return s; 
01F6A:  MOVFF  214,01
01F6E:  BRA    2048
....................             } 
....................          } 
....................       } 
....................    } 
01F70:  INCF   x14,F
01F72:  BRA    1E78
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
01F74:  MOVF   x15,W
01F76:  SUBLW  FE
01F78:  BNZ   1F80
....................       return INVALID_SOCKET; 
01F7A:  MOVLW  FE
01F7C:  MOVWF  01
01F7E:  BRA    2048
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
01F80:  MOVF   x15,W
01F82:  MULLW  24
01F84:  MOVF   FF3,W
01F86:  CLRF   03
01F88:  ADDLW  5F
01F8A:  MOVWF  01
01F8C:  MOVLW  00
01F8E:  ADDWFC 03,F
01F90:  MOVFF  01,212
01F94:  MOVFF  03,213
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
01F98:  MOVLW  01
01F9A:  ADDWF  x12,W
01F9C:  MOVWF  x16
01F9E:  MOVLW  00
01FA0:  ADDWFC x13,W
01FA2:  MOVWF  x17
01FA4:  MOVWF  FEA
01FA6:  MOVFF  216,FE9
01FAA:  MOVFF  211,FE2
01FAE:  MOVFF  210,FE1
01FB2:  MOVLW  0A
01FB4:  MOVWF  01
01FB6:  MOVFF  FE6,FEE
01FBA:  DECFSZ 01,F
01FBC:  BRA    1FB6
....................    ps->remotePort          = h->SourcePort; 
01FBE:  MOVLW  0D
01FC0:  ADDWF  x12,W
01FC2:  MOVWF  01
01FC4:  MOVLW  00
01FC6:  ADDWFC x13,W
01FC8:  MOVFF  20E,FE9
01FCC:  MOVFF  20F,FEA
01FD0:  MOVFF  FEC,03
01FD4:  MOVF   FED,F
01FD6:  MOVFF  FEF,218
01FDA:  MOVWF  FEA
01FDC:  MOVFF  01,FE9
01FE0:  MOVFF  03,FEC
01FE4:  MOVF   FED,F
01FE6:  MOVFF  218,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
01FEA:  MOVLW  23
01FEC:  ADDWF  x12,W
01FEE:  MOVWF  FE9
01FF0:  MOVLW  00
01FF2:  ADDWFC x13,W
01FF4:  MOVWF  FEA
01FF6:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
01FF8:  MOVLW  0F
01FFA:  ADDWF  x12,W
01FFC:  MOVWF  FE9
01FFE:  MOVLW  00
02000:  ADDWFC x13,W
02002:  MOVWF  FEA
02004:  INCFSZ FEF,W
02006:  BRA    200A
02008:  BRA    2036
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
0200A:  MOVLW  0F
0200C:  ADDWF  x12,W
0200E:  MOVWF  FE9
02010:  MOVLW  00
02012:  ADDWFC x13,W
02014:  MOVWF  FEA
02016:  MOVFF  FEF,216
0201A:  MOVFF  216,22F
0201E:  MOVLB  0
02020:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
02024:  MOVLW  0F
02026:  MOVLB  2
02028:  ADDWF  x12,W
0202A:  MOVWF  FE9
0202C:  MOVLW  00
0202E:  ADDWFC x13,W
02030:  MOVWF  FEA
02032:  MOVLW  FF
02034:  MOVWF  FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
02036:  MOVLW  23
02038:  ADDWF  x12,W
0203A:  MOVWF  FE9
0203C:  MOVLW  00
0203E:  ADDWFC x13,W
02040:  MOVWF  FEA
02042:  BSF    FEF.1
....................  
....................    return partialMatch; 
02044:  MOVFF  215,01
.................... } 
02048:  MOVLB  0
0204A:  GOTO   3358 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
01C4A:  MOVLB  2
01C4C:  MOVFF  268,01
01C50:  MOVFF  269,03
01C54:  MOVFF  268,26A
01C58:  MOVFF  269,26B
01C5C:  MOVFF  268,FE9
01C60:  MOVFF  269,FEA
01C64:  MOVFF  FEC,26D
01C68:  MOVF   FED,F
01C6A:  MOVFF  FEF,26C
01C6E:  MOVFF  26D,288
01C72:  MOVFF  26C,287
01C76:  MOVLB  0
01C78:  CALL   0CF0
01C7C:  MOVFF  26B,FEA
01C80:  MOVFF  26A,FE9
01C84:  MOVFF  02,FEC
01C88:  MOVF   FED,F
01C8A:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
01C8E:  MOVLW  02
01C90:  MOVLB  2
01C92:  ADDWF  x68,W
01C94:  MOVWF  01
01C96:  MOVLW  00
01C98:  ADDWFC x69,W
01C9A:  MOVWF  03
01C9C:  MOVFF  01,26A
01CA0:  MOVWF  x6B
01CA2:  MOVLW  02
01CA4:  ADDWF  x68,W
01CA6:  MOVWF  FE9
01CA8:  MOVLW  00
01CAA:  ADDWFC x69,W
01CAC:  MOVWF  FEA
01CAE:  MOVFF  FEC,26D
01CB2:  MOVF   FED,F
01CB4:  MOVFF  FEF,26C
01CB8:  MOVFF  26D,288
01CBC:  MOVFF  26C,287
01CC0:  MOVLB  0
01CC2:  CALL   0CF0
01CC6:  MOVFF  26B,FEA
01CCA:  MOVFF  26A,FE9
01CCE:  MOVFF  02,FEC
01CD2:  MOVF   FED,F
01CD4:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
01CD8:  MOVLW  04
01CDA:  MOVLB  2
01CDC:  ADDWF  x68,W
01CDE:  MOVWF  01
01CE0:  MOVLW  00
01CE2:  ADDWFC x69,W
01CE4:  MOVWF  03
01CE6:  MOVFF  01,26A
01CEA:  MOVWF  x6B
01CEC:  MOVLW  04
01CEE:  ADDWF  x68,W
01CF0:  MOVWF  FE9
01CF2:  MOVLW  00
01CF4:  ADDWFC x69,W
01CF6:  MOVWF  FEA
01CF8:  MOVFF  FEF,26C
01CFC:  MOVFF  FEC,26D
01D00:  MOVFF  FEC,26E
01D04:  MOVFF  FEC,26F
01D08:  MOVFF  26F,273
01D0C:  MOVFF  26E,272
01D10:  MOVFF  26D,271
01D14:  MOVFF  26C,270
01D18:  MOVLB  0
01D1A:  RCALL  1C28
01D1C:  MOVFF  26B,FEA
01D20:  MOVFF  26A,FE9
01D24:  MOVFF  00,FEF
01D28:  MOVFF  01,FEC
01D2C:  MOVFF  02,FEC
01D30:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
01D34:  MOVLW  08
01D36:  MOVLB  2
01D38:  ADDWF  x68,W
01D3A:  MOVWF  01
01D3C:  MOVLW  00
01D3E:  ADDWFC x69,W
01D40:  MOVWF  03
01D42:  MOVFF  01,26A
01D46:  MOVWF  x6B
01D48:  MOVLW  08
01D4A:  ADDWF  x68,W
01D4C:  MOVWF  FE9
01D4E:  MOVLW  00
01D50:  ADDWFC x69,W
01D52:  MOVWF  FEA
01D54:  MOVFF  FEF,26C
01D58:  MOVFF  FEC,26D
01D5C:  MOVFF  FEC,26E
01D60:  MOVFF  FEC,26F
01D64:  MOVFF  26F,273
01D68:  MOVFF  26E,272
01D6C:  MOVFF  26D,271
01D70:  MOVFF  26C,270
01D74:  MOVLB  0
01D76:  RCALL  1C28
01D78:  MOVFF  26B,FEA
01D7C:  MOVFF  26A,FE9
01D80:  MOVFF  00,FEF
01D84:  MOVFF  01,FEC
01D88:  MOVFF  02,FEC
01D8C:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
01D90:  MOVLW  0E
01D92:  MOVLB  2
01D94:  ADDWF  x68,W
01D96:  MOVWF  01
01D98:  MOVLW  00
01D9A:  ADDWFC x69,W
01D9C:  MOVWF  03
01D9E:  MOVFF  01,26A
01DA2:  MOVWF  x6B
01DA4:  MOVLW  0E
01DA6:  ADDWF  x68,W
01DA8:  MOVWF  FE9
01DAA:  MOVLW  00
01DAC:  ADDWFC x69,W
01DAE:  MOVWF  FEA
01DB0:  MOVFF  FEC,26D
01DB4:  MOVF   FED,F
01DB6:  MOVFF  FEF,26C
01DBA:  MOVFF  26D,288
01DBE:  MOVFF  26C,287
01DC2:  MOVLB  0
01DC4:  CALL   0CF0
01DC8:  MOVFF  26B,FEA
01DCC:  MOVFF  26A,FE9
01DD0:  MOVFF  02,FEC
01DD4:  MOVF   FED,F
01DD6:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
01DDA:  MOVLW  10
01DDC:  MOVLB  2
01DDE:  ADDWF  x68,W
01DE0:  MOVWF  01
01DE2:  MOVLW  00
01DE4:  ADDWFC x69,W
01DE6:  MOVWF  03
01DE8:  MOVFF  01,26A
01DEC:  MOVWF  x6B
01DEE:  MOVLW  10
01DF0:  ADDWF  x68,W
01DF2:  MOVWF  FE9
01DF4:  MOVLW  00
01DF6:  ADDWFC x69,W
01DF8:  MOVWF  FEA
01DFA:  MOVFF  FEC,26D
01DFE:  MOVF   FED,F
01E00:  MOVFF  FEF,26C
01E04:  MOVFF  26D,288
01E08:  MOVFF  26C,287
01E0C:  MOVLB  0
01E0E:  CALL   0CF0
01E12:  MOVFF  26B,FEA
01E16:  MOVFF  26A,FE9
01E1A:  MOVFF  02,FEC
01E1E:  MOVF   FED,F
01E20:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
01E24:  MOVLW  12
01E26:  MOVLB  2
01E28:  ADDWF  x68,W
01E2A:  MOVWF  01
01E2C:  MOVLW  00
01E2E:  ADDWFC x69,W
01E30:  MOVWF  03
01E32:  MOVFF  01,26A
01E36:  MOVWF  x6B
01E38:  MOVLW  12
01E3A:  ADDWF  x68,W
01E3C:  MOVWF  FE9
01E3E:  MOVLW  00
01E40:  ADDWFC x69,W
01E42:  MOVWF  FEA
01E44:  MOVFF  FEC,26D
01E48:  MOVF   FED,F
01E4A:  MOVFF  FEF,26C
01E4E:  MOVFF  26D,288
01E52:  MOVFF  26C,287
01E56:  MOVLB  0
01E58:  CALL   0CF0
01E5C:  MOVFF  26B,FEA
01E60:  MOVFF  26A,FE9
01E64:  MOVFF  02,FEC
01E68:  MOVF   FED,F
01E6A:  MOVFF  01,FEF
.................... } 
01E6E:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
02068:  MOVLW  0F
0206A:  MOVLB  2
0206C:  ADDWF  x2C,W
0206E:  MOVWF  FE9
02070:  MOVLW  00
02072:  ADDWFC x2D,W
02074:  MOVWF  FEA
02076:  INCFSZ FEF,W
02078:  BRA    207C
0207A:  BRA    20B6
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
0207C:  MOVLW  0F
0207E:  ADDWF  x2C,W
02080:  MOVWF  FE9
02082:  MOVLW  00
02084:  ADDWFC x2D,W
02086:  MOVWF  FEA
02088:  MOVFF  FEF,22E
0208C:  MOVFF  22E,22F
02090:  MOVLB  0
02092:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
02096:  MOVLW  0F
02098:  MOVLB  2
0209A:  ADDWF  x2C,W
0209C:  MOVWF  FE9
0209E:  MOVLW  00
020A0:  ADDWFC x2D,W
020A2:  MOVWF  FEA
020A4:  MOVLW  FF
020A6:  MOVWF  FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
020A8:  MOVLW  23
020AA:  ADDWF  x2C,W
020AC:  MOVWF  FE9
020AE:  MOVLW  00
020B0:  ADDWFC x2D,W
020B2:  MOVWF  FEA
020B4:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
020B6:  MOVLW  07
020B8:  ADDWF  x2C,W
020BA:  MOVWF  FE9
020BC:  MOVLW  00
020BE:  ADDWFC x2D,W
020C0:  MOVWF  FEA
020C2:  MOVF   FEE,F
020C4:  MOVF   FEE,F
020C6:  CLRF   FEC
020C8:  MOVF   FED,F
020CA:  CLRF   FEF
020CC:  MOVF   FED,F
020CE:  CLRF   FEF
020D0:  MOVF   FED,F
020D2:  CLRF   FEF
....................     ps->remotePort = 0x00; 
020D4:  MOVLW  0D
020D6:  ADDWF  x2C,W
020D8:  MOVWF  FE9
020DA:  MOVLW  00
020DC:  ADDWFC x2D,W
020DE:  MOVWF  FEA
020E0:  CLRF   FEC
020E2:  MOVF   FED,F
020E4:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
020E6:  MOVLW  23
020E8:  ADDWF  x2C,W
020EA:  MOVWF  FE9
020EC:  MOVLW  00
020EE:  ADDWFC x2D,W
020F0:  MOVWF  FEA
020F2:  BTFSS  FEF.3
020F4:  BRA    20FE
....................     { 
....................         MACDiscardRx(); 
020F6:  MOVLB  0
020F8:  CALL   0C30
020FC:  MOVLB  2
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
020FE:  MOVLW  23
02100:  ADDWF  x2C,W
02102:  MOVWF  FE9
02104:  MOVLW  00
02106:  ADDWFC x2D,W
02108:  MOVWF  FEA
0210A:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
0210C:  MOVLW  21
0210E:  ADDWF  x2C,W
02110:  MOVWF  FE9
02112:  MOVLW  00
02114:  ADDWFC x2D,W
02116:  MOVWF  FEA
02118:  CLRF   FEC
0211A:  MOVF   FED,F
0211C:  MOVLW  1E
0211E:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
02120:  MOVLW  23
02122:  ADDWF  x2C,W
02124:  MOVWF  FE9
02126:  MOVLW  00
02128:  ADDWFC x2D,W
0212A:  MOVWF  FEA
0212C:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
0212E:  MOVLW  23
02130:  ADDWF  x2C,W
02132:  MOVWF  FE9
02134:  MOVLW  00
02136:  ADDWFC x2D,W
02138:  MOVWF  FEA
0213A:  BTFSS  FEF.0
0213C:  BRA    214A
....................     { 
....................         ps->smState = TCP_LISTEN; 
0213E:  MOVFF  22C,FE9
02142:  MOVFF  22D,FEA
02146:  CLRF   FEF
....................     } 
....................     else 
02148:  BRA    2156
....................     { 
....................         ps->smState = TCP_CLOSED; 
0214A:  MOVFF  22C,FE9
0214E:  MOVFF  22D,FEA
02152:  MOVLW  0A
02154:  MOVWF  FEF
....................     } 
....................  
....................    ps->TxCount = 0; 
02156:  MOVLW  10
02158:  ADDWF  x2C,W
0215A:  MOVWF  FE9
0215C:  MOVLW  00
0215E:  ADDWFC x2D,W
02160:  MOVWF  FEA
02162:  CLRF   FEC
02164:  MOVF   FED,F
02166:  CLRF   FEF
....................  
....................     return; 
.................... } 
02168:  MOVLB  0
0216A:  RETLW  00
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
026E2:  MOVLB  2
026E4:  MOVF   x0E,W
026E6:  MULLW  24
026E8:  MOVF   FF3,W
026EA:  CLRF   03
026EC:  ADDLW  5F
026EE:  MOVWF  01
026F0:  MOVLW  00
026F2:  ADDWFC 03,F
026F4:  MOVFF  01,225
026F8:  MOVFF  03,226
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
026FC:  CLRF   x27
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
026FE:  MOVLW  1E
02700:  ADDWF  x25,W
02702:  MOVWF  FE9
02704:  MOVLW  00
02706:  ADDWFC x26,W
02708:  MOVWF  FEA
0270A:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
0270C:  MOVLW  1F
0270E:  ADDWF  x25,W
02710:  MOVWF  01
02712:  MOVLW  00
02714:  ADDWFC x26,W
02716:  MOVWF  03
02718:  MOVFF  01,22C
0271C:  MOVWF  x2D
0271E:  MOVLB  0
02720:  RCALL  204E
02722:  MOVFF  22D,FEA
02726:  MOVFF  22C,FE9
0272A:  MOVFF  02,FEC
0272E:  MOVF   FED,F
02730:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
02734:  MOVLW  21
02736:  MOVLB  2
02738:  ADDWF  x25,W
0273A:  MOVWF  FE9
0273C:  MOVLW  00
0273E:  ADDWFC x26,W
02740:  MOVWF  FEA
02742:  CLRF   FEC
02744:  MOVF   FED,F
02746:  MOVLW  1E
02748:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
0274A:  MOVLW  0D
0274C:  ADDWF  x11,W
0274E:  MOVWF  FE9
02750:  MOVLW  00
02752:  ADDWFC x12,W
02754:  MOVWF  FEA
02756:  BTFSS  FEF.2
02758:  BRA    2796
....................    { 
....................       MACDiscardRx(); 
0275A:  MOVLB  0
0275C:  CALL   0C30
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
02760:  MOVLB  2
02762:  MOVFF  225,01
02766:  MOVFF  226,03
0276A:  MOVFF  225,22C
0276E:  MOVFF  226,22D
02772:  MOVLW  23
02774:  ADDWF  x25,W
02776:  MOVWF  FE9
02778:  MOVLW  00
0277A:  ADDWFC x26,W
0277C:  MOVWF  FEA
0277E:  BTFSS  FEF.0
02780:  BRA    2786
02782:  MOVLW  00
02784:  BRA    2788
02786:  MOVLW  01
02788:  MOVFF  22D,FEA
0278C:  MOVFF  22C,FE9
02790:  MOVWF  FEF
....................       return; 
02792:  GOTO   31D2
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
02796:  MOVLW  16
02798:  ADDWF  x25,W
0279A:  MOVWF  FE9
0279C:  MOVLW  00
0279E:  ADDWFC x26,W
027A0:  MOVWF  FEA
027A2:  MOVFF  FEF,00
027A6:  MOVFF  FEC,01
027AA:  MOVFF  FEC,02
027AE:  MOVFF  FEC,03
027B2:  MOVFF  03,21C
027B6:  MOVFF  02,21B
027BA:  MOVFF  01,21A
027BE:  MOVFF  00,219
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
027C2:  MOVLW  0E
027C4:  ADDWF  x11,W
027C6:  MOVWF  FE9
027C8:  MOVLW  00
027CA:  ADDWFC x12,W
027CC:  MOVWF  FEA
027CE:  MOVFF  FEC,03
027D2:  MOVF   FED,F
027D4:  MOVFF  FEF,22C
027D8:  MOVFF  03,22D
027DC:  CLRF   x2E
027DE:  CLRF   x2F
027E0:  MOVLW  08
027E2:  ADDWF  x11,W
027E4:  MOVWF  FE9
027E6:  MOVLW  00
027E8:  ADDWFC x12,W
027EA:  MOVWF  FEA
027EC:  MOVFF  FEF,00
027F0:  MOVFF  FEC,01
027F4:  MOVFF  FEC,02
027F8:  MOVFF  FEC,03
027FC:  MOVF   00,W
027FE:  SUBWF  x19,W
02800:  MOVWF  00
02802:  MOVF   01,W
02804:  SUBWFB x1A,W
02806:  MOVWF  01
02808:  MOVF   02,W
0280A:  SUBWFB x1B,W
0280C:  MOVWF  02
0280E:  MOVF   03,W
02810:  SUBWFB x1C,W
02812:  MOVWF  03
02814:  MOVF   00,W
02816:  SUBWF  x2C,W
02818:  MOVWF  x30
0281A:  MOVF   01,W
0281C:  SUBWFB x2D,W
0281E:  MOVWF  x31
02820:  MOVF   02,W
02822:  SUBWFB x2E,W
02824:  MOVWF  x32
02826:  MOVF   03,W
02828:  SUBWFB x2F,W
0282A:  MOVWF  x33
0282C:  MOVLW  10
0282E:  ADDWF  x25,W
02830:  MOVWF  FE9
02832:  MOVLW  00
02834:  ADDWFC x26,W
02836:  MOVWF  FEA
02838:  MOVFF  FEC,03
0283C:  MOVF   FED,F
0283E:  MOVFF  FEF,00
02842:  MOVFF  03,01
02846:  CLRF   02
02848:  CLRF   03
0284A:  MOVF   00,W
0284C:  SUBWF  x30,W
0284E:  MOVWF  x28
02850:  MOVF   01,W
02852:  SUBWFB x31,W
02854:  MOVWF  x29
02856:  MOVF   02,W
02858:  SUBWFB x32,W
0285A:  MOVWF  x2A
0285C:  MOVF   03,W
0285E:  SUBWFB x33,W
02860:  MOVWF  x2B
....................    if(temp < 0) 
02862:  BTFSC  x2B.7
02864:  BRA    2868
02866:  BRA    287C
....................    { 
....................       ps->RemoteWindow = 0; 
02868:  MOVLW  14
0286A:  ADDWF  x25,W
0286C:  MOVWF  FE9
0286E:  MOVLW  00
02870:  ADDWFC x26,W
02872:  MOVWF  FEA
02874:  CLRF   FEC
02876:  MOVF   FED,F
02878:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
....................    else 
0287A:  BRA    2890
....................    { 
....................       ps->RemoteWindow = ack; 
0287C:  MOVLW  14
0287E:  ADDWF  x25,W
02880:  MOVWF  FE9
02882:  MOVLW  00
02884:  ADDWFC x26,W
02886:  MOVWF  FEA
02888:  MOVFF  215,FEF
0288C:  MOVFF  216,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
02890:  MOVFF  225,FE9
02894:  MOVFF  226,FEA
02898:  DECFSZ FEF,W
0289A:  BRA    2A22
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
0289C:  MOVLW  0D
0289E:  ADDWF  x11,W
028A0:  MOVWF  FE9
028A2:  MOVLW  00
028A4:  ADDWFC x12,W
028A6:  MOVWF  FEA
028A8:  BTFSC  FEF.1
028AA:  BRA    28D0
....................       { 
....................          MACDiscardRx(); 
028AC:  MOVLB  0
028AE:  CALL   0C30
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
028B2:  MOVLW  0D
028B4:  MOVLB  2
028B6:  ADDWF  x11,W
028B8:  MOVWF  FE9
028BA:  MOVLW  00
028BC:  ADDWFC x12,W
028BE:  MOVWF  FEA
028C0:  BTFSS  FEF.4
028C2:  BRA    28CC
....................           { 
....................             flags = RST; 
028C4:  MOVLW  04
028C6:  MOVWF  x27
....................             goto SendTCPControlPacket; 
028C8:  GOTO   315A
....................            } 
....................  
....................          return; 
028CC:  GOTO   31D2
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
028D0:  MOVLW  1A
028D2:  ADDWF  x25,W
028D4:  MOVWF  01
028D6:  MOVLW  00
028D8:  ADDWFC x26,W
028DA:  MOVFF  01,22C
028DE:  MOVWF  x2D
028E0:  MOVLW  04
028E2:  ADDWF  x11,W
028E4:  MOVWF  FE9
028E6:  MOVLW  00
028E8:  ADDWFC x12,W
028EA:  MOVWF  FEA
028EC:  MOVFF  FEF,22E
028F0:  MOVFF  FEC,22F
028F4:  MOVFF  FEC,230
028F8:  MOVFF  FEC,231
028FC:  MOVF   x13,W
028FE:  ADDWF  x2E,W
02900:  MOVWF  x32
02902:  MOVF   x14,W
02904:  ADDWFC x2F,W
02906:  MOVWF  x33
02908:  MOVLW  00
0290A:  ADDWFC x30,W
0290C:  MOVWF  x34
0290E:  MOVLW  00
02910:  ADDWFC x31,W
02912:  MOVWF  x35
02914:  MOVLW  01
02916:  ADDWF  x32,W
02918:  MOVWF  00
0291A:  MOVLW  00
0291C:  ADDWFC x33,W
0291E:  MOVWF  01
02920:  MOVLW  00
02922:  ADDWFC x34,W
02924:  MOVWF  02
02926:  MOVLW  00
02928:  ADDWFC x35,W
0292A:  MOVFF  22D,FEA
0292E:  MOVFF  22C,FE9
02932:  MOVFF  00,FEF
02936:  MOVFF  01,FEC
0293A:  MOVFF  02,FEC
0293E:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
02940:  MOVLW  1A
02942:  ADDWF  x25,W
02944:  MOVWF  FE9
02946:  MOVLW  00
02948:  ADDWFC x26,W
0294A:  MOVWF  FEA
0294C:  MOVFF  FEF,00
02950:  MOVFF  FEC,01
02954:  MOVFF  FEC,02
02958:  MOVFF  FEC,03
0295C:  MOVFF  03,218
02960:  MOVFF  02,217
02964:  MOVFF  01,216
02968:  MOVFF  00,215
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
0296C:  MOVLW  0D
0296E:  ADDWF  x11,W
02970:  MOVWF  FE9
02972:  MOVLW  00
02974:  ADDWFC x12,W
02976:  MOVWF  FEA
02978:  BTFSC  FEF.4
0297A:  BRA    2998
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
0297C:  MOVFF  225,FE9
02980:  MOVFF  226,FEA
02984:  MOVLW  02
02986:  MOVWF  FEF
....................          MACDiscardRx(); 
02988:  MOVLB  0
0298A:  CALL   0C30
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
0298E:  MOVLW  12
02990:  MOVLB  2
02992:  MOVWF  x27
....................          goto SendTCPControlPacket; 
02994:  GOTO   315A
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
02998:  MOVFF  225,FE9
0299C:  MOVFF  226,FEA
029A0:  MOVLW  03
029A2:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
029A4:  MOVLW  10
029A6:  MOVWF  x27
....................  
....................       ps->RemoteWindow = h->Window; 
029A8:  MOVLW  14
029AA:  ADDWF  x25,W
029AC:  MOVWF  01
029AE:  MOVLW  00
029B0:  ADDWFC x26,W
029B2:  MOVWF  03
029B4:  MOVWF  x2D
029B6:  MOVLW  0E
029B8:  ADDWF  x11,W
029BA:  MOVWF  FE9
029BC:  MOVLW  00
029BE:  ADDWFC x12,W
029C0:  MOVWF  FEA
029C2:  MOVFF  FEC,03
029C6:  MOVF   FED,F
029C8:  MOVFF  FEF,22E
029CC:  MOVFF  22D,FEA
029D0:  MOVFF  01,FE9
029D4:  MOVFF  03,FEC
029D8:  MOVF   FED,F
029DA:  MOVFF  22E,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
029DE:  MOVF   x13,W
029E0:  IORWF  x14,W
029E2:  BZ    2A18
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
029E4:  MOVLW  23
029E6:  ADDWF  x25,W
029E8:  MOVWF  FE9
029EA:  MOVLW  00
029EC:  ADDWFC x26,W
029EE:  MOVWF  FEA
029F0:  BSF    FEF.3
....................          ps->RxCount             = len; 
029F2:  MOVLW  12
029F4:  ADDWF  x25,W
029F6:  MOVWF  FE9
029F8:  MOVLW  00
029FA:  ADDWFC x26,W
029FC:  MOVWF  FEA
029FE:  MOVFF  214,FEC
02A02:  MOVF   FED,F
02A04:  MOVFF  213,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
02A08:  MOVLW  23
02A0A:  ADDWF  x25,W
02A0C:  MOVWF  FE9
02A0E:  MOVLW  00
02A10:  ADDWFC x26,W
02A12:  MOVWF  FEA
02A14:  BSF    FEF.2
....................       } 
....................       else   // No application data in this packet 
02A16:  BRA    2A20
....................       { 
....................          MACDiscardRx(); 
02A18:  MOVLB  0
02A1A:  CALL   0C30
02A1E:  MOVLB  2
....................       } 
....................       goto SendTCPControlPacket; 
02A20:  BRA    315A
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
02A22:  MOVFF  225,FE9
02A26:  MOVFF  226,FEA
02A2A:  MOVF   FEF,F
02A2C:  BTFSS  FD8.2
02A2E:  BRA    2BC6
....................    { 
....................       MACDiscardRx(); 
02A30:  MOVLB  0
02A32:  CALL   0C30
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
02A36:  MOVLW  0D
02A38:  MOVLB  2
02A3A:  ADDWF  x11,W
02A3C:  MOVWF  FE9
02A3E:  MOVLW  00
02A40:  ADDWFC x12,W
02A42:  MOVWF  FEA
02A44:  BTFSC  FEF.1
02A46:  BRA    2A4E
....................       { 
....................          flags = RST; 
02A48:  MOVLW  04
02A4A:  MOVWF  x27
....................          goto SendTCPControlPacket; 
02A4C:  BRA    315A
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
02A4E:  MOVLW  1A
02A50:  ADDWF  x25,W
02A52:  MOVWF  01
02A54:  MOVLW  00
02A56:  ADDWFC x26,W
02A58:  MOVFF  01,22C
02A5C:  MOVWF  x2D
02A5E:  MOVLW  04
02A60:  ADDWF  x11,W
02A62:  MOVWF  FE9
02A64:  MOVLW  00
02A66:  ADDWFC x12,W
02A68:  MOVWF  FEA
02A6A:  MOVFF  FEF,22E
02A6E:  MOVFF  FEC,22F
02A72:  MOVFF  FEC,230
02A76:  MOVFF  FEC,231
02A7A:  MOVF   x13,W
02A7C:  ADDWF  x2E,W
02A7E:  MOVWF  x32
02A80:  MOVF   x14,W
02A82:  ADDWFC x2F,W
02A84:  MOVWF  x33
02A86:  MOVLW  00
02A88:  ADDWFC x30,W
02A8A:  MOVWF  x34
02A8C:  MOVLW  00
02A8E:  ADDWFC x31,W
02A90:  MOVWF  x35
02A92:  MOVLW  01
02A94:  ADDWF  x32,W
02A96:  MOVWF  00
02A98:  MOVLW  00
02A9A:  ADDWFC x33,W
02A9C:  MOVWF  01
02A9E:  MOVLW  00
02AA0:  ADDWFC x34,W
02AA2:  MOVWF  02
02AA4:  MOVLW  00
02AA6:  ADDWFC x35,W
02AA8:  MOVFF  22D,FEA
02AAC:  MOVFF  22C,FE9
02AB0:  MOVFF  00,FEF
02AB4:  MOVFF  01,FEC
02AB8:  MOVFF  02,FEC
02ABC:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
02ABE:  MOVLW  14
02AC0:  ADDWF  x25,W
02AC2:  MOVWF  01
02AC4:  MOVLW  00
02AC6:  ADDWFC x26,W
02AC8:  MOVWF  03
02ACA:  MOVWF  x2D
02ACC:  MOVLW  0E
02ACE:  ADDWF  x11,W
02AD0:  MOVWF  FE9
02AD2:  MOVLW  00
02AD4:  ADDWFC x12,W
02AD6:  MOVWF  FEA
02AD8:  MOVFF  FEC,03
02ADC:  MOVF   FED,F
02ADE:  MOVFF  FEF,22E
02AE2:  MOVFF  22D,FEA
02AE6:  MOVFF  01,FE9
02AEA:  MOVFF  03,FEC
02AEE:  MOVF   FED,F
02AF0:  MOVFF  22E,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
02AF4:  MOVLW  01
02AF6:  ADDWF  x25,W
02AF8:  MOVWF  x2C
02AFA:  MOVLW  00
02AFC:  ADDWFC x26,W
02AFE:  MOVWF  x2D
02B00:  MOVWF  FEA
02B02:  MOVFF  22C,FE9
02B06:  MOVFF  210,FE2
02B0A:  MOVFF  20F,FE1
02B0E:  MOVLW  0A
02B10:  MOVWF  01
02B12:  MOVFF  FE6,FEE
02B16:  DECFSZ 01,F
02B18:  BRA    2B12
....................       ps->remotePort = h->SourcePort; 
02B1A:  MOVLW  0D
02B1C:  ADDWF  x25,W
02B1E:  MOVWF  01
02B20:  MOVLW  00
02B22:  ADDWFC x26,W
02B24:  MOVFF  211,FE9
02B28:  MOVFF  212,FEA
02B2C:  MOVFF  FEC,03
02B30:  MOVF   FED,F
02B32:  MOVFF  FEF,22E
02B36:  MOVWF  FEA
02B38:  MOVFF  01,FE9
02B3C:  MOVFF  03,FEC
02B40:  MOVF   FED,F
02B42:  MOVFF  22E,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
02B46:  MOVFF  225,FE9
02B4A:  MOVFF  226,FEA
02B4E:  MOVLW  02
02B50:  MOVWF  FEF
....................       seq = ps->SND_SEQ++; 
02B52:  MOVLW  16
02B54:  ADDWF  x25,W
02B56:  MOVWF  FE9
02B58:  MOVLW  00
02B5A:  ADDWFC x26,W
02B5C:  MOVWF  FEA
02B5E:  MOVF   FEE,F
02B60:  MOVF   FEE,F
02B62:  MOVF   FEE,F
02B64:  MOVFF  FED,03
02B68:  MOVFF  FED,02
02B6C:  MOVFF  FED,01
02B70:  MOVFF  FEF,00
02B74:  MOVLW  01
02B76:  ADDWF  FEE,F
02B78:  BNZ   2B84
02B7A:  INCF   FEE,F
02B7C:  BNZ   2B84
02B7E:  INCF   FEE,F
02B80:  BNZ   2B84
02B82:  INCF   FED,F
02B84:  MOVFF  03,21C
02B88:  MOVFF  02,21B
02B8C:  MOVFF  01,21A
02B90:  MOVFF  00,219
....................       ack =  ps->SND_ACK; 
02B94:  MOVLW  1A
02B96:  ADDWF  x25,W
02B98:  MOVWF  FE9
02B9A:  MOVLW  00
02B9C:  ADDWFC x26,W
02B9E:  MOVWF  FEA
02BA0:  MOVFF  FEF,00
02BA4:  MOVFF  FEC,01
02BA8:  MOVFF  FEC,02
02BAC:  MOVFF  FEC,03
02BB0:  MOVFF  03,218
02BB4:  MOVFF  02,217
02BB8:  MOVFF  01,216
02BBC:  MOVFF  00,215
....................       flags = SYN | ACK; 
02BC0:  MOVLW  12
02BC2:  MOVWF  x27
....................       goto SendTCPControlPacket; 
02BC4:  BRA    315A
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
02BC6:  MOVLW  1A
02BC8:  ADDWF  x25,W
02BCA:  MOVWF  FE9
02BCC:  MOVLW  00
02BCE:  ADDWFC x26,W
02BD0:  MOVWF  FEA
02BD2:  MOVFF  FEF,00
02BD6:  MOVFF  FEC,01
02BDA:  MOVFF  FEC,02
02BDE:  MOVFF  FEC,03
02BE2:  MOVFF  03,220
02BE6:  MOVFF  02,21F
02BEA:  MOVFF  01,21E
02BEE:  MOVFF  00,21D
....................    prevSeq = ps->SND_SEQ; 
02BF2:  MOVLW  16
02BF4:  ADDWF  x25,W
02BF6:  MOVWF  FE9
02BF8:  MOVLW  00
02BFA:  ADDWFC x26,W
02BFC:  MOVWF  FEA
02BFE:  MOVFF  FEF,00
02C02:  MOVFF  FEC,01
02C06:  MOVFF  FEC,02
02C0A:  MOVFF  FEC,03
02C0E:  MOVFF  03,224
02C12:  MOVFF  02,223
02C16:  MOVFF  01,222
02C1A:  MOVFF  00,221
....................  
....................    ack = h->SeqNumber; 
02C1E:  MOVLW  04
02C20:  ADDWF  x11,W
02C22:  MOVWF  FE9
02C24:  MOVLW  00
02C26:  ADDWFC x12,W
02C28:  MOVWF  FEA
02C2A:  MOVFF  FEF,00
02C2E:  MOVFF  FEC,01
02C32:  MOVFF  FEC,02
02C36:  MOVFF  FEC,03
02C3A:  MOVFF  03,218
02C3E:  MOVFF  02,217
02C42:  MOVFF  01,216
02C46:  MOVFF  00,215
....................    ack += (DWORD)len; 
02C4A:  CLRF   02
02C4C:  CLRF   03
02C4E:  MOVF   x13,W
02C50:  ADDWF  x15,F
02C52:  MOVF   x14,W
02C54:  ADDWFC x16,F
02C56:  MOVF   02,W
02C58:  ADDWFC x17,F
02C5A:  MOVF   03,W
02C5C:  ADDWFC x18,F
....................    seq = ps->SND_SEQ; 
02C5E:  MOVLW  16
02C60:  ADDWF  x25,W
02C62:  MOVWF  FE9
02C64:  MOVLW  00
02C66:  ADDWFC x26,W
02C68:  MOVWF  FEA
02C6A:  MOVFF  FEF,00
02C6E:  MOVFF  FEC,01
02C72:  MOVFF  FEC,02
02C76:  MOVFF  FEC,03
02C7A:  MOVFF  03,21C
02C7E:  MOVFF  02,21B
02C82:  MOVFF  01,21A
02C86:  MOVFF  00,219
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
02C8A:  MOVLW  04
02C8C:  ADDWF  x11,W
02C8E:  MOVWF  FE9
02C90:  MOVLW  00
02C92:  ADDWFC x12,W
02C94:  MOVWF  FEA
02C96:  MOVFF  FEF,22C
02C9A:  MOVFF  FEC,22D
02C9E:  MOVFF  FEC,22E
02CA2:  MOVFF  FEC,22F
02CA6:  MOVF   x1D,W
02CA8:  SUBWF  x2C,W
02CAA:  BTFSS  FD8.2
02CAC:  BRA    313E
02CAE:  MOVF   x1E,W
02CB0:  SUBWF  x2D,W
02CB2:  BTFSS  FD8.2
02CB4:  BRA    313E
02CB6:  MOVF   x1F,W
02CB8:  SUBWF  x2E,W
02CBA:  BTFSS  FD8.2
02CBC:  BRA    313E
02CBE:  MOVF   x20,W
02CC0:  SUBWF  x2F,W
02CC2:  BTFSS  FD8.2
02CC4:  BRA    313E
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
02CC6:  MOVFF  225,FE9
02CCA:  MOVFF  226,FEA
02CCE:  MOVF   FEF,W
02CD0:  SUBLW  02
02CD2:  BNZ   2D5A
....................          { 
....................             if(h->Flags.bits.flagACK) 
02CD4:  MOVLW  0D
02CD6:  ADDWF  x11,W
02CD8:  MOVWF  FE9
02CDA:  MOVLW  00
02CDC:  ADDWFC x12,W
02CDE:  MOVWF  FEA
02CE0:  BTFSS  FEF.4
02CE2:  BRA    2D50
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
02CE4:  MOVLW  1A
02CE6:  ADDWF  x25,W
02CE8:  MOVWF  FE9
02CEA:  MOVLW  00
02CEC:  ADDWFC x26,W
02CEE:  MOVWF  FEA
02CF0:  MOVFF  215,FEF
02CF4:  MOVFF  216,FEC
02CF8:  MOVFF  217,FEC
02CFC:  MOVFF  218,FEC
....................                ps->smState = TCP_ESTABLISHED; 
02D00:  MOVFF  225,FE9
02D04:  MOVFF  226,FEA
02D08:  MOVLW  03
02D0A:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
02D0C:  MOVF   x13,W
02D0E:  IORWF  x14,W
02D10:  BZ    2D46
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
02D12:  MOVLW  23
02D14:  ADDWF  x25,W
02D16:  MOVWF  FE9
02D18:  MOVLW  00
02D1A:  ADDWFC x26,W
02D1C:  MOVWF  FEA
02D1E:  BSF    FEF.3
....................                   ps->RxCount             = len; 
02D20:  MOVLW  12
02D22:  ADDWF  x25,W
02D24:  MOVWF  FE9
02D26:  MOVLW  00
02D28:  ADDWFC x26,W
02D2A:  MOVWF  FEA
02D2C:  MOVFF  214,FEC
02D30:  MOVF   FED,F
02D32:  MOVFF  213,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
02D36:  MOVLW  23
02D38:  ADDWF  x25,W
02D3A:  MOVWF  FE9
02D3C:  MOVLW  00
02D3E:  ADDWFC x26,W
02D40:  MOVWF  FEA
02D42:  BSF    FEF.2
....................                } 
....................                else 
02D44:  BRA    2D4E
....................                   MACDiscardRx(); 
02D46:  MOVLB  0
02D48:  CALL   0C30
02D4C:  MOVLB  2
....................             } 
....................             else   // No ACK to our SYN 
02D4E:  BRA    2D58
....................             { 
....................                MACDiscardRx(); 
02D50:  MOVLB  0
02D52:  CALL   0C30
02D56:  MOVLB  2
....................             } 
....................          } 
....................          // Connection is established, closing, or otherwise 
....................          else 
02D58:  BRA    313C
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
02D5A:  MOVLW  1A
02D5C:  ADDWF  x25,W
02D5E:  MOVWF  FE9
02D60:  MOVLW  00
02D62:  ADDWFC x26,W
02D64:  MOVWF  FEA
02D66:  MOVFF  215,FEF
02D6A:  MOVFF  216,FEC
02D6E:  MOVFF  217,FEC
02D72:  MOVFF  218,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
02D76:  MOVFF  225,FE9
02D7A:  MOVFF  226,FEA
02D7E:  MOVF   FEF,W
02D80:  SUBLW  03
02D82:  BTFSS  FD8.2
02D84:  BRA    2F4E
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
02D86:  MOVLW  0D
02D88:  ADDWF  x11,W
02D8A:  MOVWF  FE9
02D8C:  MOVLW  00
02D8E:  ADDWFC x12,W
02D90:  MOVWF  FEA
02D92:  BTFSS  FEF.4
02D94:  BRA    2DF2
02D96:  MOVLW  23
02D98:  ADDWF  x25,W
02D9A:  MOVWF  FE9
02D9C:  MOVLW  00
02D9E:  ADDWFC x26,W
02DA0:  MOVWF  FEA
02DA2:  BTFSC  FEF.1
02DA4:  BRA    2DF2
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
02DA6:  MOVLW  0F
02DA8:  ADDWF  x25,W
02DAA:  MOVWF  FE9
02DAC:  MOVLW  00
02DAE:  ADDWFC x26,W
02DB0:  MOVWF  FEA
02DB2:  INCFSZ FEF,W
02DB4:  BRA    2DB8
02DB6:  BRA    2DF2
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
02DB8:  MOVLW  0F
02DBA:  ADDWF  x25,W
02DBC:  MOVWF  FE9
02DBE:  MOVLW  00
02DC0:  ADDWFC x26,W
02DC2:  MOVWF  FEA
02DC4:  MOVFF  FEF,22C
02DC8:  MOVFF  22C,22F
02DCC:  MOVLB  0
02DCE:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
02DD2:  MOVLW  0F
02DD4:  MOVLB  2
02DD6:  ADDWF  x25,W
02DD8:  MOVWF  FE9
02DDA:  MOVLW  00
02DDC:  ADDWFC x26,W
02DDE:  MOVWF  FEA
02DE0:  MOVLW  FF
02DE2:  MOVWF  FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
02DE4:  MOVLW  23
02DE6:  ADDWF  x25,W
02DE8:  MOVWF  FE9
02DEA:  MOVLW  00
02DEC:  ADDWFC x26,W
02DEE:  MOVWF  FEA
02DF0:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
02DF2:  MOVLW  0D
02DF4:  ADDWF  x11,W
02DF6:  MOVWF  FE9
02DF8:  MOVLW  00
02DFA:  ADDWFC x12,W
02DFC:  MOVWF  FEA
02DFE:  BTFSS  FEF.0
02E00:  BRA    2EB6
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
02E02:  MOVLW  11
02E04:  MOVWF  x27
....................                   seq = ps->SND_SEQ++; 
02E06:  MOVLW  16
02E08:  ADDWF  x25,W
02E0A:  MOVWF  FE9
02E0C:  MOVLW  00
02E0E:  ADDWFC x26,W
02E10:  MOVWF  FEA
02E12:  MOVF   FEE,F
02E14:  MOVF   FEE,F
02E16:  MOVF   FEE,F
02E18:  MOVFF  FED,03
02E1C:  MOVFF  FED,02
02E20:  MOVFF  FED,01
02E24:  MOVFF  FEF,00
02E28:  MOVLW  01
02E2A:  ADDWF  FEE,F
02E2C:  BNZ   2E38
02E2E:  INCF   FEE,F
02E30:  BNZ   2E38
02E32:  INCF   FEE,F
02E34:  BNZ   2E38
02E36:  INCF   FED,F
02E38:  MOVFF  03,21C
02E3C:  MOVFF  02,21B
02E40:  MOVFF  01,21A
02E44:  MOVFF  00,219
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
02E48:  MOVLW  1A
02E4A:  ADDWF  x25,W
02E4C:  MOVWF  FE9
02E4E:  MOVLW  00
02E50:  ADDWFC x26,W
02E52:  MOVWF  FEA
02E54:  MOVLW  01
02E56:  ADDWF  FEF,W
02E58:  MOVWF  00
02E5A:  MOVLW  00
02E5C:  ADDWFC FEC,W
02E5E:  MOVWF  01
02E60:  MOVLW  00
02E62:  ADDWFC FEC,W
02E64:  MOVWF  02
02E66:  MOVLW  00
02E68:  ADDWFC FEC,W
02E6A:  MOVF   FED,F
02E6C:  MOVF   FED,F
02E6E:  MOVF   FED,F
02E70:  MOVFF  00,FEF
02E74:  MOVFF  01,FEC
02E78:  MOVFF  02,FEC
02E7C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
02E7E:  MOVLW  1A
02E80:  ADDWF  x25,W
02E82:  MOVWF  FE9
02E84:  MOVLW  00
02E86:  ADDWFC x26,W
02E88:  MOVWF  FEA
02E8A:  MOVFF  FEF,00
02E8E:  MOVFF  FEC,01
02E92:  MOVFF  FEC,02
02E96:  MOVFF  FEC,03
02E9A:  MOVFF  03,218
02E9E:  MOVFF  02,217
02EA2:  MOVFF  01,216
02EA6:  MOVFF  00,215
....................                   ps->smState = TCP_LAST_ACK; 
02EAA:  MOVFF  225,FE9
02EAE:  MOVFF  226,FEA
02EB2:  MOVLW  09
02EB4:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
02EB6:  MOVF   x13,W
02EB8:  IORWF  x14,W
02EBA:  BZ    2F44
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
02EBC:  MOVLW  23
02EBE:  ADDWF  x25,W
02EC0:  MOVWF  FE9
02EC2:  MOVLW  00
02EC4:  ADDWFC x26,W
02EC6:  MOVWF  FEA
02EC8:  BTFSC  FEF.3
02ECA:  BRA    2F02
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
02ECC:  MOVLW  23
02ECE:  ADDWF  x25,W
02ED0:  MOVWF  FE9
02ED2:  MOVLW  00
02ED4:  ADDWFC x26,W
02ED6:  MOVWF  FEA
02ED8:  BSF    FEF.3
....................                      ps->RxCount             = len; 
02EDA:  MOVLW  12
02EDC:  ADDWF  x25,W
02EDE:  MOVWF  FE9
02EE0:  MOVLW  00
02EE2:  ADDWFC x26,W
02EE4:  MOVWF  FEA
02EE6:  MOVFF  214,FEC
02EEA:  MOVF   FED,F
02EEC:  MOVFF  213,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
02EF0:  MOVLW  23
02EF2:  ADDWF  x25,W
02EF4:  MOVWF  FE9
02EF6:  MOVLW  00
02EF8:  ADDWFC x26,W
02EFA:  MOVWF  FEA
02EFC:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
02EFE:  BSF    x27.4
....................                   } 
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
02F00:  BRA    2F42
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
02F02:  MOVLW  16
02F04:  ADDWF  x25,W
02F06:  MOVWF  FE9
02F08:  MOVLW  00
02F0A:  ADDWFC x26,W
02F0C:  MOVWF  FEA
02F0E:  MOVFF  221,FEF
02F12:  MOVFF  222,FEC
02F16:  MOVFF  223,FEC
02F1A:  MOVFF  224,FEC
....................                      ps->SND_ACK = prevAck; 
02F1E:  MOVLW  1A
02F20:  ADDWF  x25,W
02F22:  MOVWF  FE9
02F24:  MOVLW  00
02F26:  ADDWFC x26,W
02F28:  MOVWF  FEA
02F2A:  MOVFF  21D,FEF
02F2E:  MOVFF  21E,FEC
02F32:  MOVFF  21F,FEC
02F36:  MOVFF  220,FEC
....................  
....................                      MACDiscardRx(); 
02F3A:  MOVLB  0
02F3C:  CALL   0C30
02F40:  MOVLB  2
....................                   } 
....................                } 
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
02F42:  BRA    2F4C
....................                { 
....................                   MACDiscardRx(); 
02F44:  MOVLB  0
02F46:  CALL   0C30
02F4A:  MOVLB  2
....................                } 
....................             } 
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
02F4C:  BRA    313C
02F4E:  MOVFF  225,FE9
02F52:  MOVFF  226,FEA
02F56:  MOVF   FEF,W
02F58:  SUBLW  09
02F5A:  BNZ   2F86
....................             { 
....................                MACDiscardRx(); 
02F5C:  MOVLB  0
02F5E:  CALL   0C30
....................  
....................                if(h->Flags.bits.flagACK) 
02F62:  MOVLW  0D
02F64:  MOVLB  2
02F66:  ADDWF  x11,W
02F68:  MOVWF  FE9
02F6A:  MOVLW  00
02F6C:  ADDWFC x12,W
02F6E:  MOVWF  FEA
02F70:  BTFSS  FEF.4
02F72:  BRA    2F84
....................                { 
....................                   CloseSocket(ps); 
02F74:  MOVFF  226,22D
02F78:  MOVFF  225,22C
02F7C:  MOVLB  0
02F7E:  CALL   2068
02F82:  MOVLB  2
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
02F84:  BRA    313C
02F86:  MOVFF  225,FE9
02F8A:  MOVFF  226,FEA
02F8E:  MOVF   FEF,W
02F90:  SUBLW  04
02F92:  BNZ   3068
....................             { 
....................                MACDiscardRx(); 
02F94:  MOVLB  0
02F96:  CALL   0C30
....................  
....................                if(h->Flags.bits.flagFIN) 
02F9A:  MOVLW  0D
02F9C:  MOVLB  2
02F9E:  ADDWF  x11,W
02FA0:  MOVWF  FE9
02FA2:  MOVLW  00
02FA4:  ADDWFC x12,W
02FA6:  MOVWF  FEA
02FA8:  BTFSS  FEF.0
02FAA:  BRA    3046
....................                { 
....................                   flags = ACK; 
02FAC:  MOVLW  10
02FAE:  MOVWF  x27
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
02FB0:  MOVLW  1A
02FB2:  ADDWF  x25,W
02FB4:  MOVWF  FE9
02FB6:  MOVLW  00
02FB8:  ADDWFC x26,W
02FBA:  MOVWF  FEA
02FBC:  MOVLW  01
02FBE:  ADDWF  FEF,W
02FC0:  MOVWF  00
02FC2:  MOVLW  00
02FC4:  ADDWFC FEC,W
02FC6:  MOVWF  01
02FC8:  MOVLW  00
02FCA:  ADDWFC FEC,W
02FCC:  MOVWF  02
02FCE:  MOVLW  00
02FD0:  ADDWFC FEC,W
02FD2:  MOVF   FED,F
02FD4:  MOVF   FED,F
02FD6:  MOVF   FED,F
02FD8:  MOVFF  00,FEF
02FDC:  MOVFF  01,FEC
02FE0:  MOVFF  02,FEC
02FE4:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
02FE6:  MOVLW  1A
02FE8:  ADDWF  x25,W
02FEA:  MOVWF  FE9
02FEC:  MOVLW  00
02FEE:  ADDWFC x26,W
02FF0:  MOVWF  FEA
02FF2:  MOVFF  FEF,00
02FF6:  MOVFF  FEC,01
02FFA:  MOVFF  FEC,02
02FFE:  MOVFF  FEC,03
03002:  MOVFF  03,218
03006:  MOVFF  02,217
0300A:  MOVFF  01,216
0300E:  MOVFF  00,215
....................                   if(h->Flags.bits.flagACK) 
03012:  MOVLW  0D
03014:  ADDWF  x11,W
03016:  MOVWF  FE9
03018:  MOVLW  00
0301A:  ADDWFC x12,W
0301C:  MOVWF  FEA
0301E:  BTFSS  FEF.4
03020:  BRA    3034
....................                   { 
....................                      CloseSocket(ps); 
03022:  MOVFF  226,22D
03026:  MOVFF  225,22C
0302A:  MOVLB  0
0302C:  CALL   2068
....................                   } 
....................                   else 
03030:  BRA    3042
03032:  MOVLB  2
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
03034:  MOVFF  225,FE9
03038:  MOVFF  226,FEA
0303C:  MOVLW  06
0303E:  MOVWF  FEF
03040:  MOVLB  0
....................                   } 
....................                } 
....................                else if(h->Flags.bits.flagACK) 
03042:  BRA    3064
03044:  MOVLB  2
03046:  MOVLW  0D
03048:  ADDWF  x11,W
0304A:  MOVWF  FE9
0304C:  MOVLW  00
0304E:  ADDWFC x12,W
03050:  MOVWF  FEA
03052:  BTFSS  FEF.4
03054:  BRA    3062
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
03056:  MOVFF  225,FE9
0305A:  MOVFF  226,FEA
0305E:  MOVLW  05
03060:  MOVWF  FEF
03062:  MOVLB  0
....................                } 
....................             } 
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
03064:  BRA    313A
03066:  MOVLB  2
03068:  MOVFF  225,FE9
0306C:  MOVFF  226,FEA
03070:  MOVF   FEF,W
03072:  SUBLW  05
03074:  BNZ   3106
....................             { 
....................                MACDiscardRx(); 
03076:  MOVLB  0
03078:  CALL   0C30
....................  
....................                if(h->Flags.bits.flagFIN) 
0307C:  MOVLW  0D
0307E:  MOVLB  2
03080:  ADDWF  x11,W
03082:  MOVWF  FE9
03084:  MOVLW  00
03086:  ADDWFC x12,W
03088:  MOVWF  FEA
0308A:  BTFSS  FEF.0
0308C:  BRA    3104
....................                { 
....................                   flags = ACK; 
0308E:  MOVLW  10
03090:  MOVWF  x27
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03092:  MOVLW  1A
03094:  ADDWF  x25,W
03096:  MOVWF  FE9
03098:  MOVLW  00
0309A:  ADDWFC x26,W
0309C:  MOVWF  FEA
0309E:  MOVLW  01
030A0:  ADDWF  FEF,W
030A2:  MOVWF  00
030A4:  MOVLW  00
030A6:  ADDWFC FEC,W
030A8:  MOVWF  01
030AA:  MOVLW  00
030AC:  ADDWFC FEC,W
030AE:  MOVWF  02
030B0:  MOVLW  00
030B2:  ADDWFC FEC,W
030B4:  MOVF   FED,F
030B6:  MOVF   FED,F
030B8:  MOVF   FED,F
030BA:  MOVFF  00,FEF
030BE:  MOVFF  01,FEC
030C2:  MOVFF  02,FEC
030C6:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
030C8:  MOVLW  1A
030CA:  ADDWF  x25,W
030CC:  MOVWF  FE9
030CE:  MOVLW  00
030D0:  ADDWFC x26,W
030D2:  MOVWF  FEA
030D4:  MOVFF  FEF,00
030D8:  MOVFF  FEC,01
030DC:  MOVFF  FEC,02
030E0:  MOVFF  FEC,03
030E4:  MOVFF  03,218
030E8:  MOVFF  02,217
030EC:  MOVFF  01,216
030F0:  MOVFF  00,215
....................                   CloseSocket(ps); 
030F4:  MOVFF  226,22D
030F8:  MOVFF  225,22C
030FC:  MOVLB  0
030FE:  CALL   2068
03102:  MOVLB  2
....................                } 
....................             } 
....................             else if ( ps->smState == TCP_CLOSING ) 
03104:  BRA    313C
03106:  MOVFF  225,FE9
0310A:  MOVFF  226,FEA
0310E:  MOVF   FEF,W
03110:  SUBLW  06
03112:  BNZ   313C
....................             { 
....................                MACDiscardRx(); 
03114:  MOVLB  0
03116:  CALL   0C30
....................  
....................                if ( h->Flags.bits.flagACK ) 
0311A:  MOVLW  0D
0311C:  MOVLB  2
0311E:  ADDWF  x11,W
03120:  MOVWF  FE9
03122:  MOVLW  00
03124:  ADDWFC x12,W
03126:  MOVWF  FEA
03128:  BTFSS  FEF.4
0312A:  BRA    313C
....................                { 
....................                   CloseSocket(ps); 
0312C:  MOVFF  226,22D
03130:  MOVFF  225,22C
03134:  MOVLB  0
03136:  CALL   2068
0313A:  MOVLB  2
....................                } 
....................             } 
....................          } 
....................       } 
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
0313C:  BRA    315A
....................       { 
....................          MACDiscardRx(); 
0313E:  MOVLB  0
03140:  CALL   0C30
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
03144:  MOVLW  10
03146:  MOVLB  2
03148:  MOVWF  x27
....................          ack = prevAck; 
0314A:  MOVFF  220,218
0314E:  MOVFF  21F,217
03152:  MOVFF  21E,216
03156:  MOVFF  21D,215
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
0315A:  MOVF   x27,F
0315C:  BZ    31D2
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
0315E:  MOVLW  02
03160:  ADDWF  x11,W
03162:  MOVWF  FE9
03164:  MOVLW  00
03166:  ADDWFC x12,W
03168:  MOVWF  FEA
0316A:  MOVFF  FEC,22D
0316E:  MOVF   FED,F
03170:  MOVFF  FEF,22C
03174:  MOVFF  211,FE9
03178:  MOVFF  212,FEA
0317C:  MOVFF  FEC,22F
03180:  MOVF   FED,F
03182:  MOVFF  FEF,22E
03186:  MOVFF  210,231
0318A:  MOVFF  20F,230
0318E:  MOVFF  22D,233
03192:  MOVFF  22C,232
03196:  MOVFF  22F,235
0319A:  MOVFF  22E,234
0319E:  MOVFF  21C,239
031A2:  MOVFF  21B,238
031A6:  MOVFF  21A,237
031AA:  MOVFF  219,236
031AE:  MOVFF  218,23D
031B2:  MOVFF  217,23C
031B6:  MOVFF  216,23B
031BA:  MOVFF  215,23A
031BE:  MOVFF  227,23E
031C2:  MOVLW  FF
031C4:  MOVWF  x3F
031C6:  CLRF   x41
031C8:  CLRF   x40
031CA:  MOVLB  0
031CC:  CALL   24B4
031D0:  MOVLB  2
....................    } 
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
031D2:  MOVLB  0
031D4:  GOTO   3386 (RETURN)
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder		9/9/04	Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder		1/5/06	Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #define debug_icmp 
.................... //#define debug_icmp   debug_printf 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp("\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
03478:  MOVLW  01
0347A:  MOVLB  2
0347C:  MOVWF  x3B
0347E:  MOVLW  EE
03480:  MOVFF  23B,277
03484:  MOVWF  x76
03486:  CLRF   x79
03488:  MOVLW  08
0348A:  MOVWF  x78
0348C:  MOVLB  0
0348E:  CALL   0C94
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Calculate the checksum using the Microchip MAC's DMA module 
.................... 	// The checksum data includes the precomputed checksum in the 
.................... 	// header, so a valid packet will always have a checksum of 
.................... 	// 0x0000 if the packet is not disturbed. 
.................... 	ReceivedChecksum = 0x0000; 
03492:  MOVLB  2
03494:  CLRF   x39
03496:  CLRF   x38
.................... 	CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
03498:  MOVFF  1E9,03
0349C:  MOVFF  1E8,FE9
034A0:  MOVFF  1E9,FEA
034A4:  MOVFF  FEF,23A
034A8:  MOVLB  2
034AA:  CLRF   x3C
034AC:  MOVLW  14
034AE:  MOVWF  x3B
034B0:  CLRF   x3E
034B2:  MOVFF  23A,23D
034B6:  MOVLB  0
034B8:  CALL   1658
034BC:  MOVFF  02,237
034C0:  MOVFF  01,236
.................... #endif 
....................  
.................... 	// Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
034C4:  MOVLB  1
034C6:  MOVFF  1E8,FE9
034CA:  MOVFF  1E9,FEA
034CE:  MOVLW  08
034D0:  SUBWF  FEF,W
034D2:  MOVWF  FEF
....................     MACGetArray(data, *len); 
034D4:  MOVFF  1E9,03
034D8:  MOVFF  1E8,FE9
034DC:  MOVFF  1E9,FEA
034E0:  MOVFF  FEF,23A
034E4:  MOVFF  1E7,277
034E8:  MOVFF  1E6,276
034EC:  MOVLB  2
034EE:  CLRF   x79
034F0:  MOVFF  23A,278
034F4:  MOVLB  0
034F6:  CALL   0C94
....................  
....................  
.................... #if !defined(MCHP_MAC) 
.................... 	// Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
034FA:  MOVLW  01
034FC:  MOVLB  2
034FE:  MOVWF  x3B
03500:  MOVLW  EE
03502:  MOVWF  x3A
03504:  MOVLB  0
03506:  RCALL  3398
....................  
....................     *code = packet.Type; 
03508:  MOVLB  1
0350A:  MOVFF  1E4,FE9
0350E:  MOVFF  1E5,FEA
03512:  MOVFF  1EE,FEF
....................     *id = packet.Identifier; 
03516:  MOVFF  1EA,FE9
0351A:  MOVFF  1EB,FEA
0351E:  MOVFF  1F3,FEC
03522:  MOVF   FED,F
03524:  MOVFF  1F2,FEF
....................     *seq = packet.SequenceNumber; 
03528:  MOVFF  1EC,FE9
0352C:  MOVFF  1ED,FEA
03530:  MOVFF  1F5,FEC
03534:  MOVF   FED,F
03536:  MOVFF  1F4,FEF
....................  
....................     debug_icmp("%U", CalcChecksum == ReceivedChecksum); 
0353A:  MOVLB  2
0353C:  MOVF   x38,W
0353E:  SUBWF  x36,W
03540:  BNZ   3548
03542:  MOVF   x39,W
03544:  SUBWF  x37,W
03546:  BZ    354C
03548:  MOVLW  00
0354A:  BRA    354C
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
0354C:  MOVF   x38,W
0354E:  SUBWF  x36,W
03550:  BNZ   3558
03552:  MOVF   x39,W
03554:  SUBWF  x37,W
03556:  BZ    355C
03558:  MOVLW  00
0355A:  BRA    355E
0355C:  MOVLW  01
0355E:  MOVWF  01
.................... } 
03560:  MOVLB  0
03562:  GOTO   3C98 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET	packet; 
....................     WORD ICMPLen; 
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
03566:  MOVLW  01
03568:  MOVLB  2
0356A:  MOVWF  x68
0356C:  MOVLB  0
0356E:  CALL   0FFC
03572:  MOVFF  01,236
....................  
.................... 	// Abort if there is no where in the Ethernet controller to 
.................... 	// store this packet. 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
03576:  MOVLB  2
03578:  INCFSZ x36,W
0357A:  BRA    357E
.................... 		return; 
0357C:  BRA    367A
....................  
.................... 	IPSetTxBuffer(MyTxBuffer, 0); 
0357E:  MOVFF  236,281
03582:  CLRF   x83
03584:  MOVLW  14
03586:  MOVWF  x82
03588:  MOVLB  0
0358A:  CALL   1026
....................  
....................  
.................... 	ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
0358E:  CLRF   03
03590:  MOVLB  1
03592:  MOVF   xE7,W
03594:  ADDLW  08
03596:  MOVLB  2
03598:  MOVWF  x34
0359A:  MOVLW  00
0359C:  ADDWFC 03,W
0359E:  MOVWF  x35
....................  
....................     packet.Code             = 0; 
035A0:  MOVLB  1
035A2:  CLRF   xED
....................     packet.Type             = code; 
035A4:  MOVFF  1E4,1EC
....................     packet.Checksum         = 0; 
035A8:  CLRF   xEF
035AA:  CLRF   xEE
....................     packet.Identifier       = id; 
035AC:  MOVFF  1E9,1F1
035B0:  MOVFF  1E8,1F0
....................     packet.SequenceNumber   = seq; 
035B4:  MOVFF  1EB,1F3
035B8:  MOVFF  1EA,1F2
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
035BC:  MOVLW  01
035BE:  MOVWF  FEA
035C0:  MOVLW  F4
035C2:  MOVWF  FE9
035C4:  MOVFF  1E6,FE2
035C8:  MOVFF  1E5,FE1
035CC:  MOVF   xE7,W
035CE:  MOVWF  01
035D0:  BZ    35DA
035D2:  MOVFF  FE6,FEE
035D6:  DECFSZ 01,F
035D8:  BRA    35D2
....................  
....................     SwapICMPPacket(&packet); 
035DA:  MOVLW  01
035DC:  MOVLB  2
035DE:  MOVWF  x3B
035E0:  MOVLW  EC
035E2:  MOVWF  x3A
035E4:  MOVLB  0
035E6:  RCALL  3398
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
035E8:  MOVLW  08
035EA:  MOVLB  1
035EC:  ADDWF  xE7,W
035EE:  MOVLB  2
035F0:  CLRF   x38
035F2:  MOVWF  x37
035F4:  MOVFF  1E3,269
035F8:  MOVFF  1E2,268
035FC:  MOVLW  01
035FE:  MOVWF  x6A
03600:  MOVFF  238,26C
03604:  MOVFF  237,26B
03608:  MOVLB  0
0360A:  CALL   2388
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
0360E:  MOVLW  01
03610:  MOVLB  2
03612:  MOVWF  x38
03614:  MOVLW  EC
03616:  MOVFF  238,28D
0361A:  MOVWF  x8C
0361C:  MOVFF  235,28F
03620:  MOVFF  234,28E
03624:  MOVLB  0
03626:  CALL   10EA
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
.................... 	packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
0362A:  MOVLB  2
0362C:  CLRF   x82
0362E:  MOVLW  14
03630:  MOVWF  x81
03632:  MOVFF  235,284
03636:  MOVFF  234,283
0363A:  MOVLB  0
0363C:  CALL   22B0
03640:  MOVFF  02,1EF
03644:  MOVFF  01,1EE
.................... 	IPSetTxBuffer(MyTxBuffer, 2); 
03648:  MOVFF  236,281
0364C:  MOVLB  2
0364E:  CLRF   x83
03650:  MOVLW  16
03652:  MOVWF  x82
03654:  MOVLB  0
03656:  CALL   1026
.................... 	MACPutArray((BYTE*)&packet.Checksum, 2); 
0365A:  MOVLW  01
0365C:  MOVLB  2
0365E:  MOVWF  x38
03660:  MOVLW  EE
03662:  MOVFF  238,28D
03666:  MOVWF  x8C
03668:  CLRF   x8F
0366A:  MOVLW  02
0366C:  MOVWF  x8E
0366E:  MOVLB  0
03670:  CALL   10EA
.................... #endif 
....................  
....................  
....................     MACFlush(); 
03674:  CALL   1202
03678:  MOVLB  2
.................... } 
0367A:  MOVLB  0
0367C:  GOTO   3CF0 (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
03398:  MOVLW  04
0339A:  MOVLB  2
0339C:  ADDWF  x3A,W
0339E:  MOVWF  01
033A0:  MOVLW  00
033A2:  ADDWFC x3B,W
033A4:  MOVWF  03
033A6:  MOVFF  01,23C
033AA:  MOVWF  x3D
033AC:  MOVLW  04
033AE:  ADDWF  x3A,W
033B0:  MOVWF  FE9
033B2:  MOVLW  00
033B4:  ADDWFC x3B,W
033B6:  MOVWF  FEA
033B8:  MOVFF  FEC,23F
033BC:  MOVF   FED,F
033BE:  MOVFF  FEF,23E
033C2:  MOVFF  23F,288
033C6:  MOVFF  23E,287
033CA:  MOVLB  0
033CC:  CALL   0CF0
033D0:  MOVFF  23D,FEA
033D4:  MOVFF  23C,FE9
033D8:  MOVFF  02,FEC
033DC:  MOVF   FED,F
033DE:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
033E2:  MOVLW  06
033E4:  MOVLB  2
033E6:  ADDWF  x3A,W
033E8:  MOVWF  01
033EA:  MOVLW  00
033EC:  ADDWFC x3B,W
033EE:  MOVWF  03
033F0:  MOVFF  01,23C
033F4:  MOVWF  x3D
033F6:  MOVLW  06
033F8:  ADDWF  x3A,W
033FA:  MOVWF  FE9
033FC:  MOVLW  00
033FE:  ADDWFC x3B,W
03400:  MOVWF  FEA
03402:  MOVFF  FEC,23F
03406:  MOVF   FED,F
03408:  MOVFF  FEF,23E
0340C:  MOVFF  23F,288
03410:  MOVFF  23E,287
03414:  MOVLB  0
03416:  CALL   0CF0
0341A:  MOVFF  23D,FEA
0341E:  MOVFF  23C,FE9
03422:  MOVFF  02,FEC
03426:  MOVF   FED,F
03428:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
0342C:  MOVLW  02
0342E:  MOVLB  2
03430:  ADDWF  x3A,W
03432:  MOVWF  01
03434:  MOVLW  00
03436:  ADDWFC x3B,W
03438:  MOVWF  03
0343A:  MOVFF  01,23C
0343E:  MOVWF  x3D
03440:  MOVLW  02
03442:  ADDWF  x3A,W
03444:  MOVWF  FE9
03446:  MOVLW  00
03448:  ADDWFC x3B,W
0344A:  MOVWF  FEA
0344C:  MOVFF  FEC,23F
03450:  MOVF   FED,F
03452:  MOVFF  FEF,23E
03456:  MOVFF  23F,288
0345A:  MOVFF  23E,287
0345E:  MOVLB  0
03460:  CALL   0CF0
03464:  MOVFF  23D,FEA
03468:  MOVFF  23C,FE9
0346C:  MOVFF  02,FEC
03470:  MOVF   FED,F
03472:  MOVFF  01,FEF
.................... } 
03476:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
00990:  BCF    58.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
00992:  MOVLW  FF
00994:  MOVLB  1
00996:  MOVWF  x15
....................     Cache.MACAddr.v[1] = 0xff; 
00998:  MOVWF  x16
....................     Cache.MACAddr.v[2] = 0xff; 
0099A:  MOVWF  x17
....................     Cache.MACAddr.v[3] = 0xff; 
0099C:  MOVWF  x18
....................     Cache.MACAddr.v[4] = 0xff; 
0099E:  MOVWF  x19
....................     Cache.MACAddr.v[5] = 0xff; 
009A0:  MOVWF  x1A
....................  
....................     Cache.IPAddr.Val = 0x0; 
009A2:  CLRF   x1E
009A4:  CLRF   x1D
009A6:  CLRF   x1C
009A8:  CLRF   x1B
.................... } 
009AA:  MOVLB  0
009AC:  GOTO   0C2A (RETURN)
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
....................     { 
*
015C6:  MOVLW  00
015C8:  BTFSC  58.1
015CA:  MOVLW  01
015CC:  XORLW  00
015CE:  BZ    15D2
015D0:  BRA    1630
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
015D2:  MOVLW  01
015D4:  MOVLB  1
015D6:  MOVWF  xEE
015D8:  MOVLW  E2
015DA:  MOVWF  xED
015DC:  MOVLW  01
015DE:  MOVWF  xF0
015E0:  MOVLW  EC
015E2:  MOVWF  xEF
015E4:  MOVLB  0
015E6:  BRA    0F12
015E8:  MOVF   01,F
015EA:  BNZ   15EE
....................             break; 
015EC:  BRA    1650
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
015EE:  CALL   0C30
....................  
....................         if ( opCode == ARP_REPLY ) 
015F2:  MOVLB  1
015F4:  MOVF   xEC,F
015F6:  BNZ   162C
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
015F8:  MOVLW  01
015FA:  MOVWF  FEA
015FC:  MOVLW  15
015FE:  MOVWF  FE9
01600:  MOVLW  01
01602:  MOVWF  FE2
01604:  MOVLW  E2
01606:  MOVWF  FE1
01608:  MOVLW  06
0160A:  MOVWF  01
0160C:  MOVFF  FE6,FEE
01610:  DECFSZ 01,F
01612:  BRA    160C
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
01614:  MOVFF  1EB,11E
01618:  MOVFF  1EA,11D
0161C:  MOVFF  1E9,11C
01620:  MOVFF  1E8,11B
....................             break; 
01624:  MOVLB  0
01626:  BRA    1650
....................         } 
....................         else 
01628:  BRA    1630
0162A:  MOVLB  1
....................             smARP = SM_ARP_REPLY; 
0162C:  BSF    58.1
0162E:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
01630:  MOVLW  01
01632:  MOVLB  1
01634:  MOVWF  xEE
01636:  MOVLW  E2
01638:  MOVWF  xED
0163A:  CLRF   xEF
0163C:  MOVLB  0
0163E:  BRA    142A
01640:  MOVF   01,F
01642:  BZ    1648
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
01644:  BCF    58.1
.................... 		} 
....................         else 
01646:  BRA    164E
....................             return FALSE; 
01648:  MOVLW  00
0164A:  MOVWF  01
0164C:  BRA    1654
....................         break; 
0164E:  BRA    1650
....................  
....................     } 
....................     return TRUE; 
01650:  MOVLW  01
01652:  MOVWF  01
.................... } 
01654:  GOTO   3BBC (RETURN)
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
....................     { 
....................         *MACAddr = Cache.MACAddr; 
....................         return TRUE; 
....................     } 
....................     return FALSE; 
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #define MPFS_RESERVE_BLOCK              (64) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     5 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the “Company”) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Company’s customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN “AS IS” CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arp 
.................... //#define debug_arp debug_printf 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
00F12:  MOVLW  01
00F14:  MOVLB  2
00F16:  MOVWF  x77
00F18:  MOVLW  F1
00F1A:  MOVWF  x76
00F1C:  CLRF   x79
00F1E:  MOVLW  1C
00F20:  MOVWF  x78
00F22:  MOVLB  0
00F24:  RCALL  0C94
....................  
....................     MACDiscardRx(); 
00F26:  RCALL  0C30
....................  
....................     SwapARPPacket(&packet); 
00F28:  MOVLW  01
00F2A:  MOVLB  2
00F2C:  MOVWF  x0E
00F2E:  MOVLW  F1
00F30:  MOVWF  x0D
00F32:  MOVLB  0
00F34:  RCALL  0E3E
....................  
....................    debug_arp("\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
00F36:  MOVLB  1
00F38:  DECFSZ xF1,W
00F3A:  BRA    0F4C
00F3C:  MOVF   xF2,F
00F3E:  BNZ   0F4C
00F40:  MOVF   xF5,W
00F42:  SUBLW  06
00F44:  BNZ   0F4C
00F46:  MOVF   xF6,W
00F48:  SUBLW  04
00F4A:  BZ    0F52
....................          return FALSE; 
00F4C:  MOVLW  00
00F4E:  MOVWF  01
00F50:  BRA    0FF6
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
00F52:  MOVF   xF7,W
00F54:  SUBLW  02
00F56:  BNZ   0F68
00F58:  MOVF   xF8,F
00F5A:  BNZ   0F68
....................         *opCode = ARP_REPLY; 
00F5C:  MOVFF  1EF,FE9
00F60:  MOVFF  1F0,FEA
00F64:  CLRF   FEF
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
00F66:  BRA    0F90
00F68:  DECFSZ xF7,W
00F6A:  BRA    0F7E
00F6C:  MOVF   xF8,F
00F6E:  BNZ   0F7E
....................         *opCode = ARP_REQUEST; 
00F70:  MOVFF  1EF,FE9
00F74:  MOVFF  1F0,FEA
00F78:  MOVLW  01
00F7A:  MOVWF  FEF
....................     else 
00F7C:  BRA    0F90
....................     { 
....................         *opCode = ARP_UNKNOWN; 
00F7E:  MOVFF  1EF,FE9
00F82:  MOVFF  1F0,FEA
00F86:  MOVLW  02
00F88:  MOVWF  FEF
....................         return FALSE; 
00F8A:  MOVLW  00
00F8C:  MOVWF  01
00F8E:  BRA    0FF6
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
00F90:  MOVF   18,W
00F92:  MOVLB  2
00F94:  SUBWF  x09,W
00F96:  BNZ   0FEE
00F98:  MOVF   19,W
00F9A:  SUBWF  x0A,W
00F9C:  BNZ   0FEE
00F9E:  MOVF   1A,W
00FA0:  SUBWF  x0B,W
00FA2:  BNZ   0FEE
00FA4:  MOVF   1B,W
00FA6:  SUBWF  x0C,W
00FA8:  BNZ   0FEE
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
00FAA:  MOVLB  1
00FAC:  MOVFF  1ED,FE9
00FB0:  MOVFF  1EE,FEA
00FB4:  MOVLW  01
00FB6:  MOVWF  FE2
00FB8:  MOVLW  F9
00FBA:  MOVWF  FE1
00FBC:  MOVLW  06
00FBE:  MOVWF  01
00FC0:  MOVFF  FE6,FEE
00FC4:  DECFSZ 01,F
00FC6:  BRA    0FC0
....................         remote->IPAddr      = packet.SenderIPAddr; 
00FC8:  MOVLW  06
00FCA:  ADDWF  xED,W
00FCC:  MOVWF  FE9
00FCE:  MOVLW  00
00FD0:  ADDWFC xEE,W
00FD2:  MOVWF  FEA
00FD4:  MOVFF  1FF,FEF
00FD8:  MOVFF  200,FEC
00FDC:  MOVFF  201,FEC
00FE0:  MOVFF  202,FEC
....................         return TRUE; 
00FE4:  MOVLW  01
00FE6:  MOVWF  01
00FE8:  BRA    0FF6
....................     } 
....................     else 
00FEA:  BRA    0FF6
00FEC:  MOVLB  2
....................         return FALSE; 
00FEE:  MOVLW  00
00FF0:  MOVWF  01
00FF2:  MOVLB  1
00FF4:  BRA    0FF6
.................... } 
00FF6:  MOVLB  0
00FF8:  GOTO   15E8 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *					FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
.................... 	BUFFER MyTxBuffer; 
.................... 	MyTxBuffer = MACGetTxBuffer(TRUE); 
*
0142A:  MOVLW  01
0142C:  MOVLB  2
0142E:  MOVWF  x68
01430:  MOVLB  0
01432:  RCALL  0FFC
01434:  MOVFF  01,20C
.................... 	 
.................... 	// Do not respond if there is no room to generate the ARP reply 
.................... 	if(MyTxBuffer == INVALID_BUFFER) 
01438:  MOVLB  2
0143A:  INCFSZ x0C,W
0143C:  BRA    1444
.................... 		return FALSE; 
0143E:  MOVLW  00
01440:  MOVWF  01
01442:  BRA    15C0
....................  
.................... 	MACSetTxBuffer(MyTxBuffer, 0); 
01444:  MOVFF  20C,281
01448:  CLRF   x83
0144A:  CLRF   x82
0144C:  MOVLB  0
0144E:  RCALL  1026
.................... 	 
.................... 	 
....................     packet.HardwareType             = HW_ETHERNET; 
01450:  MOVLB  1
01452:  CLRF   xF1
01454:  MOVLW  01
01456:  MOVWF  xF0
....................     packet.Protocol                 = ARP_IP; 
01458:  MOVLW  08
0145A:  MOVWF  xF3
0145C:  CLRF   xF2
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
0145E:  MOVLW  06
01460:  MOVWF  xF4
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
01462:  MOVLW  04
01464:  MOVWF  xF5
....................  
....................     if ( opCode == ARP_REQUEST ) 
01466:  DECFSZ xEF,W
01468:  BRA    1484
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
0146A:  CLRF   xF7
0146C:  MOVLW  01
0146E:  MOVWF  xF6
....................         packet.TargetMACAddr.v[0]   = 0xff; 
01470:  MOVLW  FF
01472:  MOVLB  2
01474:  MOVWF  x02
....................         packet.TargetMACAddr.v[1]   = 0xff; 
01476:  MOVWF  x03
....................         packet.TargetMACAddr.v[2]   = 0xff; 
01478:  MOVWF  x04
....................         packet.TargetMACAddr.v[3]   = 0xff; 
0147A:  MOVWF  x05
....................         packet.TargetMACAddr.v[4]   = 0xff; 
0147C:  MOVWF  x06
....................         packet.TargetMACAddr.v[5]   = 0xff; 
0147E:  MOVWF  x07
....................     } 
....................     else 
01480:  BRA    14B2
01482:  MOVLB  1
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
01484:  CLRF   xF7
01486:  MOVLW  02
01488:  MOVWF  xF6
....................         packet.TargetMACAddr        = remote->MACAddr; 
0148A:  MOVFF  1EE,03
0148E:  MOVFF  1ED,20D
01492:  MOVLB  2
01494:  MOVFF  1EE,20E
01498:  MOVLW  02
0149A:  MOVWF  FEA
0149C:  MOVWF  FE9
0149E:  MOVFF  1EE,FE2
014A2:  MOVFF  1ED,FE1
014A6:  MOVLW  06
014A8:  MOVWF  01
014AA:  MOVFF  FE6,FEE
014AE:  DECFSZ 01,F
014B0:  BRA    14AA
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
014B2:  MOVLW  01
014B4:  MOVWF  FEA
014B6:  MOVLW  F8
014B8:  MOVWF  FE9
014BA:  CLRF   FE2
014BC:  MOVLW  1C
014BE:  MOVWF  FE1
014C0:  MOVLW  06
014C2:  MOVWF  01
014C4:  MOVFF  FE6,FEE
014C8:  DECFSZ 01,F
014CA:  BRA    14C4
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
014CC:  MOVFF  1B,201
014D0:  MOVFF  1A,200
014D4:  MOVFF  19,1FF
014D8:  MOVFF  18,1FE
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
014DC:  MOVLW  06
014DE:  MOVLB  1
014E0:  ADDWF  xED,W
014E2:  MOVWF  FE9
014E4:  MOVLW  00
014E6:  ADDWFC xEE,W
014E8:  MOVWF  FEA
014EA:  MOVFF  FEF,00
014EE:  MOVFF  FEC,01
014F2:  MOVFF  FEC,02
014F6:  MOVFF  FEC,03
014FA:  MOVF   00,W
014FC:  XORWF  xFE,W
014FE:  MOVLB  2
01500:  MOVWF  x0D
01502:  MOVF   01,W
01504:  MOVLB  1
01506:  XORWF  xFF,W
01508:  MOVLB  2
0150A:  MOVWF  x0E
0150C:  MOVF   02,W
0150E:  XORWF  x00,W
01510:  MOVWF  x0F
01512:  MOVF   03,W
01514:  XORWF  x01,W
01516:  MOVWF  x10
01518:  MOVF   x0D,W
0151A:  ANDWF  22,W
0151C:  MOVWF  00
0151E:  MOVF   x0E,W
01520:  ANDWF  23,W
01522:  MOVWF  01
01524:  MOVF   x0F,W
01526:  ANDWF  24,W
01528:  MOVWF  02
0152A:  MOVF   x10,W
0152C:  ANDWF  25,W
0152E:  MOVWF  03
01530:  MOVF   00,F
01532:  BNZ   1540
01534:  MOVF   01,F
01536:  BNZ   1540
01538:  MOVF   02,F
0153A:  BNZ   1540
0153C:  MOVF   03,F
0153E:  BZ    1552
....................     { 
.................... 		packet.TargetIPAddr = AppConfig.MyGateway; 
01540:  MOVFF  29,20B
01544:  MOVFF  28,20A
01548:  MOVFF  27,209
0154C:  MOVFF  26,208
....................     } 
....................     else 
01550:  BRA    1582
....................         packet.TargetIPAddr             = remote->IPAddr; 
01552:  MOVLW  06
01554:  MOVLB  1
01556:  ADDWF  xED,W
01558:  MOVWF  FE9
0155A:  MOVLW  00
0155C:  ADDWFC xEE,W
0155E:  MOVWF  FEA
01560:  MOVFF  FEF,00
01564:  MOVFF  FEC,01
01568:  MOVFF  FEC,02
0156C:  MOVFF  FEC,03
01570:  MOVFF  03,20B
01574:  MOVFF  02,20A
01578:  MOVFF  01,209
0157C:  MOVFF  00,208
01580:  MOVLB  2
....................  
....................     SwapARPPacket(&packet); 
01582:  MOVLW  01
01584:  MOVWF  x0E
01586:  MOVLW  F0
01588:  MOVWF  x0D
0158A:  MOVLB  0
0158C:  RCALL  0E3E
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
0158E:  MOVLW  02
01590:  MOVLB  2
01592:  MOVWF  x86
01594:  MOVWF  x85
01596:  MOVLW  06
01598:  MOVWF  x87
0159A:  CLRF   x89
0159C:  MOVLW  1C
0159E:  MOVWF  x88
015A0:  MOVLB  0
015A2:  RCALL  1134
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
015A4:  MOVLW  01
015A6:  MOVLB  2
015A8:  MOVWF  x8D
015AA:  MOVLW  F0
015AC:  MOVWF  x8C
015AE:  CLRF   x8F
015B0:  MOVLW  1C
015B2:  MOVWF  x8E
015B4:  MOVLB  0
015B6:  RCALL  10EA
....................  
....................     MACFlush(); 
015B8:  RCALL  1202
.................... 	 
.................... 	return TRUE; 
015BA:  MOVLW  01
015BC:  MOVWF  01
015BE:  MOVLB  2
.................... } 
015C0:  MOVLB  0
015C2:  GOTO   1640 (RETURN)
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
00E3E:  MOVLB  2
00E40:  MOVFF  20D,01
00E44:  MOVFF  20E,03
00E48:  MOVFF  20D,20F
00E4C:  MOVFF  20E,210
00E50:  MOVFF  20D,FE9
00E54:  MOVFF  20E,FEA
00E58:  MOVFF  FEC,212
00E5C:  MOVF   FED,F
00E5E:  MOVFF  FEF,211
00E62:  MOVFF  212,288
00E66:  MOVFF  211,287
00E6A:  MOVLB  0
00E6C:  RCALL  0CF0
00E6E:  MOVFF  210,FEA
00E72:  MOVFF  20F,FE9
00E76:  MOVFF  02,FEC
00E7A:  MOVF   FED,F
00E7C:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
00E80:  MOVLW  02
00E82:  MOVLB  2
00E84:  ADDWF  x0D,W
00E86:  MOVWF  01
00E88:  MOVLW  00
00E8A:  ADDWFC x0E,W
00E8C:  MOVWF  03
00E8E:  MOVFF  01,20F
00E92:  MOVWF  x10
00E94:  MOVLW  02
00E96:  ADDWF  x0D,W
00E98:  MOVWF  FE9
00E9A:  MOVLW  00
00E9C:  ADDWFC x0E,W
00E9E:  MOVWF  FEA
00EA0:  MOVFF  FEC,212
00EA4:  MOVF   FED,F
00EA6:  MOVFF  FEF,211
00EAA:  MOVFF  212,288
00EAE:  MOVFF  211,287
00EB2:  MOVLB  0
00EB4:  RCALL  0CF0
00EB6:  MOVFF  210,FEA
00EBA:  MOVFF  20F,FE9
00EBE:  MOVFF  02,FEC
00EC2:  MOVF   FED,F
00EC4:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
00EC8:  MOVLW  06
00ECA:  MOVLB  2
00ECC:  ADDWF  x0D,W
00ECE:  MOVWF  01
00ED0:  MOVLW  00
00ED2:  ADDWFC x0E,W
00ED4:  MOVWF  03
00ED6:  MOVFF  01,20F
00EDA:  MOVWF  x10
00EDC:  MOVLW  06
00EDE:  ADDWF  x0D,W
00EE0:  MOVWF  FE9
00EE2:  MOVLW  00
00EE4:  ADDWFC x0E,W
00EE6:  MOVWF  FEA
00EE8:  MOVFF  FEC,212
00EEC:  MOVF   FED,F
00EEE:  MOVFF  FEF,211
00EF2:  MOVFF  212,288
00EF6:  MOVFF  211,287
00EFA:  MOVLB  0
00EFC:  RCALL  0CF0
00EFE:  MOVFF  210,FEA
00F02:  MOVFF  20F,FE9
00F06:  MOVFF  02,FEC
00F0A:  MOVF   FED,F
00F0C:  MOVFF  01,FEF
.................... } 
00F10:  RETLW  00
....................  
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... static SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
00C1E:  MOVLB  1
00C20:  CLRF   x1F
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
00C22:  MOVLB  0
00C24:  BRA    04BC
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
00C26:  BRA    07C2
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
00C28:  BRA    0990
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
00C2A:  BRA    0ADC
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Init(); 
.................... #endif 
.................... } 
00C2C:  GOTO   5092 (RETURN)
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
*
03B5C:  MOVLB  1
03B5E:  BCF    xE1.0
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
03B60:  BCF    xE1.0
....................         switch(smStack) 
....................         { 
03B62:  MOVF   x1F,W
03B64:  ADDLW  F9
03B66:  BTFSC  FD8.0
03B68:  BRA    3CFA
03B6A:  ADDLW  07
03B6C:  MOVLB  0
03B6E:  GOTO   3D06
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
03B72:  MOVLW  01
03B74:  MOVLB  1
03B76:  MOVWF  xE3
03B78:  MOVLW  20
03B7A:  MOVWF  xE2
03B7C:  MOVLW  01
03B7E:  MOVWF  xE5
03B80:  MOVLW  E0
03B82:  MOVWF  xE4
03B84:  MOVLB  0
03B86:  GOTO   0D06
03B8A:  MOVF   01,F
03B8C:  BNZ   3B94
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
03B8E:  MOVLB  1
03B90:  BRA    3CFA
03B92:  MOVLB  0
....................             } 
....................  
....................             debug_stack("\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
03B94:  MOVLB  1
03B96:  BSF    xE1.0
....................             if ( type.MACFrameType == MAC_IP ) { 
03B98:  MOVF   xE0,F
03B9A:  BNZ   3BA2
....................                 smStack = SM_STACK_IP; 
03B9C:  MOVLW  02
03B9E:  MOVWF  x1F
....................                 debug_stack("IP "); 
....................             } 
....................             else if ( type.MACFrameType == MAC_ARP ) { 
03BA0:  BRA    3BB6
03BA2:  MOVF   xE0,W
03BA4:  SUBLW  06
03BA6:  BNZ   3BAE
....................                 smStack = SM_STACK_ARP; 
03BA8:  MOVLW  05
03BAA:  MOVWF  x1F
....................                 debug_stack("ARP "); 
....................             } 
....................             else { 
03BAC:  BRA    3BB6
....................                 MACDiscardRx(); 
03BAE:  MOVLB  0
03BB0:  CALL   0C30
03BB4:  MOVLB  1
....................                 debug_stack("DISCARD"); 
....................             } 
....................             break; 
03BB6:  BRA    3CFA
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
03BB8:  GOTO   15C6
03BBC:  MOVF   01,F
03BBE:  BZ    3BC4
....................                 smStack = SM_STACK_IDLE; 
03BC0:  MOVLB  1
03BC2:  CLRF   x1F
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
03BC4:  MOVLB  1
03BC6:  BRA    3CFA
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
03BC8:  MOVLW  01
03BCA:  MOVLB  1
03BCC:  MOVWF  xE3
03BCE:  MOVLW  DC
03BD0:  MOVWF  xE2
03BD2:  MOVLW  01
03BD4:  MOVWF  xE5
03BD6:  MOVLW  20
03BD8:  MOVWF  xE4
03BDA:  MOVLW  01
03BDC:  MOVWF  xE7
03BDE:  MOVLW  E0
03BE0:  MOVWF  xE6
03BE2:  MOVLW  01
03BE4:  MOVWF  xE9
03BE6:  MOVLW  2A
03BE8:  MOVWF  xE8
03BEA:  MOVLB  0
03BEC:  GOTO   18BC
03BF0:  MOVF   01,F
03BF2:  BZ    3C1E
....................             { 
....................                 lbContinue = TRUE; 
03BF4:  MOVLB  1
03BF6:  BSF    xE1.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
03BF8:  DECFSZ xE0,W
03BFA:  BRA    3C02
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
03BFC:  MOVLW  03
03BFE:  MOVWF  x1F
....................                     debug_stack("ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
03C00:  BRA    3C1A
03C02:  MOVF   xE0,W
03C04:  SUBLW  06
03C06:  BNZ   3C0E
....................                     smStack = SM_STACK_TCP; 
03C08:  MOVLW  06
03C0A:  MOVWF  x1F
....................                     debug_stack("TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack("UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
03C0C:  BRA    3C1A
....................                 { 
....................                     lbContinue = FALSE; 
03C0E:  BCF    xE1.0
....................                     MACDiscardRx(); 
03C10:  MOVLB  0
03C12:  CALL   0C30
....................  
....................                     smStack = SM_STACK_IDLE; 
03C16:  MOVLB  1
03C18:  CLRF   x1F
....................                     debug_stack("UNKOWN-IP1 "); 
....................                 } 
....................             } 
....................             else 
03C1A:  BRA    3C26
03C1C:  MOVLB  0
....................             { 
....................                 MACDiscardRx(); 
03C1E:  CALL   0C30
....................                 smStack = SM_STACK_IDLE; 
03C22:  MOVLB  1
03C24:  CLRF   x1F
....................                 debug_stack("UNKOWN-IP2 "); 
....................             } 
....................             break; 
03C26:  BRA    3CFA
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack("\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
03C28:  MOVLW  01
03C2A:  MOVLB  1
03C2C:  MOVWF  xE3
03C2E:  MOVLW  20
03C30:  MOVWF  xE2
03C32:  MOVLW  01
03C34:  MOVWF  xE5
03C36:  MOVLW  DC
03C38:  MOVWF  xE4
03C3A:  MOVFF  12B,1E7
03C3E:  MOVFF  12A,1E6
03C42:  MOVLB  0
03C44:  GOTO   31D8
03C48:  MOVF   01,F
03C4A:  BZ    3C50
....................             { 
....................                 debug_stack("\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
03C4C:  MOVLB  1
03C4E:  CLRF   x1F
....................             } 
....................             break; 
03C50:  MOVLB  1
03C52:  BRA    3CFA
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
03C54:  MOVLB  1
03C56:  CLRF   x1F
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
03C58:  MOVF   x2B,F
03C5A:  BNZ   3CAA
03C5C:  MOVF   x2A,W
03C5E:  SUBLW  48
03C60:  BNC   3CAA
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
03C62:  MOVLW  01
03C64:  MOVWF  xE3
03C66:  MOVLW  2A
03C68:  MOVWF  xE2
03C6A:  MOVLW  01
03C6C:  MOVWF  xE5
03C6E:  MOVLW  E0
03C70:  MOVWF  xE4
03C72:  MOVLW  01
03C74:  MOVWF  xE7
03C76:  MOVLW  2C
03C78:  MOVWF  xE6
03C7A:  MOVFF  1E3,1E9
03C7E:  MOVFF  1E2,1E8
03C82:  MOVLW  01
03C84:  MOVWF  xEB
03C86:  MOVLW  6C
03C88:  MOVWF  xEA
03C8A:  MOVLW  01
03C8C:  MOVWF  xED
03C8E:  MOVLW  6E
03C90:  MOVWF  xEC
03C92:  MOVLB  0
03C94:  GOTO   3478
03C98:  MOVF   01,F
03C9A:  BZ    3CAC
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
03C9C:  MOVLB  1
03C9E:  MOVF   xE0,W
03CA0:  SUBLW  08
03CA2:  BNZ   3CAA
....................                     { 
....................                         debug_stack("\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
03CA4:  BSF    xE1.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
03CA6:  MOVLW  04
03CA8:  MOVWF  x1F
03CAA:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
03CAC:  CALL   0C30
....................             break; 
03CB0:  MOVLB  1
03CB2:  BRA    3CFA
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
03CB4:  MOVLW  01
03CB6:  MOVLB  2
03CB8:  MOVWF  x68
03CBA:  MOVLB  0
03CBC:  CALL   216C
03CC0:  MOVF   01,F
03CC2:  BZ    3CF4
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
03CC4:  MOVLW  01
03CC6:  MOVLB  1
03CC8:  MOVWF  xE3
03CCA:  MOVLW  20
03CCC:  MOVWF  xE2
03CCE:  CLRF   xE4
03CD0:  MOVLW  01
03CD2:  MOVWF  xE6
03CD4:  MOVLW  2C
03CD6:  MOVWF  xE5
03CD8:  MOVFF  12A,1E7
03CDC:  MOVFF  16D,1E9
03CE0:  MOVFF  16C,1E8
03CE4:  MOVFF  16F,1EB
03CE8:  MOVFF  16E,1EA
03CEC:  MOVLB  0
03CEE:  BRA    3566
....................  
....................                 debug_stack("\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
03CF0:  MOVLB  1
03CF2:  CLRF   x1F
....................             } 
....................             break; 
03CF4:  MOVLB  1
03CF6:  BRA    3CFA
03CF8:  MOVLB  1
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
03CFA:  BTFSC  xE1.0
03CFC:  BRA    3B60
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
03CFE:  MOVLB  0
03D00:  BRA    3680
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
03D02:  GOTO   5096 (RETURN)
....................  
....................  
.................... #if STACK_USE_CCS_PICENS 
....................  #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................  
....................  #define USER_LED1    PIN_A5 
....................  #define USER_LED2    PIN_B4 
....................  #define USER_LED3    PIN_B5 
....................  #define LED_ON       output_low 
....................  #define LED_OFF      output_high 
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
*
002A2:  MOVF   FC0,W
002A4:  ANDLW  C0
002A6:  IORLW  07
002A8:  MOVWF  FC0
002AA:  BCF    FC0.7
002AC:  BSF    FC2.0
....................    setup_adc_ports(AN0); 
002AE:  MOVF   FC1,W
002B0:  ANDLW  C0
002B2:  IORLW  0E
002B4:  MOVWF  FC1
....................    *0xF92=(*0xF92 & 0xDF) | 0x11;   //a5 output, a4 and a0 input 
002B6:  MOVF   F92,W
002B8:  ANDLW  DF
002BA:  IORLW  11
002BC:  MOVWF  F92
....................    *0xF93=*0xF93 & 0xCF;   //b4 and b5 output 
002BE:  MOVLW  CF
002C0:  ANDWF  F93,F
....................    LED_OFF(USER_LED1); 
002C2:  BSF    F89.5
....................    LED_OFF(USER_LED2); 
002C4:  BSF    F8A.4
....................    LED_OFF(USER_LED3); 
002C6:  BSF    F8A.5
....................  } 
002C8:  GOTO   4FFE (RETURN)
.................... #elif STACK_USE_CCS_PICEEC 
....................  #define BUTTON1_PRESSED()  (!input(PIN_A4)) 
....................  
....................  #define USER_LED1    PIN_A5 
....................  #define USER_LED2    PIN_B4 
....................  #define USER_LED3    PIN_B6 
....................  #define LED_ON       output_low 
....................  #define LED_OFF      output_high 
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
....................    setup_adc_ports(AN0_TO_AN2); 
....................    set_adc_channel(2); 
....................    *0xF92=*0xF92 & 0xFC;   //a0 and a1 output 
....................    *0xF93=*0xF93 & 0xCF;   //b4 and b5 output 
....................    LED_OFF(USER_LED1); 
....................    LED_OFF(USER_LED2); 
....................    LED_OFF(USER_LED3); 
....................  } 
.................... #else 
....................  #define BUTTON1_PRESSED()  (!input(PIN_B0)) 
....................  #define BUTTON2_PRESSED()  (!input(PIN_B1)) 
....................  
....................  #define USER_LED1    PIN_B2 
....................  #define USER_LED2    PIN_B4 
....................  #define LED_ON       output_low 
....................  #define LED_OFF      output_high 
....................  void init_user_io(void) { 
....................    setup_adc(ADC_CLOCK_INTERNAL ); 
....................    setup_adc_ports(ANALOG_AN0_TO_AN1); 
....................    *0xF92=*0xF92 | 3;            //a0 and a1 input (for ADC) 
....................    *0xF93=(*0xF93 & 0xEB) | 3;   //B0 and B1 input, B2 and B4 output 
....................    LED_OFF(USER_LED1); 
....................    LED_OFF(USER_LED2); 
....................  } 
.................... #endif 
....................  
.................... void MACAddrInit(void) { 
....................    MY_MAC_BYTE1=0; 
*
0025A:  CLRF   1C
....................    MY_MAC_BYTE2=2; 
0025C:  MOVLW  02
0025E:  MOVWF  1D
....................    MY_MAC_BYTE3=3; 
00260:  MOVLW  03
00262:  MOVWF  1E
....................    MY_MAC_BYTE4=4; 
00264:  MOVLW  04
00266:  MOVWF  1F
....................    MY_MAC_BYTE5=5; 
00268:  MOVLW  05
0026A:  MOVWF  20
....................    MY_MAC_BYTE6=6; 
0026C:  MOVLW  06
0026E:  MOVWF  21
.................... } 
00270:  GOTO   4FF6 (RETURN)
....................  
.................... void IPAddrInit(void) { 
....................    //IP address of this unit 
....................    MY_IP_BYTE1=10; 
00274:  MOVLW  0A
00276:  MOVWF  18
....................    MY_IP_BYTE2=46; 
00278:  MOVLW  2E
0027A:  MOVWF  19
....................    MY_IP_BYTE3=3; 
0027C:  MOVLW  03
0027E:  MOVWF  1A
....................    MY_IP_BYTE4=222; 
00280:  MOVLW  DE
00282:  MOVWF  1B
....................  
....................    //network gateway 
....................    MY_GATE_BYTE1=10; 
00284:  MOVLW  0A
00286:  MOVWF  26
....................    MY_GATE_BYTE2=46; 
00288:  MOVLW  2E
0028A:  MOVWF  27
....................    MY_GATE_BYTE3=3; 
0028C:  MOVLW  03
0028E:  MOVWF  28
....................    MY_GATE_BYTE4=226; 
00290:  MOVLW  E2
00292:  MOVWF  29
....................  
....................    //subnet mask 
....................    MY_MASK_BYTE1=255; 
00294:  MOVLW  FF
00296:  MOVWF  22
....................    MY_MASK_BYTE2=255; 
00298:  MOVWF  23
....................    MY_MASK_BYTE3=255; 
0029A:  MOVWF  24
....................    MY_MASK_BYTE4=0; 
0029C:  CLRF   25
.................... } 
0029E:  GOTO   4FFA (RETURN)
....................  
.................... char ExampleIPDatagram[] = { 
....................    0x45, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 
....................    0x64, 0x11, 0x2A, 0x9D, 0x0A, 0x0B, 0x0C, 0x0D, 
....................    0x0A, 0x0B, 0x0C, 0x0E 
.................... }; 
....................  
.................... char ExampleUDPPacket[] = { 
....................    0x04, 0x00, 0x04, 0x01, 0x00, 0x08, 0x00, 0x00, 
....................    0x01, 0x02, 0x03, 0x04 
.................... }; 
....................  
....................  
....................  
.................... #if STACK_USE_CCS_PICENS 
....................  #include "tcpip/mlcd.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             MLCD.C                                //// 
.................... ////                Driver for LCD Module on CCS PICENS                //// 
.................... ////                                                                   //// 
.................... ////  lcd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.     //// 
.................... ////                     The following have special meaning:           //// 
.................... ////                      \f  Clear display                            //// 
.................... ////                      \n  Go to start of second line               //// 
.................... ////                      \b  Move back one position                   //// 
.................... ////                                                                   //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)    //// 
.................... ////                                                                   //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     E2  enable 
.................... //     E0  rs 
.................... //     E1  rw 
.................... //     D4  D4 
.................... //     D5  D5 
.................... //     D6  D6 
.................... //     D7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used 
....................  
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            int     empty: 4;         // on PORT D 
....................            int     data : 4; 
....................         } lcd_io,lcd_lat,lcd_tris; 
....................  
.................... #bit lcd_enable=0xF8D.2 
.................... #bit lcd_rs=0xF8D.0 
.................... #bit lcd_rw=0xF8D.1 
....................  
.................... #byte lcd_io = 0xF83                   // This puts the entire structure on PORT D 
.................... #byte lcd_lat = 0xF8C 
.................... #byte lcd_tris = 0xF95 
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #define lcd_line_two 0x40    // LCD RAM address for the second line 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................       lcd_tris.data=0xF;  //set_tris_lcd(LCD_READ); 
*
00312:  MOVLW  0F
00314:  ANDWF  F95,W
00316:  IORLW  F0
00318:  MOVWF  F95
....................       lcd_rw = 1; 
0031A:  BSF    F8D.1
....................       delay_us(1); 
0031C:  BRA    031E
....................       lcd_enable = 1; 
0031E:  BSF    F8D.2
....................       delay_us(1); 
00320:  BRA    0322
....................       high = lcd_io.data; 
00322:  SWAPF  F83,W
00324:  ANDLW  0F
00326:  MOVLB  1
00328:  MOVWF  xEA
....................       lcd_enable = 0; 
0032A:  BCF    F8D.2
....................       delay_us(1); 
0032C:  BRA    032E
....................       lcd_enable = 1; 
0032E:  BSF    F8D.2
....................       delay_us(1); 
00330:  BRA    0332
....................       low = lcd_io.data; 
00332:  SWAPF  F83,W
00334:  ANDLW  0F
00336:  MOVWF  xE9
....................       lcd_enable = 0; 
00338:  BCF    F8D.2
....................       lcd_tris.data=0;  //set_tris_lcd(LCD_WRITE); 
0033A:  MOVLW  0F
0033C:  ANDWF  F95,W
0033E:  MOVWF  F95
....................       return( (high<<4) | low); 
00340:  SWAPF  xEA,W
00342:  MOVWF  00
00344:  MOVLW  F0
00346:  ANDWF  00,F
00348:  MOVF   00,W
0034A:  IORWF  xE9,W
0034C:  MOVWF  01
.................... } 
0034E:  MOVLB  0
00350:  GOTO   035A (RETURN)
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd_lat.data = n; 
*
002F4:  MOVLB  1
002F6:  SWAPF  xEA,W
002F8:  ANDLW  F0
002FA:  MOVWF  00
002FC:  MOVLW  0F
002FE:  ANDWF  F8C,W
00300:  IORWF  00,W
00302:  MOVWF  F8C
....................       delay_us(1); 
00304:  BRA    0306
....................       lcd_enable = 1; 
00306:  BSF    F8D.2
....................       delay_us(2); 
00308:  BRA    030A
0030A:  BRA    030C
....................       lcd_enable = 0; 
0030C:  BCF    F8D.2
.................... } 
0030E:  MOVLB  0
00310:  RETLW  00
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd_rs = 0; 
*
00354:  BCF    F8D.0
....................       delay_us(1); 
00356:  BRA    0358
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
00358:  BRA    0312
0035A:  MOVFF  01,1E9
0035E:  MOVLB  1
00360:  BTFSS  01.7
00362:  BRA    0368
00364:  MOVLB  0
00366:  BRA    0358
....................       lcd_rs = address; 
00368:  BCF    F8D.0
0036A:  BTFSC  xE7.0
0036C:  BSF    F8D.0
....................       delay_us(1); 
0036E:  BRA    0370
....................       lcd_rw = 0; 
00370:  BCF    F8D.1
....................       delay_us(1); 
00372:  BRA    0374
....................       lcd_enable = 0; 
00374:  BCF    F8D.2
....................       lcd_send_nibble(n >> 4); 
00376:  SWAPF  xE8,W
00378:  MOVWF  xE9
0037A:  MOVLW  0F
0037C:  ANDWF  xE9,F
0037E:  MOVFF  1E9,1EA
00382:  MOVLB  0
00384:  RCALL  02F4
....................       lcd_send_nibble(n & 0xf); 
00386:  MOVLB  1
00388:  MOVF   xE8,W
0038A:  ANDLW  0F
0038C:  MOVWF  xE9
0038E:  MOVWF  xEA
00390:  MOVLB  0
00392:  RCALL  02F4
.................... } 
00394:  RETLW  00
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................     lcd_tris.data=0;    //set_tris_lcd(LCD_WRITE); 
00396:  MOVLW  0F
00398:  ANDWF  F95,W
0039A:  MOVWF  F95
....................     lcd_rs = 0; 
0039C:  BCF    F8D.0
....................     lcd_rw = 0; 
0039E:  BCF    F8D.1
....................     lcd_enable = 0; 
003A0:  BCF    F8D.2
....................     *0xF96=*0xF96 & 0xF8; 
003A2:  MOVLW  F8
003A4:  ANDWF  F96,F
....................     delay_ms(15); 
003A6:  MOVLW  0F
003A8:  MOVLB  1
003AA:  MOVWF  xE3
003AC:  MOVLB  0
003AE:  RCALL  02CC
....................     for(i=1;i<=3;++i) { 
003B0:  MOVLW  01
003B2:  MOVLB  1
003B4:  MOVWF  xDC
003B6:  MOVF   xDC,W
003B8:  SUBLW  03
003BA:  BNC   03D4
....................        lcd_send_nibble(3); 
003BC:  MOVLW  03
003BE:  MOVWF  xEA
003C0:  MOVLB  0
003C2:  RCALL  02F4
....................        delay_ms(5); 
003C4:  MOVLW  05
003C6:  MOVLB  1
003C8:  MOVWF  xE3
003CA:  MOVLB  0
003CC:  RCALL  02CC
....................     } 
003CE:  MOVLB  1
003D0:  INCF   xDC,F
003D2:  BRA    03B6
....................     lcd_send_nibble(2); 
003D4:  MOVLW  02
003D6:  MOVWF  xEA
003D8:  MOVLB  0
003DA:  RCALL  02F4
....................     delay_ms(5); 
003DC:  MOVLW  05
003DE:  MOVLB  1
003E0:  MOVWF  xE3
003E2:  MOVLB  0
003E4:  RCALL  02CC
....................     for(i=0;i<=3;++i) 
003E6:  MOVLB  1
003E8:  CLRF   xDC
003EA:  MOVF   xDC,W
003EC:  SUBLW  03
003EE:  BNC   0414
....................        lcd_send_byte(0,LCD_INIT_STRING[i]); 
003F0:  CLRF   03
003F2:  MOVF   xDC,W
003F4:  MOVFF  FF2,1DD
003F8:  BCF    FF2.7
003FA:  MOVLB  0
003FC:  RCALL  009E
003FE:  MOVLB  1
00400:  BTFSC  xDD.7
00402:  BSF    FF2.7
00404:  MOVWF  xDE
00406:  CLRF   xE7
00408:  MOVWF  xE8
0040A:  MOVLB  0
0040C:  RCALL  0354
0040E:  MOVLB  1
00410:  INCF   xDC,F
00412:  BRA    03EA
.................... } 
00414:  MOVLB  0
00416:  GOTO   5002 (RETURN)
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    if(y!=1) 
*
0043A:  MOVLB  1
0043C:  DECFSZ xE4,W
0043E:  BRA    0442
00440:  BRA    0448
....................      address=lcd_line_two; 
00442:  MOVLW  40
00444:  MOVWF  xE5
....................    else 
00446:  BRA    044A
....................      address=0; 
00448:  CLRF   xE5
....................    address+=x-1; 
0044A:  MOVLW  01
0044C:  SUBWF  xE3,W
0044E:  ADDWF  xE5,F
....................    lcd_send_byte(0,0x80|address); 
00450:  MOVF   xE5,W
00452:  IORLW  80
00454:  MOVWF  xE6
00456:  CLRF   xE7
00458:  MOVWF  xE8
0045A:  MOVLB  0
0045C:  RCALL  0354
.................... } 
0045E:  GOTO   04BA (RETURN)
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
00462:  MOVLB  1
00464:  MOVF   xE2,W
00466:  XORLW  0C
00468:  MOVLB  0
0046A:  BZ    0476
0046C:  XORLW  06
0046E:  BZ    048E
00470:  XORLW  02
00472:  BZ    049C
00474:  BRA    04AA
....................      case '\f'   : lcd_send_byte(0,1); 
00476:  MOVLB  1
00478:  CLRF   xE7
0047A:  MOVLW  01
0047C:  MOVWF  xE8
0047E:  MOVLB  0
00480:  RCALL  0354
....................                    delay_ms(2); 
00482:  MOVLW  02
00484:  MOVLB  1
00486:  MOVWF  xE3
00488:  MOVLB  0
0048A:  RCALL  02CC
....................                                            break; 
0048C:  BRA    04BA
....................      case '\n'   : lcd_gotoxy(1,2);        break; 
0048E:  MOVLW  01
00490:  MOVLB  1
00492:  MOVWF  xE3
00494:  MOVLW  02
00496:  MOVWF  xE4
00498:  MOVLB  0
0049A:  BRA    043A
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
0049C:  MOVLB  1
0049E:  CLRF   xE7
004A0:  MOVLW  10
004A2:  MOVWF  xE8
004A4:  MOVLB  0
004A6:  RCALL  0354
004A8:  BRA    04BA
....................      default     : lcd_send_byte(1,c);     break; 
004AA:  MOVLW  01
004AC:  MOVLB  1
004AE:  MOVWF  xE7
004B0:  MOVFF  1E2,1E8
004B4:  MOVLB  0
004B6:  RCALL  0354
004B8:  BRA    04BA
....................    } 
.................... } 
004BA:  RETLW  00
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................     lcd_rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd_rs=0; 
....................     return(value); 
.................... } 
....................  
.................... #elif STACK_USE_CCS_PICEEC 
....................  #include "tcpip/elcd.c" 
.................... #else 
....................  #include "tcpip/dlcd.c" 
.................... #endif 
....................  
.................... #define NUM_LISTEN_SOCKETS 2 
....................  
.................... #define EXAMPLE_TCP_PORT   (int16)502 
....................  
.................... char lcd_str[NUM_LISTEN_SOCKETS][20]; 
....................  
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
.................... int8 TCPConnectedTask(TCP_SOCKET socket, int8 which) { 
....................    int c; 
....................    static int8 counter[NUM_LISTEN_SOCKETS]; 
....................    static int8 button1_held[NUM_LISTEN_SOCKETS]; 
....................    char str[20]; 
....................    int8 i=0; 
*
04574:  MOVLB  1
04576:  CLRF   xF8
....................  
....................    if (TCPIsGetReady(socket)) { 
04578:  MOVFF  1E1,1F9
0457C:  MOVLB  0
0457E:  BRA    3E5E
04580:  MOVF   01,F
04582:  BZ    4608
....................       while (TCPGet(socket, &c)) { 
04584:  MOVFF  1E1,1F9
04588:  MOVLW  01
0458A:  MOVLB  1
0458C:  MOVWF  xFB
0458E:  MOVLW  E3
04590:  MOVWF  xFA
04592:  MOVLB  0
04594:  BRA    3E90
04596:  MOVF   01,F
04598:  BZ    4608
....................          if(strlen(c)<12){ 
0459A:  MOVLB  1
0459C:  CLRF   xFA
0459E:  MOVFF  1E3,1F9
045A2:  MOVLB  0
045A4:  RCALL  3F68
045A6:  MOVF   01,W
045A8:  SUBLW  0B
045AA:  BNC   45AC
....................              
....................          } 
....................          lcd_str[which][i++]=c; 
045AC:  MOVLB  1
045AE:  MOVF   xE2,W
045B0:  MULLW  14
045B2:  MOVF   FF3,W
045B4:  CLRF   xFA
045B6:  MOVWF  xF9
045B8:  MOVF   xF8,W
045BA:  INCF   xF8,F
045BC:  CLRF   03
045BE:  ADDWF  xF9,W
045C0:  MOVWF  01
045C2:  MOVF   xFA,W
045C4:  ADDWFC 03,F
045C6:  MOVF   01,W
045C8:  ADDLW  90
045CA:  MOVWF  FE9
045CC:  MOVLW  01
045CE:  ADDWFC 03,W
045D0:  MOVWF  FEA
045D2:  MOVFF  1E3,FEF
....................          if (i>=20) {i=19;} 
045D6:  MOVF   xF8,W
045D8:  SUBLW  13
045DA:  BC    45E0
045DC:  MOVLW  13
045DE:  MOVWF  xF8
....................          lcd_str[which][i]=0; 
045E0:  MOVF   xE2,W
045E2:  MULLW  14
045E4:  MOVF   FF3,W
045E6:  CLRF   xFA
045E8:  MOVWF  xF9
045EA:  CLRF   03
045EC:  MOVF   xF8,W
045EE:  ADDWF  xF9,W
045F0:  MOVWF  01
045F2:  MOVF   xFA,W
045F4:  ADDWFC 03,F
045F6:  MOVF   01,W
045F8:  ADDLW  90
045FA:  MOVWF  FE9
045FC:  MOVLW  01
045FE:  ADDWFC 03,W
04600:  MOVWF  FEA
04602:  CLRF   FEF
....................       } 
04604:  MOVLB  0
04606:  BRA    4584
....................    } 
....................  
.................... //when button 1 is pressed: send message over TCP 
.................... //when button 2 is pressed: disconnect socket 
....................    if (BUTTON1_PRESSED() && !button1_held[which] && TCPIsPutReady(socket)) { 
04608:  BTFSC  F80.4
0460A:  BRA    46BE
0460C:  CLRF   03
0460E:  MOVLB  1
04610:  MOVF   xE2,W
04612:  ADDLW  BA
04614:  MOVWF  FE9
04616:  MOVLW  01
04618:  ADDWFC 03,W
0461A:  MOVWF  FEA
0461C:  MOVF   FEF,F
0461E:  BTFSC  FD8.2
04620:  BRA    4626
04622:  MOVLB  0
04624:  BRA    46BE
04626:  MOVFF  1E1,208
0462A:  MOVLB  0
0462C:  RCALL  3FA2
0462E:  MOVF   01,F
04630:  BZ    46BE
....................       button1_held[which]=TRUE; 
04632:  CLRF   03
04634:  MOVLB  1
04636:  MOVF   xE2,W
04638:  ADDLW  BA
0463A:  MOVWF  FE9
0463C:  MOVLW  01
0463E:  ADDWFC 03,W
04640:  MOVWF  FEA
04642:  MOVLW  01
04644:  MOVWF  FEF
....................       sprintf(str,"BUTTON C=%U",counter[which]++); 
04646:  CLRF   03
04648:  MOVF   xE2,W
0464A:  ADDLW  B8
0464C:  MOVWF  FE9
0464E:  MOVLW  01
04650:  ADDWFC 03,W
04652:  MOVWF  FEA
04654:  MOVF   FEF,W
04656:  INCF   FEF,F
04658:  MOVWF  xF9
0465A:  MOVLW  01
0465C:  MOVWF  xBD
0465E:  MOVLW  E4
04660:  MOVWF  xBC
04662:  CLRF   xFA
04664:  MOVF   xFA,W
04666:  MOVLB  0
04668:  CALL   00BC
0466C:  MOVLB  1
0466E:  INCF   xFA,F
04670:  MOVWF  00
04672:  MOVWF  xFD
04674:  MOVLB  0
04676:  CALL   041A
0467A:  MOVLW  09
0467C:  MOVLB  1
0467E:  SUBWF  xFA,W
04680:  BNZ   4664
04682:  MOVFF  1F9,1FB
04686:  MOVLW  1B
04688:  MOVWF  xFC
0468A:  MOVLB  0
0468C:  BRA    4070
....................       TCPPutArray(socket,str,strlen(str)); 
0468E:  MOVLW  01
04690:  MOVLB  1
04692:  MOVWF  xFA
04694:  MOVLW  E4
04696:  MOVWF  xF9
04698:  MOVLB  0
0469A:  RCALL  3F68
0469C:  MOVFF  01,1F9
046A0:  MOVFF  1E1,1FA
046A4:  MOVLW  01
046A6:  MOVLB  1
046A8:  MOVWF  xFC
046AA:  MOVLW  E4
046AC:  MOVWF  xFB
046AE:  CLRF   xFE
046B0:  MOVFF  01,1FD
046B4:  MOVLB  0
046B6:  BRA    43BC
....................       TCPFlush(socket); 
046B8:  MOVFF  1E1,203
046BC:  RCALL  41F2
....................    } 
....................    if (!BUTTON1_PRESSED()) { 
046BE:  BTFSS  F80.4
046C0:  BRA    46D6
....................       button1_held[which]=FALSE; 
046C2:  CLRF   03
046C4:  MOVLB  1
046C6:  MOVF   xE2,W
046C8:  ADDLW  BA
046CA:  MOVWF  FE9
046CC:  MOVLW  01
046CE:  ADDWFC 03,W
046D0:  MOVWF  FEA
046D2:  CLRF   FEF
046D4:  MOVLB  0
....................    } 
....................   #if defined(BUTTON2_PRESSED()) 
....................    if (BUTTON2_PRESSED()) { 
....................       return(TRUE); 
....................    } 
....................   #endif 
....................    return(FALSE); 
.................... } 
046D6:  MOVLW  00
046D8:  MOVWF  01
....................  
046DA:  GOTO   4AD0 (RETURN)
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick[NUM_LISTEN_SOCKETS]; 
....................    static TCP_SOCKET socket[NUM_LISTEN_SOCKETS]={INVALID_SOCKET}; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_LISTENING=1, 
....................       MYTCP_STATE_CONNECTED=2, MYTCP_STATE_DISCONNECT=3, 
....................       MYTCP_STATE_FORCE_DISCONNECT=4 
....................    } state[NUM_LISTEN_SOCKETS]={0}; 
....................    static NODE_INFO remote[NUM_LISTEN_SOCKETS]; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................    int8 i; 
....................  
....................    currTick=TickGet(); 
....................  
*
04870:  CALL   204E
04874:  MOVFF  02,1DD
04878:  MOVFF  01,1DC
....................    for (i=0;i<NUM_LISTEN_SOCKETS;i++) { 
....................       switch (state[i]) { 
0487C:  MOVLB  1
0487E:  CLRF   xDF
04880:  MOVF   xDF,W
04882:  SUBLW  01
04884:  BTFSS  FD8.0
04886:  BRA    4CB8
....................          case MYTCP_STATE_NEW: 
04888:  CLRF   03
0488A:  MOVF   xDF,W
0488C:  ADDLW  C4
0488E:  MOVWF  FE9
04890:  MOVLW  01
04892:  ADDWFC 03,W
04894:  MOVWF  FEA
04896:  MOVF   FEF,W
04898:  ADDLW  FB
0489A:  BTFSC  FD8.0
0489C:  BRA    4CB4
0489E:  ADDLW  05
048A0:  MOVLB  0
048A2:  GOTO   4CBE
....................             socket[i]=TCPListen(EXAMPLE_TCP_PORT); 
....................             if (socket[i]!=INVALID_SOCKET) { 
048A6:  CLRF   03
048A8:  MOVLB  1
048AA:  MOVF   xDF,W
048AC:  ADDLW  C2
048AE:  MOVWF  01
048B0:  MOVLW  01
048B2:  ADDWFC 03,F
048B4:  MOVFF  01,1E0
048B8:  MOVFF  03,1E1
048BC:  MOVLW  01
048BE:  MOVWF  xE3
048C0:  MOVLW  F6
048C2:  MOVWF  xE2
048C4:  MOVLB  0
048C6:  GOTO   3D38
048CA:  MOVFF  1E1,FEA
048CE:  MOVFF  1E0,FE9
048D2:  MOVFF  01,FEF
....................                state[i]=MYTCP_STATE_LISTENING; 
048D6:  CLRF   03
048D8:  MOVLB  1
048DA:  MOVF   xDF,W
048DC:  ADDLW  C2
048DE:  MOVWF  FE9
048E0:  MOVLW  01
048E2:  ADDWFC 03,W
048E4:  MOVWF  FEA
048E6:  MOVF   FEF,W
048E8:  SUBLW  FE
048EA:  BZ    493C
....................                sprintf(&lcd_str[i][0],"LISTENING"); 
048EC:  CLRF   03
048EE:  MOVF   xDF,W
048F0:  ADDLW  C4
048F2:  MOVWF  FE9
048F4:  MOVLW  01
048F6:  ADDWFC 03,W
048F8:  MOVWF  FEA
048FA:  MOVLW  01
048FC:  MOVWF  FEF
....................             } 
048FE:  MOVF   xDF,W
04900:  MULLW  14
04902:  MOVF   FF3,W
04904:  CLRF   xE1
04906:  MOVWF  xE0
04908:  MOVLW  90
0490A:  ADDWF  xE0,W
0490C:  MOVWF  xE2
0490E:  MOVLW  01
04910:  ADDWFC xE1,W
04912:  MOVWF  xE3
04914:  MOVWF  xBD
04916:  MOVFF  1E2,1BC
0491A:  CLRF   xE4
0491C:  MOVF   xE4,W
0491E:  MOVLB  0
04920:  CALL   00E2
04924:  MOVLB  1
04926:  INCF   xE4,F
04928:  MOVWF  00
0492A:  MOVWF  xFD
0492C:  MOVLB  0
0492E:  CALL   041A
04932:  MOVLW  09
04934:  MOVLB  1
04936:  SUBWF  xE4,W
04938:  BNZ   491C
....................             else { 
....................                sprintf(&lcd_str[i][0],"SOCKET ERROR"); 
0493A:  BRA    4978
....................             } 
0493C:  MOVF   xDF,W
0493E:  MULLW  14
04940:  MOVF   FF3,W
04942:  CLRF   xE1
04944:  MOVWF  xE0
04946:  MOVLW  90
04948:  ADDWF  xE0,W
0494A:  MOVWF  xE2
0494C:  MOVLW  01
0494E:  ADDWFC xE1,W
04950:  MOVWF  xE3
04952:  MOVWF  xBD
04954:  MOVFF  1E2,1BC
04958:  CLRF   xE4
0495A:  MOVF   xE4,W
0495C:  MOVLB  0
0495E:  CALL   0106
04962:  MOVLB  1
04964:  INCF   xE4,F
04966:  MOVWF  00
04968:  MOVWF  xFD
0496A:  MOVLB  0
0496C:  CALL   041A
04970:  MOVLW  0C
04972:  MOVLB  1
04974:  SUBWF  xE4,W
04976:  BNZ   495A
....................             break; 
....................  
04978:  BRA    4CB4
....................          case MYTCP_STATE_LISTENING: 
....................             if (TCPIsConnected(socket[i])) { 
....................                state[i]=MYTCP_STATE_CONNECTED; 
0497A:  CLRF   03
0497C:  MOVLB  1
0497E:  MOVF   xDF,W
04980:  ADDLW  C2
04982:  MOVWF  FE9
04984:  MOVLW  01
04986:  ADDWFC 03,W
04988:  MOVWF  FEA
0498A:  MOVFF  FEF,1E0
0498E:  MOVFF  1E0,1E1
04992:  MOVLB  0
04994:  CALL   3E34
04998:  MOVF   01,F
0499A:  BZ    4A06
....................                sprintf(&lcd_str[i][0],"CONNECTED!"); 
0499C:  CLRF   03
0499E:  MOVLB  1
049A0:  MOVF   xDF,W
049A2:  ADDLW  C4
049A4:  MOVWF  FE9
049A6:  MOVLW  01
049A8:  ADDWFC 03,W
049AA:  MOVWF  FEA
049AC:  MOVLW  02
049AE:  MOVWF  FEF
....................                lastTick[i]=currTick; 
049B0:  MOVF   xDF,W
049B2:  MULLW  14
049B4:  MOVF   FF3,W
049B6:  CLRF   xE1
049B8:  MOVWF  xE0
049BA:  MOVLW  90
049BC:  ADDWF  xE0,W
049BE:  MOVWF  xE2
049C0:  MOVLW  01
049C2:  ADDWFC xE1,W
049C4:  MOVWF  xE3
049C6:  MOVWF  xBD
049C8:  MOVFF  1E2,1BC
049CC:  CLRF   xE4
049CE:  MOVF   xE4,W
049D0:  MOVLB  0
049D2:  CALL   012E
049D6:  MOVLB  1
049D8:  INCF   xE4,F
049DA:  MOVWF  00
049DC:  MOVWF  xFD
049DE:  MOVLB  0
049E0:  CALL   041A
049E4:  MOVLW  0A
049E6:  MOVLB  1
049E8:  SUBWF  xE4,W
049EA:  BNZ   49CE
....................             } 
049EC:  BCF    FD8.0
049EE:  RLCF   xDF,W
049F0:  CLRF   03
049F2:  ADDLW  BE
049F4:  MOVWF  FE9
049F6:  MOVLW  01
049F8:  ADDWFC 03,W
049FA:  MOVWF  FEA
049FC:  MOVFF  1DD,FEC
04A00:  MOVF   FED,F
04A02:  MOVFF  1DC,FEF
....................             break; 
....................  
04A06:  MOVLB  1
04A08:  BRA    4CB4
....................          case MYTCP_STATE_CONNECTED: 
....................             if (TCPIsConnected(socket[i])) { 
....................                if (TickGetDiff(currTick,lastTick[i]) > ((int16)TICKS_PER_SECOND * 300)) { 
04A0A:  CLRF   03
04A0C:  MOVLB  1
04A0E:  MOVF   xDF,W
04A10:  ADDLW  C2
04A12:  MOVWF  FE9
04A14:  MOVLW  01
04A16:  ADDWFC 03,W
04A18:  MOVWF  FEA
04A1A:  MOVFF  FEF,1E0
04A1E:  MOVFF  1E0,1E1
04A22:  MOVLB  0
04A24:  CALL   3E34
04A28:  MOVF   01,F
04A2A:  BTFSC  FD8.2
04A2C:  BRA    4B46
....................                   state[i]=MYTCP_STATE_DISCONNECT; 
04A2E:  BCF    FD8.0
04A30:  MOVLB  1
04A32:  RLCF   xDF,W
04A34:  CLRF   03
04A36:  ADDLW  BE
04A38:  MOVWF  FE9
04A3A:  MOVLW  01
04A3C:  ADDWFC 03,W
04A3E:  MOVWF  FEA
04A40:  MOVFF  FEC,03
04A44:  MOVF   FED,F
04A46:  MOVFF  FEF,01
04A4A:  MOVF   xDD,W
04A4C:  SUBWF  03,W
04A4E:  BNC   4A58
04A50:  BNZ   4A5C
04A52:  MOVF   01,W
04A54:  SUBWF  xDC,W
04A56:  BNC   4A5C
04A58:  MOVLW  00
04A5A:  BRA    4A5E
04A5C:  MOVLW  01
04A5E:  CLRF   03
04A60:  IORWF  03,W
04A62:  BZ    4AA2
04A64:  BCF    FD8.0
04A66:  RLCF   xDF,W
04A68:  CLRF   03
04A6A:  ADDLW  BE
04A6C:  MOVWF  FE9
04A6E:  MOVLW  01
04A70:  ADDWFC 03,W
04A72:  MOVWF  FEA
04A74:  MOVFF  FEC,03
04A78:  MOVF   FED,F
04A7A:  MOVF   FEF,W
04A7C:  SUBLW  FF
04A7E:  MOVWF  xE0
04A80:  MOVLW  FF
04A82:  SUBFWB 03,W
04A84:  MOVWF  xE1
04A86:  MOVF   xDC,W
04A88:  ADDWF  xE0,W
04A8A:  MOVWF  xE2
04A8C:  MOVF   xDD,W
04A8E:  ADDWFC xE1,W
04A90:  MOVWF  xE3
04A92:  MOVLW  01
04A94:  ADDWF  xE2,W
04A96:  MOVWF  01
04A98:  MOVLW  00
04A9A:  ADDWFC xE3,W
04A9C:  MOVWF  03
04A9E:  MOVF   01,W
04AA0:  BRA    4AB2
04AA2:  BCF    FD8.0
04AA4:  RLCF   xDF,W
04AA6:  CLRF   03
04AA8:  ADDLW  BE
04AAA:  MOVWF  FE9
04AAC:  MOVLW  01
04AAE:  ADDWFC 03,W
04AB0:  MOVWF  FEA
....................                   sprintf(&lcd_str[i][0],"TIMEOUT"); 
....................                   lastTick[i]=currTick; 
....................                } 
....................                else { 
....................                   dis=TCPConnectedTask(socket[i],i); 
....................                   if (dis) { 
04AB2:  CLRF   03
04AB4:  MOVF   xDF,W
04AB6:  ADDLW  C2
04AB8:  MOVWF  FE9
04ABA:  MOVLW  01
04ABC:  ADDWFC 03,W
04ABE:  MOVWF  FEA
04AC0:  MOVFF  FEF,1E0
04AC4:  MOVFF  1E0,1E1
04AC8:  MOVFF  1DF,1E2
04ACC:  MOVLB  0
04ACE:  BRA    4574
04AD0:  MOVFF  01,1DE
....................                      sprintf(&lcd_str[i][0],"DISCONNECT"); 
04AD4:  MOVLB  1
04AD6:  MOVF   xDE,F
04AD8:  BZ    4B42
....................                      state[i]=MYTCP_STATE_DISCONNECT; 
04ADA:  MOVF   xDF,W
04ADC:  MULLW  14
04ADE:  MOVF   FF3,W
04AE0:  CLRF   xE1
04AE2:  MOVWF  xE0
04AE4:  MOVLW  90
04AE6:  ADDWF  xE0,W
04AE8:  MOVWF  xE2
04AEA:  MOVLW  01
04AEC:  ADDWFC xE1,W
04AEE:  MOVWF  xE3
04AF0:  MOVWF  xBD
04AF2:  MOVFF  1E2,1BC
04AF6:  CLRF   xE4
04AF8:  MOVF   xE4,W
04AFA:  MOVLB  0
04AFC:  CALL   0154
04B00:  MOVLB  1
04B02:  INCF   xE4,F
04B04:  MOVWF  00
04B06:  MOVWF  xFD
04B08:  MOVLB  0
04B0A:  CALL   041A
04B0E:  MOVLW  0A
04B10:  MOVLB  1
04B12:  SUBWF  xE4,W
04B14:  BNZ   4AF8
....................                      lastTick[i]=currTick; 
04B16:  CLRF   03
04B18:  MOVF   xDF,W
04B1A:  ADDLW  C4
04B1C:  MOVWF  FE9
04B1E:  MOVLW  01
04B20:  ADDWFC 03,W
04B22:  MOVWF  FEA
04B24:  MOVLW  03
04B26:  MOVWF  FEF
....................                   } 
04B28:  BCF    FD8.0
04B2A:  RLCF   xDF,W
04B2C:  CLRF   03
04B2E:  ADDLW  BE
04B30:  MOVWF  FE9
04B32:  MOVLW  01
04B34:  ADDWFC 03,W
04B36:  MOVWF  FEA
04B38:  MOVFF  1DD,FEC
04B3C:  MOVF   FED,F
04B3E:  MOVFF  1DC,FEF
....................                } 
....................             } 
....................             else { 
....................                sprintf(&lcd_str[i][0],"DISCONNECTED"); 
04B42:  BRA    4B96
04B44:  MOVLB  0
....................                state[i]=MYTCP_STATE_FORCE_DISCONNECT; 
04B46:  MOVLB  1
04B48:  MOVF   xDF,W
04B4A:  MULLW  14
04B4C:  MOVF   FF3,W
04B4E:  CLRF   xE1
04B50:  MOVWF  xE0
04B52:  MOVLW  90
04B54:  ADDWF  xE0,W
04B56:  MOVWF  xE2
04B58:  MOVLW  01
04B5A:  ADDWFC xE1,W
04B5C:  MOVWF  xE3
04B5E:  MOVWF  xBD
04B60:  MOVFF  1E2,1BC
04B64:  CLRF   xE4
04B66:  MOVF   xE4,W
04B68:  MOVLB  0
04B6A:  CALL   017A
04B6E:  MOVLB  1
04B70:  INCF   xE4,F
04B72:  MOVWF  00
04B74:  MOVWF  xFD
04B76:  MOVLB  0
04B78:  CALL   041A
04B7C:  MOVLW  0C
04B7E:  MOVLB  1
04B80:  SUBWF  xE4,W
04B82:  BNZ   4B66
....................             } 
04B84:  CLRF   03
04B86:  MOVF   xDF,W
04B88:  ADDLW  C4
04B8A:  MOVWF  FE9
04B8C:  MOVLW  01
04B8E:  ADDWFC 03,W
04B90:  MOVWF  FEA
04B92:  MOVLW  04
04B94:  MOVWF  FEF
....................             break; 
....................  
04B96:  BRA    4CB4
....................          case MYTCP_STATE_DISCONNECT: 
....................             if (TCPIsPutReady(socket[i])) { 
....................                state[i]=MYTCP_STATE_FORCE_DISCONNECT; 
04B98:  CLRF   03
04B9A:  MOVLB  1
04B9C:  MOVF   xDF,W
04B9E:  ADDLW  C2
04BA0:  MOVWF  FE9
04BA2:  MOVLW  01
04BA4:  ADDWFC 03,W
04BA6:  MOVWF  FEA
04BA8:  MOVFF  FEF,1E0
04BAC:  MOVFF  1E0,208
04BB0:  MOVLB  0
04BB2:  CALL   3FA2
04BB6:  MOVF   01,F
04BB8:  BZ    4BD2
....................             } 
04BBA:  CLRF   03
04BBC:  MOVLB  1
04BBE:  MOVF   xDF,W
04BC0:  ADDLW  C4
04BC2:  MOVWF  FE9
04BC4:  MOVLW  01
04BC6:  ADDWFC 03,W
04BC8:  MOVWF  FEA
04BCA:  MOVLW  04
04BCC:  MOVWF  FEF
....................             else if (TickGetDiff(currTick, lastTick[i]) > (TICKS_PER_SECOND * 10)) { 
....................                state[i]=MYTCP_STATE_FORCE_DISCONNECT; 
04BCE:  BRA    4C80
04BD0:  MOVLB  0
04BD2:  BCF    FD8.0
04BD4:  MOVLB  1
04BD6:  RLCF   xDF,W
04BD8:  CLRF   03
04BDA:  ADDLW  BE
04BDC:  MOVWF  FE9
04BDE:  MOVLW  01
04BE0:  ADDWFC 03,W
04BE2:  MOVWF  FEA
04BE4:  MOVFF  FEC,03
04BE8:  MOVF   FED,F
04BEA:  MOVFF  FEF,01
04BEE:  MOVF   xDD,W
04BF0:  SUBWF  03,W
04BF2:  BNC   4BFC
04BF4:  BNZ   4C00
04BF6:  MOVF   01,W
04BF8:  SUBWF  xDC,W
04BFA:  BNC   4C00
04BFC:  MOVLW  00
04BFE:  BRA    4C02
04C00:  MOVLW  01
04C02:  CLRF   03
04C04:  IORWF  03,W
04C06:  BZ    4C46
04C08:  BCF    FD8.0
04C0A:  RLCF   xDF,W
04C0C:  CLRF   03
04C0E:  ADDLW  BE
04C10:  MOVWF  FE9
04C12:  MOVLW  01
04C14:  ADDWFC 03,W
04C16:  MOVWF  FEA
04C18:  MOVFF  FEC,03
04C1C:  MOVF   FED,F
04C1E:  MOVF   FEF,W
04C20:  SUBLW  FF
04C22:  MOVWF  xE0
04C24:  MOVLW  FF
04C26:  SUBFWB 03,W
04C28:  MOVWF  xE1
04C2A:  MOVF   xDC,W
04C2C:  ADDWF  xE0,W
04C2E:  MOVWF  xE2
04C30:  MOVF   xDD,W
04C32:  ADDWFC xE1,W
04C34:  MOVWF  xE3
04C36:  MOVLW  01
04C38:  ADDWF  xE2,W
04C3A:  MOVWF  01
04C3C:  MOVLW  00
04C3E:  ADDWFC xE3,W
04C40:  MOVWF  03
04C42:  MOVF   01,W
04C44:  BRA    4C6A
04C46:  BCF    FD8.0
04C48:  RLCF   xDF,W
04C4A:  CLRF   03
04C4C:  ADDLW  BE
04C4E:  MOVWF  FE9
04C50:  MOVLW  01
04C52:  ADDWFC 03,W
04C54:  MOVWF  FEA
04C56:  MOVFF  FEC,03
04C5A:  MOVF   FED,F
04C5C:  MOVF   FEF,W
04C5E:  SUBWF  xDC,W
04C60:  MOVWF  00
04C62:  MOVF   03,W
04C64:  SUBWFB xDD,W
04C66:  MOVWF  03
04C68:  MOVF   00,W
04C6A:  SUBLW  64
04C6C:  BC    4C80
....................             } 
04C6E:  CLRF   03
04C70:  MOVF   xDF,W
04C72:  ADDLW  C4
04C74:  MOVWF  FE9
04C76:  MOVLW  01
04C78:  ADDWFC 03,W
04C7A:  MOVWF  FEA
04C7C:  MOVLW  04
04C7E:  MOVWF  FEF
....................             break; 
....................  
04C80:  BRA    4CB4
....................          case MYTCP_STATE_FORCE_DISCONNECT: 
....................             TCPDisconnect(socket[i]); 
....................             state[i]=MYTCP_STATE_NEW; 
04C82:  CLRF   03
04C84:  MOVLB  1
04C86:  MOVF   xDF,W
04C88:  ADDLW  C2
04C8A:  MOVWF  FE9
04C8C:  MOVLW  01
04C8E:  ADDWFC 03,W
04C90:  MOVWF  FEA
04C92:  MOVFF  FEF,1E0
04C96:  MOVFF  1E0,1E1
04C9A:  MOVLB  0
04C9C:  BRA    472E
....................             break; 
04C9E:  CLRF   03
04CA0:  MOVLB  1
04CA2:  MOVF   xDF,W
04CA4:  ADDLW  C4
04CA6:  MOVWF  FE9
04CA8:  MOVLW  01
04CAA:  ADDWFC 03,W
04CAC:  MOVWF  FEA
04CAE:  CLRF   FEF
....................       } 
04CB0:  BRA    4CB4
04CB2:  MOVLB  1
....................    } 
.................... } 
04CB4:  INCF   xDF,F
04CB6:  BRA    4880
....................  
04CB8:  MOVLB  0
04CBA:  GOTO   509A (RETURN)
.................... void LCDTask(void) { 
....................    static TICKTYPE lastTick; 
....................    TICKTYPE currTick; 
....................    static enum {LCD_STATE_DISPLAY=0, LCD_STATE_WAIT=1} state=0; 
....................  
....................    currTick=TickGet(); 
....................  
*
04CEC:  CALL   204E
04CF0:  MOVFF  02,1DD
04CF4:  MOVFF  01,1DC
....................    switch(state) { 
....................       case LCD_STATE_DISPLAY: 
04CF8:  MOVLW  00
04CFA:  BTFSC  58.2
04CFC:  MOVLW  01
04CFE:  XORLW  00
04D00:  BZ    4D08
04D02:  XORLW  01
04D04:  BZ    4D88
04D06:  BRA    4DF2
....................          printf(lcd_putc,"\f%s\n%s",&lcd_str[0][0],&lcd_str[1][0]); 
....................          state=LCD_STATE_WAIT; 
04D08:  MOVLW  0C
04D0A:  MOVLB  1
04D0C:  MOVWF  xE2
04D0E:  MOVLB  0
04D10:  CALL   0462
04D14:  MOVLW  01
04D16:  MOVWF  FEA
04D18:  MOVLW  90
04D1A:  MOVWF  FE9
04D1C:  MOVLW  00
04D1E:  IORWF  FEF,W
04D20:  BZ    4D42
04D22:  MOVFF  FEA,1DF
04D26:  MOVFF  FE9,1DE
04D2A:  MOVFF  FEF,1E2
04D2E:  CALL   0462
04D32:  MOVFF  1DF,FEA
04D36:  MOVFF  1DE,FE9
04D3A:  INCF   FE9,F
04D3C:  BTFSC  FD8.2
04D3E:  INCF   FEA,F
04D40:  BRA    4D1C
04D42:  MOVLW  0A
04D44:  MOVLB  1
04D46:  MOVWF  xE2
04D48:  MOVLB  0
04D4A:  CALL   0462
04D4E:  MOVLW  01
04D50:  MOVWF  FEA
04D52:  MOVLW  A4
04D54:  MOVWF  FE9
04D56:  MOVLW  00
04D58:  IORWF  FEF,W
04D5A:  BZ    4D7C
04D5C:  MOVFF  FEA,1E1
04D60:  MOVFF  FE9,1E0
04D64:  MOVFF  FEF,1E2
04D68:  CALL   0462
04D6C:  MOVFF  1E1,FEA
04D70:  MOVFF  1E0,FE9
04D74:  INCF   FE9,F
04D76:  BTFSC  FD8.2
04D78:  INCF   FEA,F
04D7A:  BRA    4D56
....................          lastTick=currTick; 
04D7C:  BSF    58.2
....................          break; 
04D7E:  MOVFF  1DD,1DB
04D82:  MOVFF  1DC,1DA
....................  
04D86:  BRA    4DF2
....................       case LCD_STATE_WAIT: 
....................          if (TickGetDiff(currTick,lastTick) > (TICKS_PER_SECOND / 4)) 
....................             state=LCD_STATE_DISPLAY; 
04D88:  MOVLB  1
04D8A:  MOVF   xDD,W
04D8C:  SUBWF  xDB,W
04D8E:  BNC   4D98
04D90:  BNZ   4D9C
04D92:  MOVF   xDA,W
04D94:  SUBWF  xDC,W
04D96:  BNC   4D9C
04D98:  MOVLW  00
04D9A:  BRA    4D9E
04D9C:  MOVLW  01
04D9E:  CLRF   03
04DA0:  IORWF  03,W
04DA2:  BZ    4DCE
04DA4:  MOVLW  FF
04DA6:  BSF    FD8.0
04DA8:  SUBFWB xDA,W
04DAA:  MOVWF  xDE
04DAC:  MOVLW  FF
04DAE:  SUBFWB xDB,W
04DB0:  MOVWF  xDF
04DB2:  MOVF   xDC,W
04DB4:  ADDWF  xDE,W
04DB6:  MOVWF  xE0
04DB8:  MOVF   xDD,W
04DBA:  ADDWFC xDF,W
04DBC:  MOVWF  xE1
04DBE:  MOVLW  01
04DC0:  ADDWF  xE0,W
04DC2:  MOVWF  01
04DC4:  MOVLW  00
04DC6:  ADDWFC xE1,W
04DC8:  MOVWF  03
04DCA:  MOVF   01,W
04DCC:  BRA    4DDC
04DCE:  MOVF   xDA,W
04DD0:  SUBWF  xDC,W
04DD2:  MOVWF  00
04DD4:  MOVF   xDB,W
04DD6:  SUBWFB xDD,W
04DD8:  MOVWF  03
04DDA:  MOVF   00,W
04DDC:  MOVWF  xE2
04DDE:  MOVFF  03,1E3
04DE2:  MOVF   xE3,F
04DE4:  BNZ   4DEC
04DE6:  MOVF   xE2,W
04DE8:  SUBLW  02
04DEA:  BC    4DEE
....................          break; 
04DEC:  BCF    58.2
....................    } 
04DEE:  MOVLB  0
04DF0:  BRA    4DF2
.................... } 
....................  
04DF2:  GOTO   509C (RETURN)
....................  
.................... void main(void) 
.................... { 
....................  
04DF6:  CLRF   FF8
04DF8:  BCF    FD0.7
04DFA:  BSF    08.7
04DFC:  CLRF   FEA
04DFE:  CLRF   FE9
04E00:  MOVLW  70
04E02:  MOVWF  FD3
04E04:  MOVF   FD3,W
04E06:  BCF    FB8.3
04E08:  MOVLW  0C
04E0A:  MOVWF  FAF
04E0C:  MOVLW  A2
04E0E:  MOVWF  FAC
04E10:  MOVLW  90
04E12:  MOVWF  FAB
04E14:  MOVF   FC1,W
04E16:  ANDLW  C0
04E18:  IORLW  0F
04E1A:  MOVWF  FC1
04E1C:  MOVLW  07
04E1E:  MOVWF  FB4
04E20:  CLRF   49
04E22:  CLRF   4A
04E24:  CLRF   50
04E26:  CLRF   51
04E28:  CLRF   52
04E2A:  CLRF   53
04E2C:  CLRF   5A
04E2E:  CLRF   5B
04E30:  CLRF   5C
04E32:  CLRF   5D
04E34:  MOVLW  04
04E36:  MOVWF  5E
04E38:  BCF    58.1
04E3A:  MOVLB  1
04E3C:  CLRF   x15
04E3E:  CLRF   x16
04E40:  CLRF   x17
04E42:  CLRF   x18
04E44:  CLRF   x19
04E46:  CLRF   x1A
04E48:  CLRF   x1B
04E4A:  CLRF   x1C
04E4C:  CLRF   x1D
04E4E:  CLRF   x1E
04E50:  CLRF   x1F
04E52:  CLRF   x2A
04E54:  CLRF   x2B
04E56:  CLRF   x2C
04E58:  CLRF   x2D
04E5A:  CLRF   x2E
04E5C:  CLRF   x2F
04E5E:  CLRF   x30
04E60:  CLRF   x31
04E62:  CLRF   x32
04E64:  CLRF   x33
04E66:  CLRF   x34
04E68:  CLRF   x35
04E6A:  CLRF   x36
04E6C:  CLRF   x37
04E6E:  CLRF   x38
04E70:  CLRF   x39
04E72:  CLRF   x3A
04E74:  CLRF   x3B
04E76:  CLRF   x3C
04E78:  CLRF   x3D
04E7A:  CLRF   x3E
04E7C:  CLRF   x3F
04E7E:  CLRF   x40
04E80:  CLRF   x41
04E82:  CLRF   x42
04E84:  CLRF   x43
04E86:  CLRF   x44
04E88:  CLRF   x45
04E8A:  CLRF   x46
04E8C:  CLRF   x47
04E8E:  CLRF   x48
04E90:  CLRF   x49
04E92:  CLRF   x4A
04E94:  CLRF   x4B
04E96:  CLRF   x4C
04E98:  CLRF   x4D
04E9A:  CLRF   x4E
04E9C:  CLRF   x4F
04E9E:  CLRF   x50
04EA0:  CLRF   x51
04EA2:  CLRF   x52
04EA4:  CLRF   x53
04EA6:  CLRF   x54
04EA8:  CLRF   x55
04EAA:  CLRF   x56
04EAC:  CLRF   x57
04EAE:  CLRF   x58
04EB0:  CLRF   x59
04EB2:  CLRF   x5A
04EB4:  CLRF   x5B
04EB6:  CLRF   x5C
04EB8:  CLRF   x5D
04EBA:  CLRF   x5E
04EBC:  CLRF   x5F
04EBE:  CLRF   x60
04EC0:  CLRF   x61
04EC2:  CLRF   x62
04EC4:  CLRF   x63
04EC6:  CLRF   x64
04EC8:  CLRF   x65
04ECA:  CLRF   x66
04ECC:  CLRF   x67
04ECE:  CLRF   x68
04ED0:  CLRF   x69
04ED2:  CLRF   x6A
04ED4:  CLRF   x6B
04ED6:  CLRF   x6C
04ED8:  CLRF   x6D
04EDA:  CLRF   x6E
04EDC:  CLRF   x6F
04EDE:  MOVLW  45
04EE0:  MOVWF  x70
04EE2:  CLRF   x71
04EE4:  CLRF   x72
04EE6:  MOVLW  20
04EE8:  MOVWF  x73
04EEA:  CLRF   x74
04EEC:  CLRF   x75
04EEE:  CLRF   x76
04EF0:  CLRF   x77
04EF2:  MOVLW  64
04EF4:  MOVWF  x78
04EF6:  MOVLW  11
04EF8:  MOVWF  x79
04EFA:  MOVLW  2A
04EFC:  MOVWF  x7A
04EFE:  MOVLW  9D
04F00:  MOVWF  x7B
04F02:  MOVLW  0A
04F04:  MOVWF  x7C
04F06:  MOVLW  0B
04F08:  MOVWF  x7D
04F0A:  MOVLW  0C
04F0C:  MOVWF  x7E
04F0E:  MOVLW  0D
04F10:  MOVWF  x7F
04F12:  MOVLW  0A
04F14:  MOVWF  x80
04F16:  MOVLW  0B
04F18:  MOVWF  x81
04F1A:  MOVLW  0C
04F1C:  MOVWF  x82
04F1E:  MOVLW  0E
04F20:  MOVWF  x83
04F22:  MOVLW  04
04F24:  MOVWF  x84
04F26:  CLRF   x85
04F28:  MOVLW  04
04F2A:  MOVWF  x86
04F2C:  MOVLW  01
04F2E:  MOVWF  x87
04F30:  CLRF   x88
04F32:  MOVLW  08
04F34:  MOVWF  x89
04F36:  CLRF   x8A
04F38:  CLRF   x8B
04F3A:  MOVLW  01
04F3C:  MOVWF  x8C
04F3E:  MOVLW  02
04F40:  MOVWF  x8D
04F42:  MOVLW  03
04F44:  MOVWF  x8E
04F46:  MOVLW  04
04F48:  MOVWF  x8F
04F4A:  CLRF   xB8
04F4C:  CLRF   xB9
04F4E:  CLRF   xBA
04F50:  CLRF   xBB
04F52:  CLRF   xBC
04F54:  CLRF   xBD
04F56:  CLRF   xBE
04F58:  CLRF   xBF
04F5A:  CLRF   xC0
04F5C:  CLRF   xC1
04F5E:  MOVLW  FE
04F60:  MOVWF  xC2
04F62:  CLRF   xC3
04F64:  CLRF   xC4
04F66:  CLRF   xC5
04F68:  CLRF   xC6
04F6A:  CLRF   xC7
04F6C:  CLRF   xC8
04F6E:  CLRF   xC9
04F70:  CLRF   xCA
04F72:  CLRF   xCB
04F74:  CLRF   xCC
04F76:  CLRF   xCD
04F78:  CLRF   xCE
04F7A:  CLRF   xCF
04F7C:  CLRF   xD0
04F7E:  CLRF   xD1
04F80:  CLRF   xD2
04F82:  CLRF   xD3
04F84:  CLRF   xD4
04F86:  CLRF   xD5
04F88:  CLRF   xD6
04F8A:  CLRF   xD7
04F8C:  CLRF   xD8
04F8E:  CLRF   xD9
04F90:  CLRF   xDA
04F92:  CLRF   xDB
04F94:  BCF    58.2
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
....................    setup_adc(ADC_OFF|ADC_TAD_MUL_0); 
04F96:  MOVF   FC1,W
04F98:  ANDLW  C0
04F9A:  IORLW  0F
04F9C:  MOVWF  FC1
....................    setup_psp(PSP_DISABLED); 
04F9E:  BCF    FC2.0
....................    setup_spi(SPI_SS_DISABLED); 
04FA0:  BCF    F96.4
....................    setup_wdt(WDT_OFF); 
04FA2:  BCF    FC6.5
04FA4:  MOVLW  01
04FA6:  MOVWF  FC6
04FA8:  MOVLW  00
04FAA:  MOVWF  FC7
....................    setup_timer_0(RTCC_INTERNAL); 
04FAC:  BCF    FD1.0
....................    setup_timer_1(T1_DISABLED); 
04FAE:  MOVLW  80
04FB0:  MOVWF  FD5
....................    setup_timer_2(T2_DISABLED,0,1); 
04FB2:  CLRF   FCD
....................    setup_comparator(NC_NC_NC_NC); 
04FB4:  MOVLW  00
04FB6:  MOVWF  FCA
04FB8:  MOVLW  00
04FBA:  MOVWF  FCB
....................    setup_vref(FALSE); 
04FBC:  MOVLW  07
04FBE:  MOVWF  FB4
04FC0:  MOVF   F92,W
04FC2:  MOVWF  F92
04FC4:  MOVLW  06
04FC6:  MOVWF  00
04FC8:  DECFSZ 00,F
04FCA:  BRA    4FC8
04FCC:  NOP   
04FCE:  MOVF   FB4,W
04FD0:  BCF    FA1.6
.................... //Setup_Oscillator parameter not selected from Intr Oscillator Config tab 
04FD2:  CLRF   FB5
....................  
....................    // TODO: USER CODE!! 
....................     
....................     
....................  
....................    printf("\r\n\nCCS TCP/IP TUTORIAL, EXAMPLE 13B (TCP SERVER)\r\n"); 
....................    MACAddrInit(); 
04FD4:  CLRF   xDC
04FD6:  MOVF   xDC,W
04FD8:  MOVLB  0
04FDA:  CALL   01A2
04FDE:  MOVLB  1
04FE0:  INCF   xDC,F
04FE2:  MOVLB  0
04FE4:  CALL   0252
04FE8:  MOVLW  32
04FEA:  MOVLB  1
04FEC:  SUBWF  xDC,W
04FEE:  BNZ   4FD6
....................    IPAddrInit(); 
04FF0:  MOVLB  0
04FF2:  GOTO   025A
....................  
04FF6:  GOTO   0274
....................    init_user_io(); 
....................  
04FFA:  GOTO   02A2
....................    lcd_init(); 
....................    printf("deneme"); 
04FFE:  GOTO   0396
....................    delay_ms(3000); 
05002:  MOVLB  1
05004:  CLRF   xDC
05006:  MOVF   xDC,W
05008:  MOVLB  0
0500A:  CALL   01F0
0500E:  MOVLB  1
05010:  INCF   xDC,F
05012:  MOVLB  0
05014:  CALL   0252
05018:  MOVLW  06
0501A:  MOVLB  1
0501C:  SUBWF  xDC,W
0501E:  BNZ   5006
....................    sprintf(&lcd_str[0][0],"INIT"); 
05020:  MOVLW  0C
05022:  MOVWF  xDC
05024:  MOVLW  FA
05026:  MOVWF  xE3
05028:  MOVLB  0
0502A:  CALL   02CC
0502E:  MOVLB  1
05030:  DECFSZ xDC,F
05032:  BRA    5024
....................    sprintf(&lcd_str[1][0],"INIT"); 
05034:  MOVLW  01
05036:  MOVWF  xBD
05038:  MOVLW  90
0503A:  MOVWF  xBC
0503C:  CLRF   xDC
0503E:  MOVF   xDC,W
05040:  MOVLB  0
05042:  CALL   0212
05046:  MOVLB  1
05048:  INCF   xDC,F
0504A:  MOVWF  00
0504C:  MOVWF  xFD
0504E:  MOVLB  0
05050:  CALL   041A
05054:  MOVLW  04
05056:  MOVLB  1
05058:  SUBWF  xDC,W
0505A:  BNZ   503E
....................    lcd_putc('\f'); 
0505C:  MOVLW  01
0505E:  MOVWF  xBD
05060:  MOVLW  A4
05062:  MOVWF  xBC
05064:  CLRF   xDC
05066:  MOVF   xDC,W
05068:  MOVLB  0
0506A:  CALL   0212
0506E:  MOVLB  1
05070:  INCF   xDC,F
05072:  MOVWF  00
05074:  MOVWF  xFD
05076:  MOVLB  0
05078:  CALL   041A
0507C:  MOVLW  04
0507E:  MOVLB  1
05080:  SUBWF  xDC,W
05082:  BNZ   5066
....................  
05084:  MOVLW  0C
05086:  MOVWF  xE2
05088:  MOVLB  0
0508A:  CALL   0462
....................    StackInit(); 
....................  
0508E:  GOTO   0C1E
....................    while(TRUE) { 
....................       StackTask(); 
....................       MyTCPTask(); 
05092:  GOTO   3B5C
....................       LCDTask(); 
05096:  GOTO   4870
....................    } 
0509A:  BRA    4CEC
.................... } 
0509C:  BRA    5092
....................  
0509E:  SLEEP 

Configuration Fuses:
   Word  1: C900   IESO INTRC FCMEN
   Word  2: 0E19   NOBROWNOUT WDT128 NOWDT BORV21 NOPUT
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
